4_11_2017_CUMARTESÝ

C++'da formatlý giriþ çýkýþ iþlemleri sýnýf nesneleri ile yapýlýr. Giriþ ve çýkýþ akýmlarýný kontrol eden sýnýf nesneleri var.
cout nesnesi mesela standart outputu kontrol eden nesne. Global bir deðiþken gibi fakat bir sýnýf türünden.
cin ise standart giriþ akýmýný kontrol eden nesne. En yakýn karþýlýklarý C'deki yapý nesneleri. 
cin cout'da kaç tane left shift varsa o kadar fonksiyon çaðrýsý var. Burada hem operatör overloading hem de function overloading mekanizmasý var.
Operatör önceliðine dikkat etmek gerekir, leftshift operatörünün varlýðý nedeni ile duruma göre ifadeleri paranteze alýp öncelik verilmesi gerekebilir.(cout için)

REFERANS SEMANTÝÐÝ

C'de pointerlar var, bir fonksiyona nesnenin kendisini göndermenin yolu nesnenin adresini fonksiyona göndermek. C'de call by reference pointer semantiði ile yapýlýr.
C++'da pointerlar halen bulunmakla beraber referans denilen seviyesi yükseltilmiþ bir semantik var. Fakat derleyici makine düzeyinde pointer ve referans semantiði için
ayný kodu üretmekte. Adres ve içerik operatörü ile uðraþmaktan ziyade doðrudan bir isim kullanýlacak, bu referans ismi bir nesneyi temsil eden eþ isimden baþka þey deðil.
Referans bir nesnenin yerine geçen bir isim gibi. Referans ismini kullanmak demek o ismin yerine geçtiði nesneyi kullanmak. Geri planda derleyici yine adres tutup pointerý
dereference eder. Referans semantiðinin olmasý pointerlara olan ihtiyacý sýfýrlamaz, ancak C'de kullanýlandan çok daha az kullanýlýr. Pointer ihtiyacýný alanlardan biri referans
semantiði diðeri de smart pointerlar. Ýyi bir c++ kodunda kolay kolay pointer görülmez, çok fazla pointer kullanýlmýþ ise kod ya eski c++ kodudur ya da programcý henüz c++'nýn
avantajlarýný kullanamýyordur.

Referans oluþturulmadan herþeyden önce bir nesneye ihtiyaç var. Referans bu nesnenin yerine geçecek isim. Pointerlardan önemli farký; pointer göstereceði nesne olmadan yaratýlýp ona 
daha sonra bir nesnenin adresi atanabilir.Referans olan isim bildirilirken hangi nesnenin yerine geçeceði belirtilmeli. Referanslara ilk deðer vermek mecburi. References must be 
initialized.

int x = 10; 
int &r = x; 
Buradaki '&' bir operatör deðil deklaratör. Operatör ifadede deklaratör bildirimde olur. &, r'nin ne olduðunu anlatan ifadedir. r x'e bir referans. r'nin scope u içinde
r dediðim her yerde x i kullanmýþ olurum. Bir referans isim bildiriminde hangi nesne ile ilk deðerini almýþ ise scope'u içinde o nesnenin dýþýnda baþka ismin yerine geçemez. Tüm referanslar
top-level const. Kendisi const olan pointerlar þeklinde çalýþýr. 

int x = 10; 
int&r = x; 
int *ptr = &r; 
r x'in yerine geçiyor, r demek x demek dolayýsý ile ptr x'i gösteriyor. & deklaratör deðil operatör. Hangi nesne operand olmuþ ise onun adresini alýr, r de x e eþ
isim olduðuna göre x'in adresini alýr. 
*ptr = 99;
++r; //koda eklendiðinde x'in deðerinin 100 olduðu görülür. 


int x = 10;
int &r1 = x;
int &r2 = r1;
int &r3 = r2;
++r1, ++r2, ++r3;
Pointer to pointerlar olduðu gibi reference to reference deðil! r1, x'in yerine geçiyor, r2 referansý x yerine geçiyor, r3 de yine x'e referans olmuþ olur. x'in yeni deðeri 13 olacak.


int x = 10;
int &r;//error, references must be initialized.
Oluþturulan referansa ilk deðer verilmesi zorunlu, yoksa error.

int x = 10;
int *ptr = &x; //Buradaki * da deklaratör
int &r = *ptr; // int &r = ptr olsa sentaks hatasý
++r;
*ptr = x olduðu için r'de x yerine geçer. 

int a[] = { 1, 4, 5, 6, 2 };
int &r = a[2];
++r;
r dizinin 2 indisli öðesi olan nesnenin yerine geçen isim. Böylece dizinin 2 indisli elemaný 1 arttýrýlmýþ oldu. Pointer semantiðindeki gibi r++ sanki dizinin bir sonraki elemanýný gösteriyor gibi
bir durum söz konusu deðil.

int x = 10;
double &r = x;  //gecersiz
Nasýl ki bir pointer türü ile onun adresini tutacaðý nesnenin türü ayný olmak zorunda ise ayný þey referans semantiðinde de geçerli. Referans olarak seçilen ismi gösteren türle onun yerine geçeceði
nesnenin türü ayný olmalý. Tür farký compile time'daki kontrole tabi. 

int a[5] = { 2, 4, 5, 8, 3 };
int(&ra)[5] = a;
cout << sizeof(ra) / sizeof(*ra) << endl; //dizinin boyutu bu þekilde de hesaplanabilir.
C++'da dizilere de referans alýnabilir. a ya referans isim alýndý. a yerine ra ismi kullanýlacak demektir.

int x = 10;
int y = 34;
int *ptr = &x;
int *&r = ptr;
r = &y;
++*r;
r = &y; // r ptr demek olduðundan artýk ptr y'yi gösteriyor
++*r; // y bir artmýþ oldu çünkü r demek ye demek.
x T türünden bir nesne ise x e alýnan referansýn türü T &r = x þeklinde olur. Referans için yazýlan tür bilgisi x in türünden. ptr nesnesi int * türünden olduðu için int * &r = ptr;
Referans hangi türden nesnenin yerine geçecekse baþýna o tür yazýlýr ve ondan sonra referans deklaratörü konulup referansýn ismi yazýlýr.

C'de call by reference yapmanýn tek yolu pointer kullanmak, C++'da ise call by reference'da referans semantiði kullanýlýr. Ýkisnin kullanýmý arasýnda hiçbir fark yok sadece derleyici daha 
fazla kod üretir, referans semantiði makina kodunu etkileyen bir sentaks aracý deðil sadece kodu yazanýn iþini kolaytaþtýrýr.
/////////////////////////////////////////////////////////////////////
void func(int &r)
{
	r = 768;
}
/////////////////////////////////////////////////////////////////////
C'de de olduðu gibi fonksiyona yapýlan çaðrýda kullanýlan argüman parametre deðiþkenine atanmaz, parametre deðiþkenini initialize eder. Burada da r referansý fonksiyon çaðrýsýnda kullanýlan argüman
olan nesne ile initialize edilir. r fonksiyon çaðrýsýnda kullanýlan nesnenin yerine geçer. int türden bir x için func(x) þeklinde bir çaðrý yapýldýðýnda func fonksiyonunun referans olan parametresi, 
argüman olarak gönderilen x ile initialize edilir.

Bunun pointer karþýlýðý ise
/////////////////////////////////////////////////////////////////////
void func(int *const ptr)
{
	*ptr = 768;
} 
/////////////////////////////////////////////////////////////////////
C'de örnek olarak int x = 10; þeklinde bir yerel deðiþken oluþturuldu ve func(x) fonksiyonuna argüman olarak geçildi. Bu fonksiyonun koduna bakýlmaksýzýn x'in deðerini deðiþtirmesi 
mümkün deðildir. C++'da ise func(x) çaðrýsýna bakýlarak fonksiyonun call by value mu yoksa call by reference mi olduðuna karar verilemez Fonksiyonun bildiriminin de 
görülmesi gerekir. Parametre bildiriminde referans deklaratörünün olup olmamasý fonksiyonun call by value yada call by reference olduðunu gösterir. 
/////////////////////////////////////////////////////////////////////
void iswap_r(int &r1, int &r2) {

	int temp = r1;
	r1 = r2;
	r2 = temp;
} 
/////////////////////////////////////////////////////////////////////
referans semantiði kullanýlarak swap iþlemi yapan fonksiyon.

void func(int &x);
void foo(const int &r); 
func gönderilen nesneyi set eder. foo ise gelen nesneyi sadece okuma amaçlý kullanýr. bir referans da const olabilir, bu durumda okuma amaçlý bir ismin yerine geçme durumu vardýr. Bu anlamda
low level const ile ayný yapýdadýr.

int x = 10;
const int &r = x;
++r; //gecersiz
r x'in yerine sadece okuma amaçlý geçmiþ olur, bu durumda x'in deðerini r ismi ile deðiþtirmek mümkün deðil. 

const int x = 10; 
int &r = x;  //gecersiz, const int &r = x; olmasý gerekir. x zaten const deðeri deðiþtirilemez, referans yolu ile de deðerinin deðiþmemesi gerekir.

const int x = 10;
int *ptr = &x; //gecersiz
Ayný þey dönüþümler için de geçerli; const nesneden const olmayan pointer yada referansa dönüþüm sentaks hatasý. Bunun geçerli olabilmesi için madem x salt okunur bir nesne, x yerine geçecek
ismin de salt okunur amaçlý o nesnenin yerine geçilmesi gerekir.
const int x = 10;
const int &r = x;  

const int y = 10;
const int *ptr = &y;

NOT:
int x = 10, y = 5;
int * const p1 = &x; //top level const
const int * p2 = &y; //low level const
göstericinin kendisi const ise top level const, p1 baþka bir adresi tutamaz, kendisi const ancak gösterdiði adresteki nesnenin deðerini deðiþtirebilir
Yani, *p1 = 20; geçerlidir ancak p1 = &y; geçersiz.
low level const olma durumunda ise, gösterici baþka bir adresi gösterebilir, p2 göstericisi x'in adresini tutabilir, ancak *p2 = 30; geçersizdir,
gösterdiði adresteki nesnenin deðerini deðiþtiremez, kendisi deðil gösterdiði yer const.
Ayný þey referanslar için de geçerli, hiçbir farký yok.


fonksiyon parametrik yapýsý void func(int &r) ya da void foo(int *ptr) þeklinde ise bunlar set fonksiyonlarýdýr. 
fonksiyon parametrik yapýsý void func(const int &r) ya da void foo(const int *ptr) þeklinde ise bunlar sadece okuma amaçlý fonksiyonlardýr.

int x = 10;
int & const r = x;
Þeklindeki bir kod sentaks hatasý deðil ama anlam olarak orada const yazýlmasý anlamsýz. r'nin zaten baþka bir nesnenin isminin yerine geçmesi mümkün deðil. Referanslar zaten doðuþtan const.

int &r = x;
Þeklinde bir yazýmda r'nin türü aslýnda int &, fakat bir çok durumda bu göz ardý edilir, mademki r, x'in yerine geçiyor o zaman r nin de türü int gibi düþünülür.

Normal olarak bir referans r-value expressiona baðlanamaz, sentaks hatasý olur.
int &r = 10; // sentaks hatasý
const int &r = 10 // ise geçerli bir kod
void func(int &r) þeklinde bir fonksiyon func(10) gibi bir sabitle çaðýrýlamaz.
void func(const int &r) þeklinde bir fonksiyon ise rvalue deðer ile çaðrýlabilir. 

const int &r = 10; gibi bir ifadede derleyici kendi oluþturduðu kodda önce gider bir geçici nesne oluþturur.
//const int gn = 10;//derleyici geçici nesneyi oluþturur.
//const in &r = gn; //ve o referansý, kendi oluþturduðu geçici nesneye baðlar.
Aslýnda hiçbir zaman bir referans bir sabitin yerine geçmiyor. Bu þekildeki referanslar her zaman lvalue'nin
yerine geçiyor. Böyle bir fonksiyon çaðrýsýnda derleyici kendisi temporary bir nesne oluþturur. Burada referans derleyicinin oluþturduðu geçici nesnenin yerine geçer. Derleyicilerin bu amaçla
oluþturduðu geçici nesneler const kabul ediliyor dolayýsý ile void func(int &r) çaðrýldýðýnda derleyicinin oluþturmuþ olduðu const geçici referansa const olmayan bir isim atanmaya çalýþýlýr.Error.
const olmadýðýnda derleyicinin böyle bir nesne oluþturmamasýnýn sebebi, derleyicilerin bu amaçla oluþturduklarý geçici nesneler const kabul edilir. Bu durumda const bi nesneye const olmayan bir
referans baðlanmaya çalýþýlmýþ olurdu.


C++'da geri dönüþ deðeri referans olan fonksiyonlar adrese geri dönen fonksiyonlar olarak kullanýlýrlar. Bir fonksiyonun geri dönüþ deðerinin referans olmasý demek; bu fonksiyona yapýlan çaðrý
ifadesinin bir lvalue expression olmasý demektir. C'de func bir fonksiyon olmak üzere func fonksiyonuna yapýlan çaðrýnýn oluþturduðu ifade asla lvalue expr olamaz. Fakat c++'da func'un geri 
dönüþ deðeri referans ise lvalue expr'dir. Fonksiyonun geri dönüþ deðeri referans deðil ise rvalue expr'dýr. Bir fonksiyon çaðrý ifadesinin lvalue expr olmasý da referans semantiðinin en önemli
araçlarýndan. Fonksiyonun geri dönüþ deðeri referans ise, fonksiyon çaðrýsý doðrudan nesnenin yerine geçer.


C'de bunun en yakýn karþýlýðý ise, adres geri döndüren fonksiyonun çaðrýlmasý, oradan bir adres elde edilmesi ve o adresin dereference edilip, adresteki nesneye eriþilip o nesneye atama yapýlmasý.
/////////////////////////////////////////////////////////////////////
int g = 10;
int *foo()
{
	return &g;
}
int main(){
	*foo() = 99; // g, 99 yapýlmýþ oldu.
	
	++*foo(); // g'nin deðeri bir artmýþ oldu.
}
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
int g = 10;

int &foo(){
	return g;
}
int main(){
	foo() = 99; //global g, 99 yapýldý. Fonksiyona yapýlan çaðrý ifadesi doðrudan bir nesneye karþýlýk geldi.
	++foo(); // C'de asla mümkün deðil.

}
/////////////////////////////////////////////////////////////////////
main içinde foo() = 99; demek g = 99 demektir. ++foo() ise g'nin deðerini bir arttýýr. Fonksiyon otomatik ömürlü bir nesnenin adresi ile geri dönmemeli. Referans semantiði de kullanýlsa pointer
semantiði de; adrese dönen fonksiyonlar, otomatik ömürlü yerel nesnenin adresi ile geri dönmemeli --> Run Time Error. Referans ile: statik ömürlü nesne ile, dinamik ömürlü bir nesne ile geri
dönülebilir ve de client koddan alýnan nesne client koduna geri verilmek üzere iþlevde referans ile geri dönülebilir.Fonksiyonun geri dönüþ deðerinin türünün referans olmasý demek bu fonksiyona 
yapýlan çaðrý ifadesinin bir lvalue expression olmasý demektir. Fonksiyon çaðrý ifadesinin doðrudan lvalue  expr olmasý referans semantiðinin temel özelliklerinden biri. C'de fonksiyon çaðrýsý 
her zaman rvalue'dir.

/////////////////////////////////////////////////////////////////////
int &func()
{
	cout << "bir tamsayý giriniz : " ; 
	static int x;
	cin >> x;
	
	return x;
}

int main()
{
	int &r1 = func();
	int &r2 = func();
	int &r3 = func();
}
/////////////////////////////////////////////////////////////////////
Yukarýdaki kod örneðinde r1, r2 ve r3 statik ömüklü x'in yerine geçer. Örnek kodda fonksiyona 3 kez çaðrý yapýlýyor, ancak en son r3 ne ise r1 ve r2'de o olmuþ olur çünkü hepsi x'in yerine geçiyor.


Çok daha sýk karþýlaþýlan bir durum ise: Hem refeans döndüren hem de parametresi de referans olan fonksiyonlar. Fonksiyon aldýðý nesne üzerinde bir takým iþlemler yaptýktan sonra o nesneyi geri
döndürür. Bu fonksiyona yapýlan çaðrý ifadesi ayný zamanda bizim aldýðýmýz nesnenin kendisi. User Defined türler de en çok kullanýlan konvensiyonlardan biri.
T &func(T &r) þeklindeki fonksiyonlar:
/////////////////////////////////////////////////////////////////////
struct Date {
	int md, mm, my;
};

Date &setDate(Date &r, int d, int m, int y)
{
	r.md = d;
	r.mm = m;
	r.my = y;

	return r;
}

void display(Date &r){

    cout << r.md << "/" << r.mm << "/" << r.my << endl;

}

int main()
{
    Date mydate;
 
    display(setDate(mydate, 14, 10, 1994)); //setDate fonksiyonunun geri dönüþ deðeri Date & olduðundan display fonksiyonuna doðrudan argüman olarak gönderilebilir.

    return 0;
}
/////////////////////////////////////////////////////////////////////

setDate fonksiyonu kendisine gönderilen struct Date türünden nesneyi set edip, o nesnenin kendisini geri döndürür. T bir tür olmak üzere:
void func(T &r) parametresi T referans olan fonksiyonlar: bir nesneyi deðiþtirme amaçlý isteyen fonksiyonlar
void func(const T &r) parametresi const T referans olan fonksiyonlar: bir nesneyi salt okuma amaçlý kullanacak fonksiyonlar
T &func(...) geri dönüþ deðerinin türü T referans olan fonksiyonlar: bir nesnenin kendisini döndüren fonksiyonlar. Bu fonksiyona yapýlan çaðrý ifadesi bir lvalue exprdir.
const T &func(...) geri dönüþ deðeri yine bir nesne ancak, türü const T referans olduðundan fonksiyon nesneyi salt okuma amaçlý kullanýlacak þekilde geri veriyor.

Nesneye referansýn kendisi ok operatörü ile kullanýlamaz, ancak nesneyi gösteren bir pointerý tutan bir referans olur ise ok operatörü kullanýlabilir.

	Data mydata;
	Data *ptr = &mydata;
	Data *&r = ptr; //r demek ptr demek olduuðundan r ok operatörünün operandý olabilir.
	r->x = 10;

Referanslar ile Pointerlarýn Karþýlaþýrýlmasý:
Bir pointer deðiþken ilk deðer vermeden oluþturulabilir ancak bir referans ilk deðer vermeden oluþturulamaz.
int *ptr; þeklinde bir pointer deðiþken tanýmlanabilir(ptr'nin kendisi const olmadýðý sürece). Ancak int &r; þeklinde bir referans ilk deðerini almadan oluþturulamaz.

Bir pointerýn kendisi const olmak zorunda deðil. Kod içerisinde pointer farklý nesneleri gösterebilir. Hep ayný nesneyi gösterecekse int *const ptr = &x; bu þekilde tanýmlanýr.
Referanslar zaten kendisi const pointerlara karþýlýk gelir. Ayný kod içerisinde bir referans ismin baþka bir nesnenin yerine geçme ihtimali yok. Referans semantiði kendisi const pointerlarýn
karþýlýðý.
	int x = 10; 
	int *const ptr = &x; // kendisi const pointer, referansýn karþýlýðý.
	int &ref = x;

	int x = 0, y = 0, z = 0;
	int *p[] = { &x, &y, &z }; // pointer array, elemanlarý gösterici olan dizi
	//int &ra[] = { x, y, z };  // GEÇERSÝZ
Þeklinde elemanlarý pointer olan bir dizi oluþturulabilir ancak elemanlarý referans olan bir dizi oluþturulamaz.

	int x = 10;
	int *p = &x;
	int **ptr = &p;
ptr de bir pointer, o da bir pointeri gösteriyor. Pointer to pointer denen araç geçerli ancak reference to reference diye bir araç yok.(Olmasý durumunda dilin ileride görülecek baþka kurallarý
mevcut)		
	
Bir pointer null pointer deðerinde olabilir. Malloc, fopen, geri dönüþ deðeri adres olan bazý foknksiyonlarda null pointer kullanýlýr. Ancak null reference yok.
referans mutlaka bir nesneye baðlanmak zorunda. Geri dönüþ deðeri adres olan fonksiyonlarda, iþin yapýlamamasý durumunda null adres dönülmesi yaygýn fakat referans semantiðinde 
böyle bir durum söz konusu deðil. Referans semantiðinde iþin yapýlamamasý durumunda yapýlacak tek durum exepction throw etmek.

	int x = 10;

	cout << "&x  = " << &x << endl;
	int *ptr = &x;
	cout << "ptr = " << ptr << endl;
	int &r = x;
	cout << "&r  = " << &r << endl;
Hepsi için ayný adres yazýlýr, referans bir eþ isimdir, ayrý bir nesne olmadýðýndan &r demek = &x demektir.

	int &r = 10; //geçersiz
	int &&r = 10; //r-value references
C++ 11 den itibaren, sað taraf referansý denen yeni araç geldi. Bir sað taraf deðerinin yerine geçen referans. C++ ile beraber lvalue ve rvalue olmak üzere aslýnda iki tip referans var.
Sað taraf referanslarý daha önce C++'da yapýlamayan taþýma semantiði(move semantic), perfect forwarding mekanizmalarýnýn yapýlmasýný saðlar. C++11 öncesi implemente edilemeyen durumlardý.


auto keyword'u : Türün ne olduðunu derleyice açýk açýk söylemek yerine, derleyicinin bunu compile time'da kendisinin anlamasýný saðlar. 

	auto x = expr; // genel biçimi, derleyici ilk deðerin türüne bakar, o tür ne ise x in de o türden tanýmlandýðýný kabul eder.

	auto x = 0;  //x is int;
	auto y = 0L;  //y is long
	auto z = 0.F;  //z is float
	auto t = 0.;  //t is double

auto keywordü ilk deðer vermeyi zorunlu kýlar. auto keywordu kullanýlarak oluþturulan nesnelere ilk deðer verilmesi zorunludur. Böylece ilk deðer vermeme nedeni ile oluþan kodlama hatalarý 
önlenmiþ olur. 
(auto'nun c'deki anlamý otomatik ömürlü olmayý gösterir. C'deki kullanýmý ile C++'daki kullaným tamamen farklý.)

int *foo() þeklinde tanýmlanmýþ bir fonksiyon olsun, mainde ise auto x = foo(); ifadesinde x'in türü int * olur.

/////////////////////////////////////////////////////////////////////
#include <iostream>
#include <list>
#include <forward_list>
#include <string>

using namespace std;
list<pair<list<int>::iterator, forward_list<string>>> foo();

int main()
{
	list<pair<list<int>::iterator, forward_list<string>>> x = foo(); //eskiden olsa böyle uzun uzun yazýlmasý gerekirdi.
	auto y = foo(); // uzun ve kompleks tür isimleri yazmak yerine bu çýkarýmlarý derleyicinin yapmasý saðlanýr.
}
/////////////////////////////////////////////////////////////////////
Benzer kodda fonksiyonun geri dönüþ deðerinin türü deðiþtirildiðinde, x deðiþkeninin de türünün deðiþtirilmesi gerekir, yoksa geçersiz olur. Ancak x auto ile nitelenmiþ ise derleyici otomatik
olarak x'i fonksiyonun geri dönüþ deðeri türünden tanýmlar.

Modern C++'da çoðu kodda deðiþkenlerin tür bilgisini yazmak yerine direk auto keywordu ile kullanýlýr.


	//int x = 10; 	//yerine;
	int x(10);	//C++'da eskiden beri zaten var.
	//int &r = x; 	//yerine;
	int &r(x); 	//Bu þekilde ilk deðer verme sentaksý önceden beri C++'da mavcut.

C++11 ile gelen ise: artýk ilk deðer vermede parantez kullanýlan her yerde küme parantezi kullanmak da legal. --> Uniform Ýnitalizer(C++11)

	int x{ 10 };
	int a[]{ 1, 5, 65, 7 }; 
	int &r{ x };
	int *ptr{ &x };

dval double türden. x = dval yapýlýnca x = 5 olur burada veri kaybý var. Bu tür dönüþümlere narrowing conversion denir(daraltýcý dönüþüm). C++11 den önceki C++ da daraltýcý dönüþüm ilk deðer verme 
yolu ile olursa legaldi. Fakat uniform initializer(tek biçimli ilk deðer verme) kullanýlýrsa narrowing conversion error.
	double dval = 5.6;
	int x = dval;
	int y(dval);
	int z{ dval }; //error, 


VARSAYILAN ARGÜMAN KULLANILMASI(DEFAULT ARGUEMENT)

C'de yok fakat çoðu programlama dillerinde mevcut(C++, C#, Java)
Modern programlama dilleri þöyle bir mekanýzma sunar: Fonksiyonun parametre sayýsýndan daha az sayýda argüman ile çaðrý yapýldðýnda argüman gönderilmeyen parametreler için önceden belirlenmiþ
bir takým deðerlerin fonksiyona geçilmiþ olduðunu kabul ediyor. "Bu parametreye ya bi argüman geçersin, geçmezsen ben þu deðeri geçtiðini kabul edeceðim". Buradaki "þu" deðer default argüman.

Tamamen compile time'a iliþkin bir özellik. Varsayýlan argüman kullanýlmasý Run time maliyetini arttýrmaz ya da azaltmaz.
Özellikle bazý programlama domainlerinde en baþta GUI programlarý ve iþletim sistemi apileri fonksiyonlarýnýn bazýlarýnýn çok sayýda parametresi var. Böyle fonksiyonlarýn büyük kýsmý belirli
parametrelere hep ayný deðerlerin geçilmesine dayalý. Örnek olarak bir pencere fonksiyonunda standart bir pencere için 5. 6. 8. 10. parametrelere argüman geçilmesine gerek olmayabilir.
Client kodu yazan programcýnýn iþini kolaylaþtýrma amaçlý bir mekanizma. Daha az þey bilip, daha az deðer göndererek hata yapma riskini de azaltýr. 

Standart kütüphanenin de varsayýlan argüman alan bir çok fonksiyonu mevcut. Varsayýlan argüman mekanizmasý tamamen interface'e yönelik, implementasyon ile hiç alakasý yok. Baþlýk dosyalarýnda 
karþýmýza çýkacak. Yani bir kütüphane varsayýlan argüman kullanma olanaðý vermiþ ise bu varsayýlan argüman baþlýk dosyasýnda görülür. Baþlýk dosyasý include edildiðinde varsayýlan argüman
kullanma hakkýný elde etmiþ oluruz.

void func(int, int, int = expression);
void func(int, int, int = 10);
func öyle bir fonksiyon ki, üçüncü parametreye argüman geçilmeden iki argümanla da çaðrýlabilir. Bu durumda üçüncü argüman için default argüman geçilecek. Varsayýlan argüman olan ifadenin constant
expression olmasýna gerek yok herhangi bir ifade olabilir. Üç parametreye de deðer gönderildiðinde o zaman üçüncü parametre için de gönderilen argümaný alýr, 3. parametreye argüman geçilmediði 
taktirde ona default argüman muamelesi yapýlýr.

void func(int, int = 20, int = 30) için;
func(100, 500, 700);  //100 500 700
func(100, 500); //100 500 30
func(100);  //100 20 30

void func(int = 10, int = 20, int = 30) için ise func() çaðrýsý, func(10, 20, 30) çaðrýsýna denktir.

Bildirimde varsayýlan argüman kullanýlmýþsa, tanýmda tekrar etmeyecek. Tanýmda tekrar etmesi sentaks hatasý. 
Yani void func(int, int, int = 10); þeklinde bildirilmiþ fonksiyonuun tanýmý: void func(int x, int y, int z){} þeklinde olmalýdýr. Tanýmý normal fonksiyon tanýmý þeklinde yapýlýr. Bildirim void func(int a, int b, int c = 10)
þeklinde de yapýlabilirdi.
 

Bir fonksiyonun bir parametresi varsayýlan argüman alýrsa onun saðýndaki tüm parametrelerin de varsayýlan argüman almasý gerekir. 
void func(int, int = 20, int = 30); //gecerli
void func(int, int = 20, int); //gecersiz, bildirim geçersiz

 
Varsayýlan argüman bir pointera yada bir referansa da verilebilir. 
void func(int x,  const char *pEr = "error!"); 

func(10) // func(10, "error!") çaðrýsýna denk

int g = 56; //global deðiþken
void func(int x, int &r = g);

func(10);   //func(10, g);

Not: Referansýn ömrü diye bir þey yok. Ancak referansýn yerine geçtiði nesnenin ömrü olabilir. Referansýn scope'u devam ettiði sürece o referansýn yerine geçtiði nesnenin ömrünü devam ettirir.

Bir fonksiyonun varsayýlan argümaný baþka bir fonksiyonun geri dönüþ deðeri de olabilir.
int f1(int x = 10, int y = 20);
int f2(int a, int b = f1());

f2(23); //derleyicinin dönüþtürdüðü: f2(23, f1(10, 20)); (compile time'da)

Bir bildirimin üstüne, yeniden bildirim yaparken varsayýlan argüman eklenebilir.
//onder.h
void func(int x, int y); //onder.h'daki fonksiyon bildirimi.
//sinan.cpp
//#include "onder.h"
void func(int, int = 0); //örnek olarak sinan.cpp'de bu func fonksiyonunun ikinci parametresine çoðu zaman belli, hep ayný argüman gönderilecek, ancak onder.h'daki bildirime bakýldýðýnda
herhangi bir varsayýlan argüman kullanýlmamýþ. Bu durumda ikinci bir bildirim yapýlýr ve varsayýlan argüman kullanýlýr. Derleyici önce onder.h'daki ardýndan varsayýlan argüman almýþ bildirimi
gördüðünden, ikinci bildirimi fonksiyon bildirimi olarak görür. Bu function overloading deðil, redecleration, ayný fonksiyonun bildirimi bir kez daha gösterildi.

func(987); //func(987, 0) çaðrýsýna dönüþtürülür.


//onder.h
void func(int x, int y, int z = 10);
//sinan.cpp
//#include "onder.h"
void func(int, int = 20, int); //Tek baþýna bu olmuþ olsa idi sentaks hatasý çünkü ikinci parametre default argüman almýþken saðýndaki parametrelerin de default argüman
almasý gerekir ancak derleyici önce onder.h daki fonksiyon bildirimini gördüðünden orada zaten üçüncü parametreye default argüman geçilmiþ. Derleyici bu iki bildirimi 
birleþtirir o yüzden geçerli.Ancak sinan.cpp deki bildirim void func(int, int = 20, int z = 20) þeklinde olsa idi error, çünkü varsayýlan argümanýn tekrar edilmesi hangi
deðer olduðunun bir önemi olmaksýzýn geçersiz. Yani ikinci bildirimde 3. argüman varsayýlan argüman olarak ayný deðeri almýþ olsaydý da error olurdu.

func(1);  //func(1, 20, 10) anlamýna gelir.

//onder.h
void func(int x, int y, int z);
Burada örnek olarak cpp dosyasýnda bu fonksiyonun ikinci parametresine hep default argüman geçilmek isteniyor.
void func(int x, int y = 10, int z); //Geçersiz çünkü bu durumda üçüncü parametrenin de default argüman almasý gerekir.
Bu durumda sarmalayýcý fonksiyon yazýlmasý gerekir.
//sinan.cpp
void myfunc(int x, int z, int y = 10)
{
	func(x, y, z);
}

Örnek olarak bir possix fonksiyonu olan itoa fonksiyonu. C'de stdlib baþlýk dosyasý altýnda bulunur.
itoa; bir tamsayýyý yazýya dönüþtüren fonksiyon. Birinci parametre yazýya dönüþtürülecek tamsayý, ikinci parametresi yazýnýn dönüþtürüleceði dizinin adresi, üçüncü parametresi ise hangi
sayý sisteminde sayýnýn yazýya dönüþtürüleceði. Bir çok kodda onluk sayý sisteminde çalýþýldýðýndan, C deðil de C++ olsaydý varsayýlan argüman olarak 10 verilebilirdi. Çoðu zaman set
parametrelerinin birinci parametre olmasý tercih edilir, birinci parametrenin char * olmasý, ikinci parametrenin int türden bir sayý olmasý tercih edilebilir.
Bu durumda;
//necati.h
void mitoa(char *buffer, int val, int radix  = 10);
//necati.cpp
char * mitoa(char *buffer, int val, int radix)//varsayýlan argüman bildirimde olduðundan tanýmda tekrar edilmemeli
{
	return itoa(val, buffer, radix);
}//tipik bir sarmalayýcý örneði, hem varsayýlan argüman verildi, hem de parametrik yapý deðiþtirildi.

//date.h
void processDate(int d = 0, int m = 0, int y = 0);
Burada sadece implementasyon varsayýlan argüman kullanýlýp kullanýlmadýðýný bu deðerler ile check edebilir. Örnek olarak yýla, 3.parametreye deðer geçilmez ise bulunulan yýl kullanýlýr. Yine birinci
ve ikinci parametreye deðer geçilmediðinde sýrasý ile bulunulan gün ve ay bilgileri geçilecek. Burada varsayýlan argüman dinamik.
Fonksiyonun kodu düþünüldüðünde ise;
#include <iostream>
#include <time.h>

using namespace std;
//date.h
void processDate(int d = 0, int m = 0, int y = 0);

int main()
{
    processDate();
    processDate(15);
    processDate(15, 2);
    processDate(15,2, 1989);
    
    return 0;
}
void processDate(int d, int m, int y){
    if(y == 0){
		time_t timer = time(nullptr);
		tm *tp = localtime(&timer);
		y = tp ->tm_year + 1900;
	if(m == 0){
		m = tp-> tm_mon + 1;
	if(d == 0)
		d = tp->tm_mday;
		}
	}

    cout << d << "/" << m << "/" << y << endl;
}



5_11_2017_PAZAR

int &foo(int &r){

    ++r;

    return r;

}
int main()
{
    int a = 10;

    foo(a) += 45;

    cout << a << endl;

    return 0;
}

Yukarýdaki kodun C'deki karþýlýðý;

int *foo(int *p){

    ++*p;

    return p;

}
int main()
{

    int a = 10;

    *foo(&a) += 45;

    cout << a << endl;

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int g = 10;

int &foo(){

	return g;
}

int main(){
	int &x = foo(); // x demek g demek, int x = foo() olsa idi, x demek g demek olmazdý, g'nin deðeri x'e kopyalanmýþ olurdu
	x = 15; // g, global nesnesi 15 oldu
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int g = 10;

int foo(){

	return g;
}
res
int main(){

	int &x = foo(); //sentaks hatasý
}
sentaks hatasý olmasýnýn sebebi, artýk fonksiyon çaðrý ifadesi bir lvalue expression deðil. Bir fonksiyon çaðrý ifadesinin lvalue expression olabilmesi için referans döndürmesi gerekir.
Eðer fonksiyonun geri dönüþ deðeri T & deðilde T ise, o zaman fonksiyon çaðrý ifadesi lvalue expression deðil rvalue expressiondur.
C++11 ile gelen özelliklerden biri de, rvalue expressionlarýn da baðlanabileceði rvalue referanslar.
int &&x = foo(); // geçerli

 
FUNCTION OVERLOADING

Birden fazla ayný isimde fonksiyon olmasýnda derleyiciyi zorlayan tarafý, fonksiyonlarýn bir arada olmasý deðil, fonksiyon çaðrýsý yapýldýðýnda derleyicinin fonksiyonlar arasýndan 
istenen fonksiyona çaðrýyý baðlamasý. Derleyicinin bu süreci function overload resolution denir. Derleyicinin compile time'da n tane ayný isimli fonksiyon varken, bu fonksiyonlardan hangisinin
çaðrýrýlacaðýnýn anlama süreci. C'de bu mekanizmanýn olmamasýnýn en büyük sebebi derleyicisinin oldukça küçük tutulmaya çalýþýlmasý, bu tür mekanizmalar ancak derleyicinin büyük olmasý ile mümkün.

Standart kütüphane tarafýndan da oldukça yoðun kullanýlan bir mekanizma. Ayný isimle çok fazla overload stl de mevcut.

Function Overloading'in fonksiyon çaðrýsý ile hiçbir alakasý yok. Function overloading var mý yok mu sorusunun cevabý fonksiyon çaðrýsý ile ilgili deðil. Fonksiyonlarýn bir arada bulunmasý ile ilgili.
Function Overloading çalýþma zamanýna gelen ek bir maliyet deðil. Derleyici hangi fonksiyonun çaðýrýldýðýný compile time'da anlar. Compile time'da ek bir yük getirir. Derleyici derleme zamanýnda hangi
fonksiyonun çaðrýldýðýný anlamak için bir süreci yürütmek durumunda.

Bir fonksiyon çaðýrýldýðý zaman çaðrýlan fonksiyonun hangi fonksiyona baðlanacaðý yani çaðrýlan fonksiyonun ne olduðunun anlaþýlmasý, a) compile time'da yapýlabilir b)run time'da yapýlabilir.
Eðer hangi fonksiyonun çaðýrýldýðý compile time'da anlaþýlýyorsa buna static binding ya da early binding denir.(erken baðlama). Function Overloading early binding çünkü sonuçta isimleri ayný da olsa
derleyici compile time'da hangi fonksiyonun çaðýrýldýðýný anlýyor. 

C'de function overloading olmamasýnýn sebebi, derleyicinin küçük tutulmak istenmesi. Function overloading mekanizmasý olsa idi, bu bir takým kurallar getirecekti, ayný isimli fonksiyonlar arasýndan
bir eleme iþlemi sonucunda o fonksiyonlardan biri çaðýrýlacak bu da derleyici açýsýndan ekstra kod yükü demek.

C++,C#, Java gibi dillerde (OOP'a destek veren dillerde), nesne yönelimli programlamanýn en önemli bileþenlerinden birini implemente etmekte kullanýlan araç: dynamic binding ya da late binding. Hangi 
fonksiyonun çaðýrýldýðýnýn derleme zamanýnda deðil programýn çalýþma zamanýnda anlaþýlmasý. Run Time Polymorphism tamamen hangi fonksiyonun çaðrýldýðýnýn programýn çalýþma zamanýnda anlaþýlmasý ile 
implemente ediliyor. Kod ise her zaman compile time'da üretilir. Compile time'da derleyici hangi fonksiyonun çaðrýldýðýný ismen anlayacak ve bilecek çaðrýyý ona baðlayacak. Ama diðerinde derleyici öyle bir
kod üretecek ki, o kod run time çalýþtýðýnda hangi fonksiyonun çaðrýldýðý anlaþýlacak. Function overriding dinamik baðlama. Function overloading ise static binding, early binding.

Function Overloading için 2 koþul var.
1)Ýsimler ayný scope'da olmalý. Farklý scope'da bildirilen ayný isimli fonksiyonlar birbirini overload etmez. (Kalýtým konusunda çok önemli olacak taban sýnýfýn ayný isimli fonksiyonu ile child
classýn ayný isimli fonksiyonlarý birbirini overload etmez çünkü scopelarý farklý.)
2)Ýmzalarý farklý olacak. Ýmza = fonksiyonun parametrik yapýsý fakat buna fonksiyonun geri dönüþ deðerinin türü dahil deðil. Kaç parametresi var ve he her bir parametre deðiþkeninin türü ne ?

void func(int);
void func(int); //function redeclaration
Eðer imzalarý ayný olmakla beraber ayný scopeda bildirilen fonksiyonlarýn geri dönüþ deðerlerinin türü de ayný ise bu function overloading deðil, redeclarationdur ve legaldir.

void func(const int)
void func(int)
Function Overloading deðil, kendisi const, top level constluk bir imza farklýlýðý olarak görülmez. Top level constluk her zaman function redeclarationdur. F.O olup olmadýðýný anlamak için: Bunlarýn bildirimi
redeclaration, fakat eðer ayný fonksiyonlar ise ayný fonsiyona iki ayrý taným verilemez. Function Overloading olsa idi derleyici iki ayrý fonksiyon tanýmýna izin verirdi. Fakat bu durumda iki ayrý tanýma
derleyici izin vermez.
void func(const int)
{
}
void func(int)
{
}
//Error, function overloading olmadýðýndan derleyici iki ayrý fonksiyon tanýmýna izin vermez, sentaks hatasý.


Call by reference yolu ile, kendi nesnemi gönderdiðim iþlevler dýþýnda, fonksiyonun bildiriminde const nesne olmasý anlamsýz, örnek:
int func(const int x){} // bu þu demek: "ben kendi parametetre deðiþkenimi deðiþtirmeyeceðim" anlamýna gelir, zaten kopya. Const semantiðinde önemli olan ben bir nesne göndereceksem o deðiþecek mi 
deðiþmeyecek mi? Pointer, referans parametre olmadýðý sürece parametrenin const olup olmamasýnýn hiçbir anlam yok. 

Function Overloading deðil, buradaki const kendisi const pointer. Ýkisine ayrý taným vermeye çalýþýlsa sentaks hatasý. Function overloading için birinin low level const olmasý gerekir.
void func(int *const ptr);
void func(int *ptr); //Function Redeclaration


typedef int Word;
typedef int Neco;

void func(Word);
void func(Neco);    //redeclaration
Ýkisi de int, farklý typedef isimleri function overloading yaratmaz. typedef bildirimleri ayný türe farklý isim oluþturur.


int func(int, int);
double func(int, int); //error
Ýmzalar ayný fakat geri dönüþ deðerlerinin türleri farklý. Bu durum sentaks hatasý. Type mismatch in redeclaration. Derleyici bunu redeclaration edilmeye çalýþýlýrken geri dönüþ deðeri türlerinin
farklý yazýlmýþ olduðunu düþünür. Error olan derleyicinin ikinci bildirimi görmesi.

Farklý scope'daki isimler birbirini overload etmez, birbirini gizler(hide, mask). Ayný isimde farklý scopelarda iki fonksiyon tanýmlandýðýnda, derleyici bu isim kullanýldýðýnda arama, name look-up yapar.
Name look-up unda bir sýrasý var, isim belirli bir sýraya göre aranýr, aranan isim bulununca isim arama biter. Derleyici bir scope'daki ismi bulduðunda arama bitecek ve zaten derleyici diðer scope'daki
ismi görmeyecek bile.

Function overloading:
void func(int); //call by value
void func(int &); //call by reference

Function overloading: geri dönüþ deðerleri ayný da olabilir, farklý da.
void func(int);
double func(int &);

Function overloading (const overloading) Öncekiler ile ayný deðil, öncekilerin kendisi const'du. Bu low level const.
void func(int *); //T * parametreli, nesneyi set amaçlý kullanacak
double func(const int *); // const T * parametreli, nesneyi okuma amaçlý kullanacak
Bu ikisi bir arada bulunabilir bu yüzden function overloading.

Function overloading (referans semantiði ile yapýlmýþ const overloading)
void func(int &r);
double func(const int &r);

Function overloading, varsayýlan argüman almasý parametre sayýsýný deðiþtirmez. Default argument alsa da almasa da ilk fonskyionun 1 parametresi var.
void func(int x = 10);
void func();
Parametre sayýlarý farklý, doðal olarak imzalarý farklý, function overloading.

C++'da fonksiyon bildirimi yaparken void func() ile void func(void) arasýnda hiçbir fark yok. C'de void func() demek parametresi yok demek deðil, func'un parametrik yapýsý ile ilgili bilgi
verilmiyor demek. 

3 tane overload var
void func(int x, int y = 10);
void func(int y);
void func(int, ...); 
Variyatik fonksiyon olmasý, variyatik olmayan fonksiyonlara göre overload yaratýr. 


Function Overloading Resolution

Ayný isimli fonksiyonlardan hangisinin derleyici tarafýndan çaðrýlacaðýnýn anlaþýlmasý süreci. Ortada function overloading olmasý ayný isimli fonksiyonlarýn çaðrýsýnýn legal olacaðý anlamýna gelmez. 
Resolution, error ile de sonuçlanabilir. Ýki farklý illegalite durumu var. Ortada örnek olarak 4 fonksiyon var ancak yapýlan fonksiyon çaðrýsý hiçbirine denk düþmüyor, yani bu fonksiyonlardan herhangi
biri tek baþýna olmuþ olsa idi de error olacaktý. Örnek olacak func fonksiyonu çaðýrýldý, çaðrý bir parametre ile yapýldý ancak bildirilen fonksiyonlarýn parametre sayýlarý 2,3 ve 4. Ortada function over
loading var ama bu fonksiyonlardan hiçbiri çaðrýya uymuyor.(Nomatch)

Ýkinci illegalite durumu ise, derleyicinin 2 fonksiyon arasýnda hangisinin çaðrýlacaðýna dilin kurallarý çerçevesinde karar verememesidir. Eligibility yok, yani birinin çaðrýlmasý için diðerine üstünlüðü
yok, seçicilik kriteri yok(ambiguity). Bu fonksiyonlardan her biri tek baþýna olsa problem yok, legal fakat ikisi bir arada olduðu zaman derleyici 2'si arasýnda bir seçime gidemiyor.
(Çift Anlamlýlýk Hatasý)

no match error								
void func(int);
void func(int, int);
void func(int, double);
int main()
{
	func(); // no match error
}
Overloading var, ama çaðrý bu fonksiyonlardan hiçbirine uymuyor. Fonskyionlar tek baþýna olmuþ olsa idi de legal olmayacaktý. 


//Ambigious call to overloaded functions.
void func(int)
void func(long double)
int main()
{
	func(10U); //unsigned int ile çaðrý yapýldý.
}
Fonksiyonlar tek baþlarýna bulunsa legal ama ikisi bir arada bulunduðunda aralarýnda bir seçicilik kriteri yok.

Eðer bir argüman bir parametre deðiþkenine legal olarak aktarýlýyorsa, compile time'da bu tek olsa idi problem olmayacaktý.

Derleyici Function Overload Resolution'u kendi içinde 3 alt sürece ayýrýr, önce a süreci sonra b süreci ondan sonra c sürecini gerçekleþtirir gibi davranýr.
Birinci süreç derleyici fonksiyon çaðrýsýnýn olduðu noktada o scope içinde ayný isimli fonksiyonlarýn hepsini listeye dahil eder. Yeter ki imzalar farklý olsun.
Derleyici bu aþamada fonksiyonlarýn parametrik yapýsýný not eder, imzalarýný not alýr. Bu süreçte olan fonksiyonlara aday fonksiyonlar(candidate func) denir. Fonksiyonlar ayný isimli olsun ve ayný
scope'da olsun tüm fonksiyonlar aday olmuþ olur.

Birinci süreçte zaten sadece tek bir fonksiyon olsa ikinci sürecin yürütülmesine gerek kalmaz.

Ýkinci süreçte, derleyici acaba bu yapýlan fonksiyon çaðrýsý ile bu listedeki fonksiyonlardan hangileri legal olarak çaðrýlabilir diye bakar. Yani aslýnda derleyici eðer o fonksiyon tek baþýna olsa idi, 
baþka ayný isimde fonksiyon olmasaydý çaðýlýrmýydý'ya bakar. O fonksiyon tek baþýna olsa legal olur muydu ? 

int func();  //1 Tek baþýna olsa çaðýrýlmazdý, listeden atýldý
int func(int);  //2 Tek baþýna olsa caðýrýlmazdý, listeden atýldý
int func(int , int); //3 Tek baþýna olsa çaðýrýlýrdý, listede kaldý
int func(double, int); //4 Tek baþýna olsa çaðýrýlýrdý, listede kaldý
int func(double, int, int = 34); //5 Tek baþýna olsa çaðýrýlýrdý, listede kaldý.

int main()
{
	func(10, 56);
}

Bu aþamayý geçen fonksiyonlara viable fonksiyon(uygun fonksiyon) denir. Viable fonksiyon olmasý için minimal kurallar: argüman sayýsý ile parametre sayýsý denk düþecek(varsayýlan argüman kontrolü
de buna dahil, varyatiklik de dahil), ve her bir argümandan her bir parametre deðiþkenine geçerli bir tür dönüþümü olmasý gerekir. 3'teki fonksiyon int func(int *, int) þeklinde olsa idi, bu fonksiyon
da viable olmaktan çýkardý çünkü parametreler ile argümanlar arasýnda geçerli bir tür dönüþümü olmazdý, parametrede int * argümanda int var. int'den int *'a dönüþüm olmadýðýndan viable olmazdý.

Eðer ikinci aþamayý geçen fonksiyon yoksa, çaðrýlabilecek fonksiyon yok demektir -> error.
Eðer ikinci aþamayý geçen bir fonksiyon var ise o çaðrýlacaktýr. -> legal
Eðer ikinci aþamayý geçen fonksiyon sayýsý yani viable fonksiyon sayýsý iki ve daha fazla ise sürecin belirleyici son aþamasý gerçekleþtirilir.
Derleyici üçüncü aþamada uygun olan fonksiyonlardan en uygun olanýný bulmayý amaçlar bulamaz ise error verir. Derleyicinin amacý best match fonksiyonu bulmak.

Üçüncü aþamaya gelindiyse her bir argümandan her bir parametre deðiþkenine aktarýmýn legal olmasý gerekir. Derleyici argümandan parametre deðiþkenine aktarýmý öncelikle 3 kategoriye ayýrýr. Biri 
conversion (dönüþüm), diðeri user defined conversion, diðeri ise variadic functions. Conversion: argümandan parametre deðiþkenine aktarým dilin kurallarýna göre legal, legal bir dönüþüm söz konusu 
örnek olarak: int'den double'a dönüþüm, double'den int'e dönüþüm, int'den int'e aktarým. C'de karþýlýðý var.
User Defined Conversion'un C'de bir karþýlýðý yok. Normalde dönüþüm legal deðil iken, programcý tarafýndan yazýlan bir fonksiyon tarafýndan legal hale getirilmiþse buna user defined conversion denir.
Seçicilik açýsýndan en kötü durum variatic fonksiyonlar. 
En iyi senaryo conversion ardýndan user defined conversion en son da variadic fonksiyonlar.

Conversion söz konusu olduðunda, iki ya da daha fazla fonksiyon var, çaðrýdaki argüman olan ifadeden her iki fonksiyonun parametresine de dönüþüm var ise ?
Dönüþümü de derleyici kalite kategorilerine ayýrýr. 
Olabilecek en iyi dönüþüm kategorisi exact match.(tam uyum)
Ýkinci kategori promotion.(yükseltme)
Üçüncü kategori ise standart conversion.

Exact match: Argüman olan ifadenin türü ile parametrenin türü birebir ayný. Argüman int, parametre int. Olabilecek en iyi durum. Bu durumun promotion ve standart conversiona göre seçilebilirliði var.
1) L value to R value transformation: Normalde bir fonksiyonun parametresinin int olmasý durumunda, bu fonksiyon bir rvalue expr bekliyor. Fonksiyona bir lvalue expr gönderilirse, örnek olarak int türden
bir nesne ile çaðýrýldýðýnda, derleyici int türden nesnenin deðerini alýp parametreye kopyalayacak bir kod üretir. Buna teknik olarak L value to R value conversion denir. Yani aslýnda dilin kurallarýna 
göre int argümandan int parametreye de bir dönüþüm söz konusu bu dönüþüm, L value to R value olarak geçiyor. 
2) const conversion: Bir fonksiyonun parametresi const int *(parametre const int bir nesne adresi istiyor demek) ise bu fonksiyon const olmayan bir nesne adresi ile de çaðrýlabilir. Bu durumda T * dan 
const T *'a dönüþüm yapýlýyor. Bu dönüþüme const conversion denir. Bunun tersi error, yani const T *'dan T *'a dönüþüm zaten yok.
void func(const int *);
int main{
int x = 10;
func(&x);
}
3)array to pointer conversion: Dizi isminin adrese dönüþtürülmesi. 
void func(int *);
int main{
int a[3] = {4,5,7};
func(a);
}
4)function to pointer conversion: Fonksiyonun isminden fonksiyon adresine dönüþüm. 
void func(int *(fp)(int));
int foo(int);
////
func(foo);//Aslýnda doðrudan adres operatörü ile fonksiyonun adresi alýnmadý ama derleyici foo ismini foo'nun adresine dönüþtürür. Sanki func(&foo) þeklinde yazýlmýþ gibi.


Promotion: Exact matchden bir kötüsü. 
1) Integral promotion(int altý türlerin inte yüksltilmesi: parametre int, argüman char; parametre int, argüman short; parametre int, argümen unsigned char), C'deki integral 
promotiona ek olarak C++'da bool türünden int türüne aktarým da integral promotion kabul ediliyor.
2) Float to Double Conversion: Float'dan Double'a dönüþüm. Float'dan long double'a , double'dan long double'a olanlar promotion deðil.

Standart Conversion: Exact match ve promotion deðil ve halen legan ise standart conversion.

örnek olarak unsigned int'den int'e : standart conversion. integral promotion deðil çünkü integral promotion int altý türlerin int'e yükseltilmesi.
int * dan double * ' a : error. öncelikle legallik önemli.

Enum'dan int'e dönüþüm legal, int'den Enum'a dönüþüm legal deðil o yüzden standart dönüþüm.
double *'dan int *'a : hiçbiri deðil çünkü böyle bir dönüþüm zaten legal deðil.
0'dan null pointer'a:  standart conversion
int *'dan void *'a : standart dönüþüm. Tersi error, void *'dan int *'a dönüþüm yok.

iki fonksiyon var biri exact match diðeri promotion, kazanan exact match.
Biri promotion biri standart conversion ise kazanan promotion.
Ýki fonksiyon var ikisine de dönüþüm standart conversion o zaman error!

Birinci ambiguity senaryosu, ikisi de user defined conversion ise, aralarýnda seçicilik yok. Her iki overloada yapýlan çaðrý da user defined conversion ise error.
Diðeri de her ikisi de standart conversion ise yine error, ambiguity.


void func(int);   //1
void func(double);  //2
int main()
{
	func(13u); // Error! Ambiguity! unsigned int'den int'e standart conversion, unsigned int'den double'a standart conversion. Seçicilik yok!

}

void func(int);   //1
void func(double);  //2
int main()
{
	func(1.3f);  //2 çaðrýlýr çünkü float'dan int'e standart conversion, float'dan double'a promotion.
}


enum Color {Blue, Purple, Red}

void func(Color); //1
void func(double);//2
void func(int);//3
int main()
{
	func(6U);//error, ambiguity
}
1 zaten viable deðil, unsigned int'den enum türüne otomatik dönüþüm yok. 2 ve 3 viable ancak aralarýnda seçicilik yok ikisi de standart conversion.


void func(int x); //1
void func(bool x); //2
int main()
{
	func(10 > 5);  //2 caðrýlýr çünkü bool'dan int'e promotion. bool'dan bool'a exact match.
}


void func(char x);//1
void func(int x);//2
void func(double x);//3
int main()
{
	func('A');// 1 Çaðrýlýr. C++'da karakter sabitlerinin türü char'dýr, C'de olduðu gibi int deðildir.
}
Burada 1 exact match, 2 integral promotion, 3 ise standart conversion. Birinci fonksiyon olmasa idi ambiguity olmazdý 2 çaðrýlýrdý.



void func(int);//1
void func(float);//2
void func(long double x);//3
int main()
{
	func(4.); //error, ambiguity. double'dan long double'a dönüþümün hiçbir özelliði yok standart conversion.
} 
Eðer ikinci iptal edilirse yine error olur çünkü double'dan int'e de dönüþüm standart dönüþüm; double'dan long double'a da 
dönüþüm standart conversion. Promotion olan sadece float'dan double'a olan dönüþüm.


void func(double);
void func(int *); 
int main()
{
	func(0); //error, ambiguity.
}
int * yerine int parametreli bir fonksiyon olsa idi error olmayacaktý, int olan çaðýrýlacaktý, exact match olurdu.
Ama þimdi int'den double'a dönüþüm standart conversion, int türden 0 sabitinin null pointer'a dönüþümü de standart conversion.

C++ öncesi void func(int *) gibi bir fonksiyona null pointer göndermek isteyen;
func(0); þeklinde çaðrý yapýyordu.
void func(int *) varken bir de void func(double); parametreli bir overload eklendiðinde func(0); çaðrýsý artýk legal olmaktan çýkar.
void func(int *) var ve kod legal iken void func(int); parametreli overload eklendiðinde ise int parametreli olan exact match olduðundan
func(0); çaðrýsý sonucu int parametreli olan çaðrýlýr. Bu durum en tehlikelisi, çünkü fonksiyona 0 gönderilerek amaçlanan int * parametreli
olanýn çaðrýlmasý idi ancak void func(int) overloadýnýn eklenmesi sonucunda artýk int parametreli olan fonksiyon çaðrýlýr.
Null pointer için 0 kullanmak bir takým problemleri de beraberinde getirmekte bu yüzden "nullptr" keywordü kullanýlýr.
nullptr taným gereði sadece pointerlara atanabilen, kopyalanabilen bir sabit. sadece pointer türlerine dönüþüm var.

void func(int *); //1
void func(int); //2

int main()
{
	func(nullptr); //1 çaðrýlýr.
	func(0); //2 çaðrýlýr.
}


void func(int x);
void func(int &x);
int main()
{
	int y = 10;

	func(y);  //error! ambiguity!  call by value'nin call by reference'a ya da tam tersinin birbirlerine karþý üstünlükleri yok.
}

void func(int x); //1
void func(int &x); //2
int main()
{
	func(10); //1 exact match olduðundan 1 çaðýrýlýr. 2 aday fakat viable deðil.
}

//Const Overloading
void func(int *ptr)  //1
void func(const int *ptr); //2
int main()
{
	const int x = 10;
	int y = 45;

	func(&x);  //exact match olduðundan 2 çaðrýlýr.
	func(&y);  //2 fonksiyonda viable biri zaten int *, diðerinde ise int * dan const int *'a. 1 caðrýlýr bu durumda int *'ýn const int *'a üstünlüðü var
}				

Ýki overload var ve birinin parametresi T * diðerininki ise const T * ise: ve argüman olarak const bir nesne adresi ile caðrýlýrsa const T * olan, const olmayan bir nesne adresi ile çaðrýlýr ise const
olmayan T * çaðrýlýr.


//const overloading; pointer semantiði yerine referans semantiði kullanýlmýþtýr
void func(int &r)  //1
void func(const int &r); //2
int main()
{
	const int x = 10;
	int y = 45;

	func(x); //2
	func(y);  //1
}


void func(int x = 20) 
void func()  
int main()
{
	func(); error! ambiguity
}

void func(int, int, int);
void func(int, double, int);
void func(float, double, int);
void func(int, double, long);

Birden fazla parametre olmasý durumunda bir fonksiyonun seçilebilmesi için o fonksiyonun þu koþulu saðlamasý gerekiyor: argümanlardan parametrelere aktarýmda en az bir parametrede diðerlerine üstünlük
saðlayacak diðer parametrelerde de daha kötü olmayacak. Bir parametre de bir fonksiyon baþka bir parametrede baþka bir fonksiyon üstün ise ambiguity, seçilebilirlik yok.

func(4.5f, 3.4, 12U) //Örnek olarak bu çaðrýda ilk argümana bakýlýrsa 3. dýþýnda diðerleri þanýsý kaybettti. Þuan sadece 3.nün çaðrýlma ihtimali var fakat 3.nün çaðrýlmasý içinde diðer iki argümanda
diðer fonksiyonlardan kötü olmamalý. 2. argüman için de exact match, 3. argüman ise tüm fonksiyonlar için standart conversion. 1 argüman'da üstünlük saðladý ve diðer ikisinde onlardan daha kötü durumda
olmadýðýndan nu çaðrý için 3.fonksiyon çaðrýlýr.

func(4.5f, 3.4, 12L) //olsa idi ambiguity çünkü son fonksiyon karþýsýnda üstünlük kaybedildi, eþitlik saðlanmýþ oldu.

extern "C" bildirimi:
C++'da C fonksiyonlarý çaðýrýlabilir fakat bir önlem alýnmalý. Örnek olarak C kursunda yazmýþ olduðumuz nutility baþlýk dosyasýndan bir fonksiyonu cpp main'inde derlemeyi denediðimizde linker ile ilgili
bir hata alýrýz. C'de function overloading yok. C'de iki fonksiyonun ismi ayný olamaz. abs fonksiyonu örnek olarak abs, fabs, labs diye parametresi farklý olup mutlak deðer alan fonksiyonlar. C'de bir
fonksiyona çaðrý yaptýðýmýzda derleyici bu fonksiyon inline deðilse derleyici fonksiyonun hangi fonksiyonun çaðrýldýðýný gösteren bir referansý obje modüle yazar. Yani derleme sonunda oluþturulacak koda
linkera ithafen bir referan isim yazar. Baþtaki durumda verilen hata mesajý unresolved external reference....: linker'ýn düþündüðü: "derleyici bana bir referans isim yazmýþ, benim iþimi yapabilmem için o
obje kodu o referans ismin objesiyle birleþtirmem lazým ancak birleþtiremiyorum çünkü öyle bir objeyi bulamýyorum" Linkerin verdiði tipik hata. Diðeri de multiple reference bu durumda da birden fazla bulup
hangisiyle birleþtireceðini bilememe durumu oluþur. C'de f.o olmadýðý için, derleyici obje modüle referans isim olarak çaðýrýlan fonksiyonun isminden türetilmiþ bir isim yazar. En tipik notasyon _ karakteri 
kullanýp çaðýrýlan fonksiyonun adýný yazmak, object modüle yazým biçimi bu. Linker bunu görüp fonksiyonun derlenmiþ haliyle birleþtirmesi gerektiðini anlayacak. Ancak cpp de f.o olduðu için ismi func olan birçok
fonksiyon olabilir, derleyici linkera func'lardan hangisinin de çaðýrýldýðýný söylemek zorunda. Cpp derleyicisi ise object modüle özel bir notasyonda parametrik yapý ile birleþtirip bir isim oluþturuyor. Yani 
fonksiyon ismini parametrik yapý ile de birleþtirip o þekilde bir notasyon kullanýyor. Cpp derleyicisi bprint fonksiyonunun çaðrýldýðýný gördü ama bprintin c'de derlenmiþ olduðunun farkýnda deðil. O yüzden object
modüle _bprint@i yazacak ancak diðer fonksiyonu derleyen cpp derleyicisi deðil c olduðu için, c derleyicisi onu object modüle yalnýzca _ kullanarak koymuþ _bprint þeklinde. O yüzden cpp derleyicisi c'de derlenmiþ
fonksiyonu bulamadý. Linker birleþtirmek için linkerin aradýðý isimle aradýðý yerde bprint'in derlenmiþ ismine verilmiþ isim ayný deðil. Hata cpp derleyicisinin derlediði kodda c'de derleme iþlemi yapýlmýþ fonksiyonun
çaðýrýlmasýnda ve compile time'da deðil link time'da oldu. Derleyiciye bprint fonksiyonu c'de derlendi yani bprinte yapýlan çaðrýlarda linkera vereceðin referansý c tarzý yaz, parametre ile dekore etme denilse
doðru þekilde çalýþýrdý. Bu iþi yapmaya yarayan bildirim var = ismi c tarzý yaz external referans olarak ki linker þaþýrmasýn. "extern c bildirimi". Derleyici bprinti aradýðýnda extern "C" bildirimini gördü bu bil-
dirimden de fonksiyonun C'de derlendiðini anlayýp linkera _bprint yazdý. 

Dinamik bellek alaný elde edilirken, malloc'a elde edilecek bellek alanýnýn boyutu geçilir ancak free ederken büyüklük geçilmez sadece adresi verilir. Heap alaný dinamik bellek fonksiyonlarý ile elde edilecek yer.
Heap alaný derleyici tarafýndan iki ayrý þekilde kullanýlýr. Ýlki buradan programcýya bellek alaný verilir. Derleyici çalýþma zamanýnda heap alanýnýn yönetimi için arka planda bir veri yapýsý oluþturur. Bu veri 
yapýsýna dinamik tahsis tablolarý denilir. Bu tablo bir baðlý liste gibi çalýþýr; içinde hangi blok yani hangi adresten baþlayarak ne kadarlýk bir blok ? bu veri yapýsýnýn kendisi de heap'de tutulur. Heap alaný iki
farklý þekilde tüketilir. 1) elde edilen bloðun kendisi 2) her blok için bir entry(data structur'a bir entry). 
Örnek olarak 1000'er bytelýk 100 bellek bloðu alýnýrsa toplamda 100 bin byte ama 10'ar bytelýk 10 bin bellek bloðu alýnýrsa toplamda yine 100 bin byte. Fakat ikincisi heap alanýný çok daha çabuk tüketir çünkü 10 bin 
tane ayrý tahsisat olacaðýndan 10 bin tane de entry olacak demektir. free ederken bellek alanýnýn boyutunun girilmemesinin sebebi derleyicinin buna ihtiyacý yok, derleyici girilen adres bilgisini keyword olarak kullanýr
ilgili entrye ulaþýp bellek bloðunun adresine ve boyutuna ulaþýr. Heap alanýndaki bir pointer hatasý genelde fatal error. Heap'de kontrolsüz bir þekilde bilinmeyen bir yere yazýldý, yazýlan yerde o veri yapýsýnýn entrysi
olabilir bu durumda dinamik tahsis tablolarý run time'de çökecektir.



TÜR DÖNÜÞTÜRME OPERATÖRLERÝ

C'de ne amaç ile tür dönüþümü yapýlýrsa yapýlsýn tek bir interface var. Daha iyi senaryo ise biribirinden çok farklý amaçlar ile yapýlmýþ tür dönüþümleri için dönüþümler farklý operatörler ile yapýlmalý. Derleyici
de o dönüþüm belirli bir operatör dýþýndaki bir operatörle yapýlýrsa bunu kontrol etsin ve bunu geçersiz kýlsýn. Operatör olarak da () yerine bir isim kullanýlsýn ki arama yapýldýðýnda da bulmak, eriþmek daha kolay
olsun. Farklý amaca farklý operatör, özelleþtirilmiþ bir yapý ve arama iþlemlerinde kolaylaþtýrýlýmþ bir yapý.

Nerde tür dönüþtürme operatörleri kullanýlýr?
1)Bir ifadeyi bir iþlemde farklý türdenmiþ gibi iþleme sokmak için
(double)i1 / i2; //intleri bölüp double elde etmek için

(long)i1 * i2; //int'in 2 byte longun 4 byte olduðu sistemlerde taþmayý önlemek adýna

ival = (int)dval; //verikaybýnýn kontrollü olarak yapýldýðýný göstermek için

Bu tür dönüþümlere statik tür dönüþümleri denir. Bunlarý yapmak için C++'da static cast adlý ayrý bir operatör var.

2)strchr'deki durum. Geri dönüþ deðeri char * parametresi const char *, int ch : bir yazýda karakteri arar, arama fonksiyonu set amaçlý olmadýðýndan aldýðý parametre const char * ama bulduðu yerin adresini kendisini 
çaðýrana geri verdiðinde bu taahhüdü kaldýrýyor. Burada geri dönüþ deðeri de const char * olsa idi fazla taahhüt de bulunmuþ olacaktý, sahibine geri verirken sahibinden dahi korur duruma düþecekti.
char *strchr(const char *p, int c)
{
	while (*p) {
		if (*p == c)
			return (char *)p; // return p; cpp'de geçersiz, c de ise yanlýþ çünkü const t *'dan t *'a dönüþüm yapmaya zorlamýþ olurum
		++p;					// bilerek isteyerek yaptýðým için tür dönüþtürme operatörü ile yapýlýr. 
	}
	if (c == '\0')
		return (char *)p;

	return NULL;
}

Buradaki dönüþümlere const cast denir bu da ayrý bir operatör ile yapýlýr adý const cast. 

3)En tehlikeli olan dönüþüm þekli, tür farketmeksizin baþka türdenmiþ gibi kullanýlan durumlar. C kodlarýnda alt seviyeli durumlarda en çok kullanýlan fakat en yüksek riskli tür dönüþtürme iþlemleri.

Cpp'de C'de olmayan 4 tane tür deðiþtirme operatörü var:(Tümü modern C++'dan önceden de vardý)
static cast
const cast
reinterpret cast
dynamic cast: C ile hiç alakasý yok. Run Time Polymorphism ile kullanýlacak, C'de bir karþýlýðý yok.

Ortak sentaks: keywordlerden biri yazýlýr, açýsal parantez içine hedef tür bilgisi yazýlýr, ve parantez içinde operand yazýlýr.
(açýsal parantez kullanýlmasýnýn sebebi template olmasý.)
static_cast<hedef tür>(operand)
const_cast<hedef tür>(operand)
reinterpret_cast<hedef tür>(operand)

srand(static_cast<unsigned>(time(nullptr)));
time'ýn geri dönüþ deðeri time_t türünden, srand'ýn unsigned int parametresine gönderilir.

int i1, i2;
cin >> i1 >> i2 ;
double dval = static_cast<double>(i1) / i2;
intler arasý iþlem yapýp sonucu double türden elde etmek için

float f = static_cast<float>(dval);

enum Color {White, Gray, Red, Brown};
int i;
Color c = static_cast<Color>(i1);
enum int dönüþümleri de bununla yapýlýr.

Operatörleri kendi yetenekleri dýþýnda tür dönüþümüne zorlamak geçersiz!
Yani örnek olarak static cast yerine reinterpret cast kullanmak sentaks hatasý.(compile time'a iliþkin hata)
/////////////////////////////////////////////////////////////////////
char *strchr(const char *p, int c)
{
	while (*p) {
		if (*p == c)
			return const_cast<char *>(p);
		++p;
	}
	if (c == '\0')
		return const_cast<char *>(p);

	return nullptr;
}

///////////////////////////////////////////////////////////////////////
struct Date {
	int d, m, y;
};
	Date mydate{ 4, 6, 1987 };
	char *p = reinterpret_cast<char *>(&mydate);

/////////////////////////////////////////////////////////////////////
const int *func();
int main()
{
	auto p1 = const_cast<char *>(reinterpret_cast<const char *>(func()));
	auto p2 = reinterpret_cast<char *>(const_cast<int *>(func()));
}
const int *'dan  char *'a reinterpet_cast ile cast edilmez. reinterpret_cast ile ancak const char *'a cast edilir.
amaç char *'a cast etmekse iki tane operatör birlikte kullanýlýr.


11_11_2017_CUMARTESÝ

void func();
C'de olsa fonksiyonun parametrik yapýsý hakkýnda bilgi verilmediði anlamýna gelirdi. C++'da ise parametre parantezinin içinin boþ býrakýlmasý ile void yazýlmasý arasýnda
bir fark yok. void func(); ile void func(void); arasýnda bir fark yok.

Bir fonksiyon çaðrý ifadesi dahi C++'da constant expression olabilir.
int a[] = {2, 65, 67, 7, 8, 4}
int b[asize(a)]; //asize(a) bir fonksiyon çaðrýsý, makro deðil. Bu çaðrýdan elde edilen geri dönüþ deðeri compile time'da elde edilecek. Derleyici fonksiyon çaðrýsýnýn ol-
duðu yere sabit yerleþtirir.

constexpr int factorial(int x){
	return x < 2 : 1 ? x * factorial(x-1);
}
int main(){
	int a[factorial(5)]; // Dizi boyutunu gösteren ifadenin constant expression olmasý gerekiyor.
	cot << asize(a) << endl; 
}
factorial(5) bir fonksiyon çaðrýsý olsa dahi derleyici bu duruma itiraz etmez. Fonksiyondan elde edilen deðer compile time'da elde edildi. Derleyici 120 deðerini compile time'da
elde etti. Yine asize(a) deðeri de compile time'da elde edildi. C'de zaten olmayan, C++'ya ise 11 standartlarý ile gelen bir özellik: constexpression functions
 
Bir fonksiyonu constexpr keywordü ile tanýmlarsak ve eðer bu fonksiyon bir sabitle, constant expression ile çaðýrýrsak geri dönüþ deðeri compile time'da elde edilecek. Eðer
constant expresion olmayan bir ifade ile çaðýrýlrsa ise o zaman geri dönü deðeri run time'da elde edilecek.

int x = 45;
factorial(x); bu fonksiyon çaðrýsýnda fonksiyonun geri dönü deðeri run time'da elde edilir çünkü x bir constant expression deðil.
int b[factorial(x)]; // sentaks hatasý, fonksiyona gönderilen deðer sabit ifadesi deðil, böylece artýk fonksiyon çaðrý ifadesi de constant expression olmadýðýndan dizi boyutu 
gibi constant expression   gereken yerlerde kullaným geçersiz. Geçerli olabilmesi için fonksiyona bir sabit ifadesi ile çaðrý yapýlmasý gerekli.

örnek olarak sin(x+y+z) fonksiyonu bu þekilde çaðýrýldý. Derleyici compile time'da (x+y+z)'nin sabit ifadesi olup olmadýðýna bakar. Eðer sinus constexpr function ise sinüsünü
compile time'da elde eder, runtime'da hiçbir hesap yapýlmaz. Ama compile time'da (x+y+z) bir constant expression deðil ise diðer fonksiyonlar gibi geri dönüþ deðeri run time'da
hesaplanýr. Böylece birçok dilde olmayan bir ekonomi de yapýlmýþ olur: compile time'da hesaplanan deðerler compile time'da hesaplanýr, run time'da hesaplanmasý mecburi olan deðerler
run time'da hesaplanýr. Fonksiyonu çaðýran için deðiþen bir þey yok. Bunu belirleyen dilin kurallarý. Yeni kütüphanede matematik fonksiyonlarý constexpr. Compile time'da hesaplabilen
deðer asla run time'da hesaplanmaz ki programýn çalýþma zamaný maliyeti artmasýn. Hangi fonksyionlarýn constexpr olduðunu anlamak için: sabit ile çaðýrýldýðýnda sabit ifadesi olmasý 
gerekli.

C++'da const bir nesneye constant expression ile ilk deðer verilirse const nesnenin kendisi de constant expression kabul edilir.

const double dval = .912; //dval constant expression
sin(dval); 

CONSTEXPR KEYWOWRDU(C++11 ile)
C++'da const anahtar sözcüðü farklý constexpr anahtar sözcüðü farklý. 
const anahtar sözcüðü bir nesneyi tanýmlarken kullanýlabilecek bir anahtar sözcük.
const int x = 10; //x kendisi const bir nesne, x'in deðeri deðiþmeyecek. Burada x ayný zamanda constant expression.

int func();
þeklinde bildirilmiþ bir fonksiyon için: const int x = func(); // x ifadesi constant expression deðil.

constexpr ise: ben bir sabit ifadesi olarak kullanýlacak deðiþken oluþturmak istiyorum demek.
constexpr int x = 5; //legal ama buna sabit ifadesi olmayan bir ifadeyle ilk deðer verme giriþiminde bulunmak geçersiz.
constexpr deðiþkenlere constant expression ile ilk deðer vermek zorunlu. Yani deðiþken constexpr ile tanýmlanmýþsa ve legal ise o artýk constant expressiondýr.

int func(); //fonksiyon bildirimi
constexpr int x = func(); //geçersiz, constexpr'ye constant expression ile ilk deðer vermek zorunlu. 
int a[x] = {}; //geçersiz, x bir constant expression olmadýðýndan dizi boyutu olamaz.
constexpr int y = 25; //geçerli 
const int m = func(); // m constant expression deðil.
constexpr keywordü ile tanýmlanýrsa artýk kodun legal olmasý durumunda sabit ifadesi olmamasý ihtimali söz konusu deðil. çünkü sabit ifadesi olmadýðý zaman
zaten sentaks hatasý olacak.

constexpr int square(int x){
	return x*x;
}
int main(){
	const int x = 20; //x constant expression
	constexpr int y = square(x); // square(int) constant bir expression ile çaðýrýldýðýndan square(x) ifadesi constant expression
				     // y'de constexpr keywordu ile tanýtýldýðýndan constant expression ile ilk deðer vermek mecburi, GEÇERLÝ
	int a = 20;
	constexpr int b = square(a); //geçersiz çünkü square(int) fonksiyonu constant expression ile çaðrýlmýyor, o yüzden square(a) ifadesi
				     //constant expression deðil. y'ye de ilkdeðer veren ifadenin constant expression olmasý gerekir, GEÇERSÝZ
}					


const int x = 10; //ilkdeðerin sabit ifadesi olmasý gerekmiyor.
constexpr int y = x; // constant expression olmama ihtimali yok, öyle olsa idi geçersiz.
++x; //geçersiz
++y; //geçersiz
//her ikisi de kendisi const, aralarýndaki fark const kullanýldýðýnda ilkdeðerin sabit ifadesi olmasý gerekmiyor.
const anahtar sözcüðü ile tanýtýlan bir deðiþken constant expression olarak da iþlem görebilir, constant expression olmayacak þekilde de iþlem görebilir. Bu neyle ilk deðer
verildiði ile alakalý bir durum. Ancak constexpr ile tanýtýlan bir deðiþkenin constant expression olmama ihtimali yok. constant expression olmasa zaten derleyici tanýmýnda
sentaks hatasý verir.


bir deðiþkenin oluþturulma nedeni onu bir constant expression olarak kullanmak ise;
const int x = exp; // x bir sabit ifadesi mi ? exp'nin sabit ifadesi olup olmadýðýna baðlý. Diyelim ki exp'nin sabit ifadesi olup olmadýðýný doðrudan göremiyoruz. Bu durumda büyük bir risk
alýnmýþ olur, zira tanýmlama g eçerli fakat constant expression mý deðil mi bu ifadeye baðlý olmuþ olur.
constexpr int x = exp; // Madem x constexpr olarak kullanýlmak isteniyor, constexpr'yi yaz. 2 avantajý var; ilki herkes amacýn bu olduðunu anlayacak yani x, sabit ifadesi gereken yerlerde
kullanýlacak. 2. avantajý ise exp sabit ifadesi deðilse sentaks hatasý olacak. exp sabit ifadesi sanýlýrken eðer öyle deðilse constexpr'de zaten kod geçersiz olacak.

Bir deðiþkenin sabit ifadesi olarak kullanýlmasý zorunlu olan yerlerde constexpr kullanýlacak.
/////////////////////////////////////////////////////////////
int func(int);
int main()
{
	int y; // y daha önce tanýtýlmýþ, çöp deðerinde deðil.
	////
	const int x = func(y); // x, hiç deðiþmeyecek ve x hayata func fonksiyonunun geri dönüþ deðeri ile gelecek.
			       //Burada constexpr kullanýlamaz, x'in sabit ifadesi olma ihtimali yok
}
/////////////////////////////////////////////////////////////
int x = 10;
int main(){
	const int *ptr = &x; //ptr constant expression olamaz çünkü kendisi const bir nesne deðil, const int *const ptr þeklinde olmasý gerekirdi.
}//kendisi const olmayan bir nesne constant expression olamaz
//////////////////////////////////////////////////////////////
int main(){
	int x = 10;
	const int *ptr = &x; 
	const int *p = ptr; // bu geçerli
}
const int *ptr = &x; ptr'nin constant expression olup olmadýðýný anlamak için; constexpr keywordu ile tanýtýp, ptr'ye ilk deðer verildiðinde 
geçerli ise constant expression'dýr.
constexpr const int *p = ptr; //error, ptr constant expression deðil. 
const int *p = ptr; //constexpr'nin silinmesi durumunda geçerli, herhangi bir hata yok. p'yi sabit ifadesi kullanýlmasý gereken yerlerde kullanmak 
isteseydim p'nin constant expression olmasý gerekirdi.
//////////////////////////////////////////////////////////////
int main(){
	int x = 10;
	int *const ptr = &x; //ptr kendisi const

	constexpr int *p = ptr //geçersiz, ptr kendisi const ama constant expression deðil.
}
ptr constant expression olsa constexpr ile tanýtýlan deðiþkene ptr ile ilk deðer verilebilirdi. Yani constexpr keywordu þunu gösterir, eðer legalse sabit ifadesi gereken her yerde kullanýlabilir.

Bir pointerýn sabit ifade olabilmesi için ona verilen adresin statik ömürlü bir nesnenin adresi olmasý gerekir.
Yerel deðiþkenlerin adresleri constant expression kabul edilmez. Statik yerel deðiþkenlerin adresleri de sabit ifadesi deðildir. Global nesnelerin adresleri constant expression kabul edilir.
int x = 10;
int main(){
	constexpr int *const ptr = &x; //legal, ptr ayný zamanda constexpr
}

int x = 10;
int main(){
	constexpr int *p = &x; //legal   
}

int main(){
	int x = 10;
	constexpr int *ptr = &x; //geçersiz, constant expression deðil, x yerel deðiþken.
}


int x = 10;
int main(){
	int *const ptr = &x; //ptr constant expression mu? Bilinmeyebilir yani olabilir ama olmayadabilir de, ama constexpr keywordü ile tanýmlansa ya tanýmlama illegal olacak ya da ptr constant expression olacak
	constexpr int *p = &y; // tanýmlama legal ise p constant expression. Ptr'nin deðeri hiç deðiþmeyecek, kendisi conts pointer ve de ptr sabit ifadesi gereken yerlerde kullanýlabilecek.
	constexpr int *ptr = &x; //ptr constant expression, *ptr'ye deðer atanabilir, set edilebilir. ptr ise constexpr yüzünden deðiþtirilemez.
	constexpr const int *ptr = &x; // ptr constant expression ama *ptr salt okuma amaçlý kullanýlacak. ptr ise constexpr yüzünden deðiþtirilemez.
}
Son iki tane de constexpr ve const'un anlamlarý tamamen birbirinden farklý. constexpr yüzünden ptr'yi deðiþtiremem ve ptr'nin bir constant expression olma garantisi var olmasa illegal olacaktý. const ise *ptr'ye 
atama yapýlmasý durumunda error oluþur.
/////////////////////////////////////////////////////////////////////
int x = 10;
int y = 5; 
int main(){ 
	constexpr int *ptr = &x;
	*ptr = 45; //geçerli, constexpr const int *ptr = &x olsa const anahtar sözcüðünden dolayý geçersiz olurdu
	 ptr = &y; //geçersiz, constexpr olduðundan dolayý
}
/////////////////////////////////////////////////////////////////////
int func();
int main()
{
	const int x = 10; //const bir nesne, bir sabit ifadesi ile ilk deðerini aldý.
	int dizi[x];// x sabit ifadesi olmasa geçerli olmazdý.
	constexpr int y = x; // x sabit ifadesi olmasa geçerli olmazdý.
}
x'e func fonksiyonunun geri dönüþ deðeri ile ilk deðer verilseydi de error olurdu.
const int x = func(); //x constant expression deðil.
constexpr int y = x; //error
dizi boyutu ile test yapmak her zaman iyi deðil, örnek olarak dizi boyutu double olamaz ama bu kural double için de geçerli.
///////////////////////////////////////////////////////////////////////
int main(){
	const double = 2.3;
	constexpr double y = x; //geçersiz, bir ifadenin sabit ifadesi olabilmesi için integral type olmalý.

}
///////////////////////////////////////////////////////////////////////
Bir pointer'ýn, pointer deðiþkenin constant expression olmasý için kendisinin const olmasý yeterli deðil, ona verilen ilk deðerin de constant expression olmasý gerekir.
constexpr keyword'u ile tanýtýlan deðþken bildirimi, tanýmlamasý geçerli ise o deðiþken artýk constexpr'dir !!!

NOT:
int x = 10;
int y = 20;
int main(){
	const int *p1 = &x; // low level-const, *p1 deðiþtirilemez
	*p1 = 5; //geçersiz
	p1 = &y; //geçerli, p1'nin deðeri deðiþtirilebilir yani p1 baþka bir adresi gösterebilir.

	int *const p2 = &x; // top-level const, p2 deðiþtirilemez
	*p2 = 5; //geçerli, *p2 deðiþtirilebilir
	p2 = &y; //geçersiz, p2'nin deðeri deðiþtirilemez yani p2 baþka bir adresi gösteremez.
}
///////////////////////////////////////////////////////////////////////
#include <bitset>
using namespace std;
int main(){
	int x = 10;
	bitset<5> t; //geçerli
	bitset<x>; t1//geçersiz, x bir sabit ifadesi deðil
	bitset<sizeof(x)> t2; //geçerli sizeof(x) bir sabit ifadesi

	constexpr int y = 10; //legal olduðuna göre sabit ifadesidir.
	bitset<y> t3; //geçerli
}

///////////////////////////////////////////////////////////////////////
int gx = 10;
int gy = 5;
int main(){

	const int *ptr = &x; //sabit ifadesi deðil.
	constexpr const int *ptr = &x; //geçerli ve ptr bir sabit ifadesi, sabit ifadesi gereken yerlerde kullanýlýr
	*ptr = 1; //geçersiz, low level constlukdan dolayý *ptr'nin deðeri deðiþtirilemez
	ptr = &y; //geçersiz, constexpr anahtar sözcüðünden dolayý, kendisi constdur, gösterdiði yer deðiþemez.

}

///////////////////////////////////////////////////////////////////////
int main(){

	int y = 56;
	const int x = y; //x constant expression deðil çünkü ilk deðerini aldýðý ifade bir sabit ifadesi deðil
	int dizi[x]; //geçersiz

	constexpr int val = x; //geçersiz çünkü x bir sabit ifadesi deðil
}
///////////////////////////////////////////////////////////////////////

SINIFLAR

Prosedürel programlamada temel yazýlýmsal birim fonksiyonlar. Yapýlacak iþ fonksiyonlara ayrýþtýrýlýp halledilir. Nesne yönelimli programlamada yapýlacak iþ için öncelikle sýnýflar bulunur.
Ayrýþtýrma sýnýflara yönelik. C# ve Java Nesne Yönelimli Programlama dilleri, C++ ise nesne yönelimli programlamaya da destek veren multiparadigm bir programlama dili. 

C++'daki struct anahtar sözcüðü C'deki gibi deðil. struct anahtar sözcüðü C'deki gibi deðil, C++'da bir sýnýf oluþturmak için class keywordu de struct keywordu de kullanýlabilir.
Sýnýf bir tür, class is a type. C'de int, double nasýl bir tür ise class'da C++'da bir tür. Tabi derleyicinin böyle bir türün varlýðýndan haberdar olmasý için derleyicinin class definitioni
görmesi lazým.


class Myclass { //class definition
};
int main(){
	Myclass x;  
};
Tür bilgisi gereken yerde Myclass ismi kullanýldýðýnda, derleyici myclass ismini arar ve yukarýdaki definiton ile geçmesi gerektiðini anlar. x'de böylece bu türden deðiþkenin ismi olur.

class definitionlar eðer clientlar bu türü kullanacaksa baþlýk dosyasýnda(çoðu zaman) bulunur. Clientlar kullanmayacak sadece implementasyon kullanacaksa o zaman baþlýk dosyasýnda deðil cpp dosyasýnda.
Çok büyük çoðunlukla baþlýk dosyasýnda bulunur. Çoðu zaman sýnýf ismi ile baþlýk dosyasýnýn ismi de ayný yapýlýr.(çoðunlukla baþlýk dosyasý o sýnýfa yönelik olur)
C++'da C'deki gibi user defined türler için typedef bildirimi yapýlmasýna gerek yok, typedef bildirimi yapýlmadan da türün adý Myclass.
C'de elemaný olmayan bir yapý nesnesi tanýmlanamaz ancak C++'da öðesi olmayan sýnýf olabilir, legal.
C++'da struct da bir class.
Struct'ýn default eriþim bölgesi public, class'larýn default eriþim bölgesi private.
Sýnýfýn definition'ý içinde bildirilen tüm isimlere o sýnýfýn memberlarý denir. 3 tane member kategorisi var: 1)Data members 2)Member functions 3)Type Member
C'de tüm fonksiyonlar global, C++'da sýnýf fonksiyonlarýnýn olmasý global fonksiyonlarýn olmayacaðý anlamýna gelmez. Global Fonksiyonlar için free function terimi de kullanýlýr.
Type Memberlar; classs, enum, yada bir typedef name olabilir.

/////////////////////////////////////////////////////////////////////
//data.h
class Data { //ismi Data olan sýnýfýn definition'ý
	int mx; //data member
	void func(); //member function, C'de olmayan bir durum.
	typedef int Word; // Word bir type ismi, type member
 }

 void foo(int); //global function, free function
 /////////////////////////////////////////////////////////////////////
 
 Global fonksiyonlar ile member fonksiyonlar arasýnda makina düzeyinde bir fark yok. Aradaki fark semantik olarak mevcut. Assembly koduna bakýldýðýnda aralarýnda fark yok. Bu ikisini farklý kilan
 dilin sentaksý ve onun ifade ettikleri. 

 Class ayný zamanda bir scope. C'de structure scope gibi bir scope yok; file scope, block scope, function prototype scope, ve function scope var. C++'da ise block scope var, file scope farklý bir isimle
 namespace scope adýyla var, function prototype scope ve function scope ve ek olarak class scope var. 
 Class scope sýnýfýn içinde bildirilen isimleri ilgilendirir. Class scope'un olmasý en baþta name look-up ý deðiþtirir.

int main(){
	mx; //þeklinde kullanýldýðýnda derleyici hata verir, derleyici ismi arayýp bulamaz. Derleyici mx'in neyin ismi olduðunu anlama sürecinde class scope'da arama yapmaz.
}//undeclared identifier

Bir isim hangi durumda bir class scope'da aranýr ?
Global fonksiyonlar içinde kullanýlan isimlerin bir class scope'da aranmasý için;
1)Ýsim nokta operatörünün sað operandý olarak kullanýlmýþ ise
2)Ýsim ok operatörünün sað operandý olarak kullanýlmýþ ise
3)Ýsim binary :: operatörünün sað operandý olarak kullanýlmýþsa (:: scope resolution operatörü)
söz konusu isim sadece ve sadece class scope'da aranýr.

Ýsmin aranýp bulunmamasý her zaman error. Ýsmin aranýp bulunmasý ise her zaman o ismin kullanýmýnýn legal olduðu anlamýna gelmez. Dilin bazý baþka kurallarý isim bulunsa dahi kullanýmýna izin vermeyebilir.

nokta operatörü: x.y ---->  x bir sýnýf türünden nesne ise sað operand olan y, x'in ait olduðu sýnýfýn scope'unda aranacak.
ok operatörü:    x->y --->	ptr bir sýnýf türünden adres ise, sað operand olan y ismi ptr'nin ait olduðu sýnýfýn scope'unda aranacak.
çözünürlük operatörü: Myclass::x -----> Eðer MyClass bir sýnýfýn ismi ise sað operand olan x bu sýnýfta aranacak.


Class Scope: C'den farklý olarak public, private, protected denilen eriþim açýsýndan farklý ayrýcalýk özelliklerine sahip bölümlerden oluþur. Public, private, protected scope deðil. Bunlar eriþim bölgeleri; 
bu bölgelerde tanýtýlan isimlerin kimin legal olarak kullanýp kullanamayacaðýný belirler. Class scope'daki isimler bulunduktan sonra bir de o kodun o ismi kullanma hakký olup olmadýðýna bakýlýr. 
Bu kontrole access control(eriþim kontrolü) denir. Bir kodun legal olmasý eriþim kontrolüne de baðlýdýr. 

Sýnýfýn public bölümü, dýþarýya açýk bölümü. Sýnýfýn public bölümündeki öðeleri herkesin kullanma hakký var herhangi bir sýnýrlama yok.
Sýnýfýn private ya da protected bölümünde tanýtýlan isimler client kodlara tamamen kapalýdýr.
Clientlara açýk interface'e public interface denir. Client kullanýcý public isimleri kullamma hakkýna sahiptir.
Sýnýfýn private bölümü sadece sýnýfýn kendi kodlarýna, kendi implementasyonuna açýktýr. x, sýnýfýn private ismi ise bu ismi, isim arama ile arayýp bulunmasý kodu legal kýlmaz, derleyici bir de eriþim kontrolü 
yapar ve sýnýfýn private bölümünde olan bir isme eriþme giriþimini geçersiz kýlar.
C'deki yapýlarda tüm isimler public, C'de bir ismi private yapma imkaný yok.
Protected ise C'de olmayan kalýtým(inheritance) aracý ile ilgili. Sýnýfýn protected bölümü kalýtým olmazsa önemi olan bir bölüm deðil, o zaman ayný private bölüm gibi davranýr.
Client için protected ya da private farketmez ikisine de eriþim geçersiz. Kalýtým uygulandýðýnda protected bölüm önem kazanýr ve farklýlaþýr.
Protected bölüm client kodlara kapalý, kalýtým yolu ile elde edilmiþ sýnýflarýn kullanýmýna açýk isimlerin bulunduðu bölümdür. 

 /////////////////////////////////////////////////////////////////////
class Data{
	////private
public:
	////public
protected:
	////protected
public:
	////public
}
 /////////////////////////////////////////////////////////////////////


C#, Java ve bazý farklý dillerde public, private, protected keyword, fakat öðe baþýna yazýlýr yani her öðrenin ne olduðu açýk açýk yazýlýr.
C++'da bu sözcükler öðe bildiriminde kullanýlamaz, bölge olarak kullanýlabilir.
Default eriþim bölgesi class'larda private. Ancak struct anahtar sözcüðü kullanýlarak oluþturulan sýnýflarda public.
Bir bölge oluþturulmak için bu anahtar sözcüklerden biri kullanýlýr. Bu alandan :'dan baþlanarak sýnýfýn sonuna kadar yada bir baþka eriþim belirten anahtar sözcüðe kadarki bölüm o eriþim alanýna ait bölüm.
Bu anahtar sözcüklerin birden fazla kullanýlmasý legal.
Zorlayýcý bir neden yoksa public ya da private, hangisi istenirse o baþa yazýlabilir. 

 /////////////////////////////////////////////////////////////////////
class Data{
	int mx;
public:
	double mx; //geçersiz, ayný scope'da bir isim birden fazla varlýða verilemez.
}
 /////////////////////////////////////////////////////////////////////
 class Data{
	int mx;
 }
 int main(){
	Data mydata;

	int x = mydata.mx; //error
 }
 Derleyici önce ismi arar, isim aramada bir problem yok çünkü nokta operatörünün saðýnda olduðundan isim Data sýnýfýnýn scope'unda aranýr. Ýsim aramada ve kullanýmda hata yok.
 Hatanýn sebebi eriþim kontrolüne takýlmasý. Derleyicinin verdiði hatanýn sebebi mx öðesinin private olmasý.
 /////////////////////////////////////////////////////////////////////
class Data{
	int mx; 
	void func();
public:
	void foo();
};
int main(){
	Data mydata;
	int x = mydata.mx; // Geçersiz..Ýsim arandý ve bulundu fakat mx, private bölümde.
	mydata.foo(); //geçerli, foo public member function
	mydata.func(); // geçersiz, func private member function, protected da olsa ayný þekilde error olacaktý.
}
 ///////////////////////////////////////////////////////////////////// 

Data memberlar kendi içinde iki gruba ayrýlýr; non-static data member ve static data member.
Bir anahtar sözcük kullanýlmadan tanýtýlan non-static data member. Static data member olmasý için static keywordu kullanýlmalý. 
Buradaki static keywordü C'deki ile karýþtýrýlmamalý.

 ///////////////////////////////////////////////////////////////////// 
class Data{
	int mx; //non-static private data member
	static int my; //static private data member
};
 ///////////////////////////////////////////////////////////////////// 

Sýnýfýn non-static veri elemanlarý ya da sadece data member dendiðinde(kastedilen non-static data member), C'deki yapý elemanlarý gibi. Yani sýnýf nesnesinin içinde. 
Data türünden 3 farklý nesne oluþturulduðunda ve mx, sýnýfýn non-static data member'i ise bu 3 farklý nesnenin de ayrý mx'i var. Sýnýflarýn non-static data memberlarý
fiilen sýnýf nesnesinin içinde, bir sýnýf nesnesinin mxin'in deðeri 15 diðerininki 25 olabilir. Bunlar(non-static d.m) sýnýf nesnesinin içinde olduðundan sizeof()'u doðrudan arttýrýrlar.
Sýnýfýn static veri elemanlarý fiilen sýnýf nesnesinin içinde deðil. Statik veri elemanlarý sýnýf baþýna tektir , kaç tane hayatta olan Data sýnýfýndan nesne olursa olsun aþaðýdaki örnek
göz önünde bulundurulduðunda bir tane msa var. Ancak non-static elemanlar için her Data sýnýf nesnesinin kendi mx, my ve mz'si var.

 ///////////////////////////////////////////////////////////////////// 
class Data{
int mx, my, mz; // sizeof(Data) = 12 byte
static int msa; // sizeof(Data)'yý deðiþtirmez, 5 tane daha static data member tanýmlansa dahi sizeof(Data)'da deðiþim olmaz.
}
 ///////////////////////////////////////////////////////////////////// 

Static veri elemanlarý C'deki global deðiþkenler gibidirler, statik ömürlüler. Global deðiþkenlerden farký scope'larý. Global deðiþkenler file scope'da, static data memberlar class scope'da.
Global deðiþkenlere herkes eriþebilir fakat static data memberlar da diðer sýnýf nesneleri gibi ayný þekilde aramaya tabii ve global deðiþkenler için access control yokken static yerel deðiþkenler
için de public, private, protected kavramlarý yine var.

Class bir varlýðýn sözlükteki tanýmý gibidir. Nesnelerin ortak özelliklerini anlatan kurallar. Class ile object arasýndaki fark class daha çok sözlükteki taným gibi onun ne olduðunu anlatýrken 
object ya da instance ise daha çok fiilen kullanýlan nesne. Bir sýnýfýn implementasyonunda non-static veri elemanlarý sýnýf nesnesinin kendisi ile ilgili. Statik veri elemanlarýnýn ise instance ile
alakalarý yok, sýnýf ile alakasý var. Örnek olarak account isimli bir sýnýf olduðu düþünülsün, account'un sahibi, account'un numarasý bunlar tipik olarak non-static veri elemaný çünkü her hesabýn
sahibi farklý. Non-static veri elemanlarý sýnýf nesnelerinde farklýlýk gösteren deðiþkenleri tutar. Hesaba uygulanacak bir faiz oraný olduðu düþünülsün, farklý hesaplar için farklý faiz oranlarý
olabilir, bu durumda faiz deðerini tutacak öðenin non-static olmasý gerekir. Fakat banka örnek olarak tek bir faiz uygulamasýna sahip olsun, her hesaba ayný faiz oraný iþletiyor, bu durumda faiz
oranýný tutacak deðer, statik veri elemaný olur, fiilen sýnýf nesnesi içinde tutulmaz.
Object olmadan bir anlamý olmayan öðeler non-static veri elemanlarýdýr.
Sýnýfýn statik veri elemanlarý global deðiþkenlere benzer. Global deðiþkenlerin class scope'a alýnmýþ ve eriþim kontrolü uygulama þansý verilmiþ hali.

Zorlayýcý neden yoksa data memberlar private yapýlýr, böylece clientlarýn data memberlarý bilip, öðrenmesine gerek kalmaz. Clientlarýn bilmesi gereken sýnýfýn public interface'i: burada sýnýfýn member
functionlarý var. Böylece sýnýfýn elemanlarýnda yapýlan deðiþiklikler client kodun deðiþmesine sebep olmaz. C'deki yapýlar düþünüldüðünde, yapýnýn tüm elemanlarýnýn bilinmesi gerekir ki kullanýlabilsinler.
C++, C#, Java gibi dillerde bu data memberlar client kodu ilgilendirmez, clientin ilgilendiði sýnýfýn public interfacei. Böylece client'in öðrenme yükü azalýr, sýnýfýn public interfacei sabit tutulmak 
þartý ile private interface'de yapýlan deðiþikliklerden client etkilenmez. 
Örnek olarak bir çizim programýnda üçgen isimli bir sýnýf olsun. Sýnýfýn data memberlarý, üçgenin üç kenarý ve alan bilgisini tutan bir data member. Bu data memberlar clienta açýk olsaydý, bir kenar 
deðiþtirildiðinde alanýn da deðiþtirilmesi gerekirdi. Kenar deðiþtirilip alan deðiþtirilmezse nesne istendiði gibi çalýþmaz. Data memberlar sýnýfýn private bölümünde olduðunda bunun ile ilgili gereken
kontroller de yapýlýr, yanlýþ deðerlerin verilmesi önüne geçilebilir. Dilin kurallarý gereði private bölümdeki isimlere eriþme giriþimi sentaks hatasý.

Sýnýfýn private bölümünde olan, member functionlar ve data memberlar client kodlara kapalý ancak, implementasyon da bunlarý kullanýr. C++'da sýnýfýn private bölümünü client'dan tamamen gizlemek de mümkün.
Client private memberlarý kullanamasýn yerine hiç görmesin de isteniyorsa bunun da bir yolu var. Bir sýnýfýn baþlýk dosyasý açýldýðýnda private bölümdeki isimler görünür ancak bunun da sakýncalý olduðu bir 
takým durumlar olabilir o zaman bu isimlerin görünmesi de engellenir.


Aþaðýdaki kod C kodudur, halen C++'da böyle bir kod yazýlabilir tabi ama tercih edilmez. 
Fonksiyon date nesnesi üstünde iþlem yapacaðýndan date nesnesinin adresini alýr.
/////////////////////////////////////////////////////////////////////
struct Date{
	int md, int mm, my;
}
void setDate(Date *ptr, int d, int m, int y){
	ptr->md = d; 
	ptr->mm = m; 
	ptr->my = y;
}
 int main(){
	struct Date mydate;
	setDate(&mydate, 11,11,1997);
 }
 /////////////////////////////////////////////////////////////////////

C++'daki Member function bu fonksiyondan farklý deðil, makina düzeyinde member functionlar ile setDate() fonksiyonunun kodu arasýnda hiçbir fark yok. Sadece notasyonel fark var.
Öncelikle buradaki fonksiyon ismi global, bu ismi arayan derleyici önce blok içinde arayýp, bulamazsa global alanda arayacak, bu isim herkese açýk. Üye fonksyion haline gelince bu
ismi sadece ., ->, :: saðýnda ise arayacak. Member functionlar'ýn global functionlara göre birincil farklarý scopelarý farklý, biri file scope'da diðeri class scope içerisinde.
Bu fonksiyona 4 farklý argüman gönderilir, ancak asýl önemli olan birinci parametrede geçilen mydate. Bu iþlem mydate üstünde yapýlýr. C tarzý kütüphanelerde bir iþlem nesnenin
kendisi için yapýlsa da, bu nesnenin adresi de diðer argümanlar gibi fonksiyona gönderilir. Hattta her zaman birinci parametre olarak da deðil ikinci üçüncü parametre olarak da 
gönderilir.
C++'da ise member function, fonksyion çaðrý notasyonunu da deðiþtirir. C++'da þu þekilde çaðrýlýr:

mydate.set(); //C++ member fonksiyonu böyle çaðrýlýr

Bu iþin kimin için yapýldýðý belli, noktanýn solundaki nesne için. Buradaki amaç kodu yazmanýn ve düzenlemenin kolay olmasý. Böylece adres operatörü kullanýlmaz, mydate'in adresi
argüman olarak fonksiyona geçilmez, bunu derleyici kendisi yapar. Derleyicinin kendisi objenin adresini fonksiyona gönderir, yoksa fonksiyona bu nesnenin adresini göndermeden böyle
bir iþlem yapmanýn yolu yok. Son fark olarak da kim bu fonksiyonu çaðýrabilir kim çaðýramaz bunun kontrolü yapýlýr. Member functionlarda Access Control yapma olanaðý da vardýr.
(private, public, protected kontrolü )

/////////////////////////////////////////////////////////////////////
class Date{
	int md, mm, my;
public:
	void set(int d, int m, int y); //set() sýnýfýn non-static public member function'ý
};
int main(){
	Date mydate;
	mydate.set(12,4,1879);
}
 /////////////////////////////////////////////////////////////////////
set() fonksiyonunun görünen 3 parametresi var, makina kodu düzeyinde bakýldýðýnda 4 tane parametresi var. Sýnýfýn non-static üye fonksiyonlarýnýn hepsinin çalýþacak kodda olan fakat
bildirimde gösterilmeyen gizli bir Date * türünden parametresi var. Fonksiyon bir set fonksiyonu olduðundan, mydate nesnesini set ediyor bunun için de nesnenin adresini almasý gerekir.
Derleyicinin ürettiði kodda, fonksiyona mydate'in adresi gönderiliyor argüman olarak, sadece görsel olarak yer almýyor. Non-static üye fonksiyonlarýn kaç parametre deðiþkeni varsa
gerçekte ondan 1 tane daha parametre deðiþkeni vardýr ve bu deðiþkenin türü o sýnýf türünden bir pointer. 

Sýnýflarýn member functionlarý da overload edilir. 
/////////////////////////////////////////////////////////////////////
class Date{
	int md, mm, my;
public:
	void set(int d, int m, int y); 
	void set(const char *p); //function overloading, imzalarý farklý ve scopelarý ayný
};

class Date{
	int md, mm, my;
	void set(int d, int m, int y); 
public:
	void set(const char *p); //function overloading, scopelarý ayný, imzalarý farklý
};
 /////////////////////////////////////////////////////////////////////

Data memberlar gibi member functionlar'da statik ve non-statik olmak üzere ikiye ayrýlýr.
Statik olmayanlarýn bir adres alan pointer parametresi var, non-statik member functionlar adresini aldýðý nesne üzerinde iþlem yapar.
Statik member functionlarýn instance ile alakasý yok bu yüzden de gizli bir parametre deðiþkenleri yok.

/////////////////////////////////////////////////////////////////////
class Data{
	int mx, my; 
public:
	void func(int); //görünmeyen bir parametresi var 
	static void foo(int); //görünmeyen bir parametresi yok
};
/////////////////////////////////////////////////////////////////////
func'ýn görünürde bir gerçekte iki parametre deðþkeni var. foo fonksiyonunun ise gerçekten bir tane parametre deðiþkeni var.
func'ýn çaðrýlmasý için bir Data nesnesine ihtiyaç var ancak foo'nun çaðrýlmasý için bir Data nesnesine ihtiyaç yok.

Bir fonksiyonun adresine adres operatörü ile ulaþýlýr.
void g();

C'de global bir fonksiyonun adresini almak için &g ya da function to pointer conversion ile doðrudan g; fonksiyonunun ismi kullanýlýr.
Ancak sýnýflarýn üye fonksiyonlarý için adres bu þekilde elde edilemez, çünkü derleyici örnek olarak &func() çaðrýsýný gördüðünde bunu class scope içinde aramaz.
Derleyicinin bu ismi class içinde aramasý için:

&Data::func // çözünürlük operatörünün önceliði tüm operatörlerden daha yüksekmiþ gibi düþünülür. C'deki birinci seviye operatörlerden bile daha yüksek.

Yine bu kullanýmýn geçerli olmasý için func'ýn public üye fonksiyon olmasý gerekir.
Sýnýflarýn nonstatik member functionlarý için function to pointer conversion yok yani bu fonksiyonlarýn adreslerini alabilmek için adres operatörü þart.

Statik member functionlarýn object ile alakasý yok onlar sýnýf için çaðrýlýr.
Fighter sýnýfýndan nesneler için, savaþçýlarýn yaþýný söylemesini saðlayan bir fonksiyon olsa idi bu non-static member function olurdu. Çünkü iþlem object üzerinden yapýlýr.
Ancak savaþçýlarýn yaþadýðý yerin sýcaklýðýnýn kaç derece olduðu bilgisi için static member function kullanýlýr, çünkü bu instance(object) ile alakalý deðil, fighter sýnýf nesnelerinden baðýmsýz.

Global fonksiyonlarýn gizli bir parametre deðiþkenleri olmaz. Global fonksiyon nesnenin kendisi ile ilgili iþlem yapacak ise data nesnesini fiilen bir parametre olarak 
almasý gerekiyor(ister pointer ister referans semantiði ile).
/////////////////////////////////////////////////////////////////////
class Data {
	int mx, my, mz;
public:
}

void gfunc(Data &r, int a, int b, int c);

int main(){
	Data mydata;

	gunc(mydata, 10, 20, 30); //referans semantiði ile call by reference

	return 0;
	
}
/////////////////////////////////////////////////////////////////////

Global fonksiyonlarýn public, private, protected ayrýmý yok. Yukarýdaki gfunc fonksiyonunu sýnýfýn kendisi çaðýrabilsin, clientler çaðýramasýn istiyorsam ancak C'deki 
kurallara göre bunu dosya bazýnda iç baðlantýya ait yapabilirim, Sýnýf bazýnda bunu yapmanýn yolu yok.
Global fonksiyonlar için access control yok. Yani örnek olarak gfunc fonksiyonunun içinde sýnýfýn private elemanlarýna eriþilmeye çalýþýlmasý sentaks hatasý. Global
fonksiyonlar sýnýflarýn private interface'ine eriþemez.
C'de isim arama kurallarý neyse, C++'da global fonksiyonlar içinde kullanýlan isim arama kurallarý ayný: Önce blok içine bakar bulamazsa kapsayan bloklara bakar, kapsayan
bloklarda da sýrayla bakýp bulamazsa global alanda fonksiyonun tanýmýnýn olduðu yere kadar bakar, orada da bulamazsa error. Ancak üye fonksiyonlar için arama kurallarý bu
þekilde deðil. Deðiþen noktalardan biri de isim arama kurallarý.

Üye fonksiyonlarýn tanýmlarý da C'de olduðu gibi cpp'de olacak. Bildirimi sýnýf tanýmý içinde, tanýmý cpp dosyasýnda.
Kodlar belirli istisnalar dýþýnda her zaman cpp dosyasýnda.
/////////////////////////////////////////////////////////////////////
//data.h
class Data{
	int mx, my, mz;
public:
	void set(int x, int y, int z);
};

//data.cpp 
void set(); //bu isim de aramaya dahil, o yüzden bu þekilde yazýlmasý sýnýfýn üye fonksiyonunun deðil, global bir fonksiyonun tanýmý olurdu.
void Data::set(int x, int y, int z){ // Derleyicinin set()'in sýnýfýn üye fonksiyonu olduðunu bilmesi için ismi sýnýf içinde aramasý gerekiyor.
	int mx = 10;
	++mx; // ismi önce blok içinde aradý, isim bulundu, arama bitti. Bu mx fonksiyon içindeki yerel deðiþkenin ismi.
}
void Data::set(int x, int y, int z){
	++mx; // sýnýfýn data member'i olan mx ismi bulundu. Derleyiciye göre mx, Data sýnýfýnýn non-static veri elemaný.
}
/////////////////////////////////////////////////////////////////////
Üye fonksiyonlar içerisinde isim arama da farklý, global fonksiyonlardaki gibi deðil. Örnek olarak sýnýfýn üye fonksiyonlarýndan birinin tanýmýnda bir isim kullanýldý.
Derleyici ismi önce blok içerisinde arar bulamazsa kapsayan blokta arama yapar yine bulamazssa onu da kapsayan bloklara bakar. Global fonksiyon olsa idi orada da bulamasaydý
global alana bakardý ancak burada öyle deðil. Blok içinde isim aranýp bulunamazsa class içine bakar, class scope'da arar.
 
Non-static veri elemaný bir nesnenin mx'i olduðundan, derleyici set fonksiyonunda gizli olan parametre sayesinde mx'i, ptr->mx'e dönüþtürür.
C olsaydý ptr->mx diye eriþirdik. Bu mx olarak kullanýldýðýnda derleyici bunun non-statik data memberi olduðunu anladýðýnda ptr->mx dönüþümünü kendi gerçekleþtirir.
Class scope'daki bir isim, block scope'daki bir isim tarafýndan maskelenmiyorsa, görünmesi engellenmiyor ise, o isim doðrudan kullanýldýðýnda,
o fonksiyon hangi nesne için çaðýrýlmýþ ise o nesnenin mx'i demek.

Data::set() fonksiyonunun içinde;
mx = x; // demek, atama bu fonksiyon hangi nesne için çaðýrýlmýþ ise o nesnenin mx'ine yapýlmýþtýr.

/////////////////////////////////////////////////////////////////////
void Data::set(int x, int y, int z){
	mx = x;
	my = y;
	mz = z;
}
int main(){
	Data data1, data2;
	data1.set(10,20,30); //Gizli parametre olarak data1 nesnesinin adresi fonksiyona gönderildi. Böylece mx, my ve mz; data1 in mx, my ve mz'si.
	data2.set(6,7,8);	// Burada da data2 nesnesinin mx, my ve mz'sini girilen parametreler ile set edecek.
}
/////////////////////////////////////////////////////////////////////

Sýnýfýn üye fonksiyonu içinde, sýnýfýn non-static data memberinin ismi kullanýldýðýnda ve bu isim daha dar bir scope içinde maskelenmemiþse o 
fonksiyon hangi nesne için çaðrýlmýþ ise o nesnenin elemanlarý set edilmiþ olur, gizli parametre olarak o nesnenin adresi fonksiyona geçilmiþ olur.

Sýnýfýn class scope'daki bir isimle, bloktaki bir isim ve global düzeydeki bir isim ayný ise ve bu isim üye fonksiyon içinde kullanýlýrsa, bloktaki isim
class scope'daki ismi; class scope'daki isim global scope'daki ismi gizler.
/////////////////////////////////////////////////////////////////////
//data.cpp
int mx = 10;
void Data::set(int x, int y, int z){
	int mx = 56;
	mx = 99; //yerel mx 
}
int main(){
	Data data1;
	data1.set(10,20,30);
}
/////////////////////////////////////////////////////////////////////
Yerel mx olmasaydý sýnýfýn veri elemaný olan mx deðiþmiþ, o da olmasa idi global mx deðiþmiþ olacaktý. 
Bir ismi global alanda aratmanýn yolu; unary çözünürlük operatörü. Scope resolution denen operatörü, unary prefix bir operatör olarak kullanýrsak ve 
operatör olarak bir isim verirsek, derleyici bu ismi sadece global namespace'de arar. Blok içinde de kullanýlsa bloða bakmaz ya da class scope'a bakmaz.
Üye fonksiyonun içi de olsa global fonksiyonun içi de olsa ::mx þeklinde ifade olursa, mx global scope'da aranýr.

/////////////////////////////////////////////////////////////////////
int mx = 20;

int main(){
	int mx = 10; //C'de olsa idi global mx'i kullanmanýn bir yolu yok.
	::mx = mx; //C++'da global mx deðiþkenine local mx deðiþkeni atanýr.
}
/////////////////////////////////////////////////////////////////////

Bloktaki bir isim ya da class scope'daki bir isim global scope'daki ismi gizlediðinde, global scope'daki isim kullanýldýðýnda global isme eriþmek için
unary çözünürlük operatörünün operandý olarak eriþilebilir. Bu durumda mx global alanda bulunamazsa error, sadece global alana bakýlýr.

/////////////////////////////////////////////////////////////////////
void Data::set(int x, int y, int z){
	mx = ... //þeklindeki kullanýmda isim class scope'da aranýr yani mx hangi nesne için çaðýrýldý, hangi nesne için gizli parametre olarak nesnenin kendisini
}			//argüman olarak aldýysa o nesnenin mx'i

void Data::set(int x, int y, int z){
	Data::mx // bu þekilde yapýldýðýnda da isim class scope'da aranýr. yine hangi nesne için çaðýrýldý ise o nesnenin mx'i
}

void Data::set(int x, int y, int z){
	int mx = 40;
	Data::mx = mx + ::mx; // sentaks olarak geçerli: class scope'daki isim = yerel mx + global mx
}
/////////////////////////////////////////////////////////////////////
Yani maskeleme olsa bile, C++'da maskelemenin aþmanýn yolu mevcut.
sýnýfýn üye fonksiyonu içinde isim arama: blok içinde -> kapsayan blok içinde -> class scope'da -> global alanda
Ýsim arama bir kez yapýlýr, aranan isim bulununca isim arama biter.

/////////////////////////////////////////////////////////////////////
int mx(int) //global bir fonksiyon olmak üzere
void Data::set(int x, int y, int z){
	::mx(mx);	//global mx fonksiyonuna argüman olarak sýnýfýn data memberi olan mx gönderilir.
	mx(23)		// geçersiz, fakat geçersiz olmasýnýn sebebi, mx'in sýnýfýn data memberi olmasý, sýnýfýn üye fonksiyonu olmadýðýndan geçersiz olduðudur.
}				//Bu durumda isim arama gerçekleþir, mx ismi öncelikle class scope'da bulunur, sýnýfýn data memberi, verilen error data member in sanki
				//üye fonksiyonmuþ gibi, fonksiyon çaðrýsý þeklinde kullanýlmasýnda.
/////////////////////////////////////////////////////////////////////
//data.h
class Data{
	int mx, my, mz;
public:
	void set(int x, int y, int z);
	void func(int x);
}
void Data::set(int x, int y, iny z){
	func(x);
}
///////////////////////////////////////////////////////////////////// 
Derleyici x ismini arar, x isminin aranmasýnda bir problem yok, parametrenin ismi. Ardýndan func ismi aranýr, func önce blok içinde aranýr, bulamadýðýndan
class scope'da arar, bulur ve isim arama biter, global düzeyde bir func ismi olsa dahi o görülmeyecekti. Derleyici func'ýn sýnýfýn non-static public member
function'ý olduðunu anladý. set ve func fonksyionlarýnýn gizli pointer parametreleri var, derleyici func(x) çaðrýsýný, set fonksiyonu hangi nesne için
çaðýrýldýysa func() fonksiyonunu da o nesne için çaðýrýr. main'de Data mydata; ve mydata.set(10,20,30); ile fonksiyon çaðrýsý yapýldýðýnda set fonksiyonuna
aslýnda mydata'nýn adresi gönderildi. Derleyici aslýnda þu þekilde bir kod üretir:

void Data::set(Data *p, int x, int y, int z){
	func(p,x);
	Data::func(x); //bu þekilde de yapýlabilirdi, tek fark derleyici blok içinde arama yapmamýþ olurdu
}

Bir üye fonksiyon, bir baþka üye fonksiyonu çaðýrdýðýnda bunlarýn ikisi de non-static üye fonksiyon ise derleyici aldýðý adresi öbür fonksiyona geçer.

///////////////////////////////////////////////////////////////////// 
void func(int, int); //global fonksiyonu bildirilmiþ olsun,

void Data::set(Data *p, int x, int y, int z){
	func(10,20); //error, func ismi öncelikle class scope'da bulunda ve arama bitti, global isim gizlendi ve fonksiyon çaðrýsýnda argüman ve parametre sayýlarý eþit
				 //olmadýðýndan error
	::func(x,y); // global func çaðýrýldý
	}
///////////////////////////////////////////////////////////////////// 

Global bir fonksyion ile sýnýfýn üye fonksiyonu birbirini hiç bir zaman overload etmez, ancak birbirini gizler.

///////////////////////////////////////////////////////////////////// 
void Data::set(int x, int y, int z){
	set(x,y,z); //recursive call
}
///////////////////////////////////////////////////////////////////// 

Bir sýnýfýn non-static üye fonksiyonunun sýnýfýn baþka bir non-static üye fonksyionunu çaðýrmasýnýn 2 yolu var.
Doðrudan isim ile çaðýrma. set hangi nesne için çaðýrýlmýþ ise func'da o nesne için çaðrýlacak.
Ýsim maskelenmiþ ise Data::func(x,y); þeklinde çaðrýlacak.
///////////////////////////////////////////////////////////////////// 
//data.h
class Data{
	int mx, my, mz;
public:
	void set(int x, int y, int z);
	void func(int x, int y);
};
void Data::set(int x, int y, int z){
	func(x,y); //set hangi nesne için çaðrýlýrsa func da o nesne için çaðrýlýr. Konvensiyon bu þekilde.
	Data::func(x,y);//isim bloktaki bir isim tarafýndan maskelenirse bu kullanýlýr.
}
///////////////////////////////////////////////////////////////////// 

Member function'lara private yasaðý yok. 
///////////////////////////////////////////////////////////////////// 
Data gdata; //global
void Data::set(int x, int y, int z){
	mx = x; // legal, member functionlar için private yasaðý yok
	Data data1;
	data1.mx = 45; //legal, sadece çaðrýldýðý nesne için private bölümüne deðil, fonksiyonun kodu içerisinde herhangi bir nesnenin
					//private bölümüne eriþim için bir yasak yok.
	gdata.mx = 9; //geçerli, global gdata nesnesi
}
///////////////////////////////////////////////////////////////////// 
Fonksiyon içinde çaðrýldýðý nesnenin private elemanýna, global sýnýf nesnelerinin private elemanýna, ya da yerel, parametre deðiþkenlerinin private
elemanlarýna eriþebilir. Eriþim sadece gizlice adresi aktarýlan nesne için deðil, tüm data nesneleri için geçerli. Bir sýnýfýn üye fonksiyonu kendi
sýnýfýnýn private bölümüne hangi nesne olursa olsun eriþim hakkýna sahip.

Sýnýflarýn üye fonksiyonlarý için redecleration error! Redeclaration yalnýzca global(free) fonksiyonlar için geçerli.
///////////////////////////////////////////////////////////////////// 
class Myclass{
public:
	void func(int);
	void func(int,int); //function overloading
	void func(int); //geçersiz
}
///////////////////////////////////////////////////////////////////// 

Access control C++'da her zaman en son yapýlýr. Önce function overloading resolution yapýlýr.
///////////////////////////////////////////////////////////////////// 
class Myclass{
	void func(int);
public:
	void func(int, int);
}
int main(){
	Myclass m;
	m.func(15); // Function overloading var, o yüzden f.o resolution yapýlýr, bu yapýlýrken derleyici public, private olma durumunu göz önüne almaz.
}				// Derleyici çaðýrýlmasý gereken fonksiyonu anladý, fakat o fonksiyon private olduðundan dolayý error verecek.
///////////////////////////////////////////////////////////////////// 

void Myclass::func(double d){} //sentaks hatasý, bu parametrik yapýda bir func fonksiyonunun bildirimi sýnýf içinde yapýlmamýþ. Bir fonksiyonun tanýmlanabilmesi için
o fonksiyonun sýnýf içinde bildirilmiþ olmasý gerekir. Sýnýf içinde böyle bu parametrik yapýda bildirilmiþ bir fonksiyon yok.

Bir fonksiyonun cpp dosyasýndaki tanýmýna bakarak fonksiyonun public, private yada protected mý olduðu anlaþýlmaz. Bunu anlamak için tekrardan sýnýfýn definitionuna 
bakmak gerekir. Bunu anlamak için þu þekilde bir yöntem kullanýlabilir:
//myclass.cpp
#define PUBLIC
#define PRIVATE
#define PROTECTED

PRIVATE void Myclass::func(int x){
	///
} 
Makrolarýn tanýmlarý da cpp dosyasýnda, baþlýk dosyasýnda deðil, bu þekilde tekrardan class definitionlara tekrar tekrar bakmaya gerek kalmaz.

Üye fonksiyonu sýnýfýn içinde tanýmlamakla, tanýmýný dýþarýda yapmak arasýnda fark var.
Fonksiyonlarýn tanýmlarýnýn sýnýflarýn içinde yapýlmasý, bu fonksiyonlarý inline function yapar.
///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx, my;
public:
	void func(int x){	//inline fonksiyon, inline keywordü kullanýlarak da yapýlabilirdi, fark yok. inline void func(int x){ } þeklinde..
		mx = x;
	}
};
///////////////////////////////////////////////////////////////////// 

12_11_2017_PAZAR

Sýnýfýn memberlarý 2 kategoriye ayrýlýr, non-statik ve statik veri elemanlarý. Non-static olanlar sýnýf nesnesinin fiilen içinde olan elemanlar, daha çok olmalarý daha çok sizeof.
Statik veri elemanlarý ise sýnýf baþýna tek, sýnýf nesnesinin içinde deðil.
Non-statik member functionlar, sýnýf ile iliþkilendirilmiþ fonksiyonlar, class scope içinde ve bu fonksiyonlar bu sýnýf türünden nesneler için çaðýrýlan fonksiyonlar. 
Public, private, protected fonksiyonlarýn tanýmlama sentakslarý arasýnda bir fark yok.

CONST MEMBER FUNCTIONS

void func(T *ptr);	  //set fonksiyonu
void foo(const T *p); //get fonksiyonu

///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx, my;
public:
	void func(); //gerçekte 1 tane parametre deðiþkeni var
};
///////////////////////////////////////////////////////////////////// 

C'deki yapýlar düþünüldüðünde func fonksiyonunun karþýlýðý(global fonksiyon):
void func(Mylcass *p); //C'de member function yok, bu bir set fonksiyonu
Peki üye fonksiyonlar ile void func(const Myclass *p); þeklinde adresini aldýðý bir nesneyi salt okuma amaçlý kullanacak bir fonksiyonu nasýl implemente ederiz ?
C++'da ise func(Mylcass *p) þeklindeki fonksiyonlarda Myclass *p açýk þekilde yazýlmaz, gizli parametre. Bu durumda bu set, get farklý nasýl ortaya konulacak ?

void func()const; // const üye fonksiyon, C'deki karþýlýðý void func(const Myclass *p), bu fonksiyon bir nesne için çaðýrýldýðýnda nesnenin deðiþmeyeceði garanti altýnda.
void foo();		  // C'deki karþýlýðý void foo(Myclass *p)

Const fonksiyon nesneyi deðiþtirmeyeceðini taahhüt eder. Burada kastedilen C'deki gibi deðil, nesnenin veri elemanlarýnýn deðiþtirilmeyeceði deðil. 
Problem domeyni içindeki anlamýnýn deðiþmeyeceði kastedilir. Örnek olarak Date sýnýfýnda, standart outputa çýktý verecek bir display fonksiyonu var. Bu fonksiyon const 
olmalý, çünkü bir tarihi display etmek o tarihi deðiþtirmek ile ilgili bir iþlem deðil. Bir fonksiyonun const olup olmamasý kodun nasýl yazýlacaðý ile ilgili deðil. Modelden gelen 
bir özellik. Kod olmasa da fonksiyonun const olup olmamasý kararý verilir. 
Const olsun mu olmasýn mý sorusunun cevabý "ben buna elemanlar koyacaðým, bu elemanlar deðiþecek mi" ile verilmez, bu implementasyonun sorunu. Cevap verilmesi gereken, client gözüyle
bakýldýðýnda bu sýnýf türünden bir nesne ne ifade ediyorsa, onun öz nitelikleri deðiþecek mi ? Bu karar alýnýrlen elemanlara falan bakýlmaz, önce interface oluþturulur ardýndan 
implementasyona geçilir. Interface oluþturulurken nasýl implemente edileceði düþünülmez. Önemli olan client için operasyonun ne ifade ettiði, clientin bu interface'i nasýl kullanacaðý.
Örnek olarak Fighter türünden bir sýnýfýn, tell_name() isimli bir üye fonksiyonu olduðu ve bu fonksiyonun, çaðrýldýðý savaþçý bir þekilde kendi ismini söylüyor. Bu fonksiyon const
olmalý mý olmamalý mý ? Fonksiyonun kodunda string türünden bir deðiþken olacak, o deðiþecek gibi bir düþünce doðru deðil. Sorulmasý gereken soru bu oyunun senaryosuna göre ismini 
söylemiþ bir savaþçý deðiþmiþ bir savaþçý mýdýr ? Cevabý verilmesi gereken soru bu, fonksiyonun const olup olmamasý da bu sorunun cevabýna göre belirlenir.
Mimari bir programda bir evi niteleyen bir sýnýf olduðu düþünülsün, make_light() evin ýþýklarýný yakma operasyonunu gerçekleþtirecek bir fonksiyon olduðu düþünülsün. Bunun const 
olamayacaðý çok açýk. Iþýklarý yanan bir ev ile ýþýklarý yanmayan bir farklý, mimari olarak birçok farklýlýk mevcut. Nesne deðiþiyor mu deðiþmiyor mu sorusu önemli ama nesnenin deðiþip
deðiþmediðine bakýlýrken C'deki gibi nesnenin veri elemanlarýnýn deðiþimine bakýlmaz. Interface aþamasýnda zaten veri elemanlarý henüz yok. Sýnýfýn veri elemaný kavramý, bu sýnýfýn ne iþe
yaradýðý, ne tür operasyonlarý var; bunlara karar verildikten sonra belirlenir.
Sentaks kurallarý ile paradigma karýþtýrýlmamalý, sentaks kurallarý dili ve derleyiciyi ilgilendiriyor.

Derleyici const üye fonksiyonlar için, gizli parametreyi T * türünden deðil const T * türünden yazar.

Const bir üye fonksiyon içinde sýnýfýn non-static data memberlarýný set amaçlý kullanmak sentaks hatasý.
///////////////////////////////////////////////////////////////////// 
//.h 
class Myclass{
	int mx;
public:
	void func()const;
	void foo();
};
//.cpp
void Myclass::func()const{
	mx = 45; //sentaks hatasý, "mx cannnot be modified, beacuse it is accesed through a const object"
}
void Myclass::foo(){ 
	mx = 45; //geçerli
}
///////////////////////////////////////////////////////////////////// 
func fonksiyonu içerisinde mx'in kullanýmýnýn C'deki karþýlýðý, bu hangi nesne için çaðrýlmýþsa onun mx'i. O parametre C'deki yapýlarda olduðu gibi gizli deðil de açýk olsaydý burada Myclass *ptr
gibi bir pointer olurdu. Ancak bu pointer const Myclass *ptr þeklinde olurdu. Bu durumda ptr->mx = 45; þeklindeki kullanýmda C'de de error burada da error.
Low level const pointer dereference edilirse o ancak salt okuma amaçlý kullanýlýr. Const üye fonksiyonlar için derleyicinin yaptýðý kontrollerden biri de non-statik bir veri elemanýnýn set amaçlý
kullanýlmasý durumunda verdiði error. Fonksiyon const olmasa idi zaten legal olacaktý
Const anahtar sözcüðü imzanýn bir parçasý olduðu için hem bildirimde hem de tanýmda olacak.

///////////////////////////////////////////////////////////////////// 
struct Data{		 
	int a, b,c;
};
void func(Data *ptr);
int main(){
	const Data mydata = {3,6,6};
	func(&mydata); //geçersiz
}
///////////////////////////////////////////////////////////////////// 
C'de const T * 'dan T *'a dönüþüm legal ama yanlýþ, Cpp'de ise zaten sentaks hatasý.
Yanlýþ olmasýnýn sebebi func fonksiyonunun bir set fonksiyonu olduðu belli ancak nesne const olduðundan deðiþtirilemez. 

Sýnýf nesneleri de const olabilir.
Bu durumda const olan m nesnesi deðiþtirilemez, ancak m, func fonksiyonu için çaðrýldýðýnda yine ayný þekilde geçersiz olacaktý.
func, sýnýf nesnesini deðiþtiren bir fonksiyon. m sýnýf nesnesinin adresinin türü const Myclass *, func fonksiyonunýn parametre deðiþkeninin
türü ise Myclass *, const bir sýnýf nesnesi ile sýnýfýn const olmayan bir üye fonksiyonuna çaðrý yapýldýðýnda, const T *'dan T *'a dönüþüme zorlama var.
C++'da sentaks hatasý.
Sýnýflarýn const olmayan üye fonksiyonlarý, const sýnýf nesneleri için çaðrýlamaz.
///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx;
public:
	void func();
};
int main(){
	const Myclass m;
	Myclass m1;

	m.func(); //geçersiz
	m1.func(); //geçerli
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx;
public:
	void func();
	void foo()const;
};
int main(){
	const Myclass m1;
	Myclass m2
	m1.func(); //geçersiz, sýnýflarýn non-const üye fonksiyonlarý, const sýnýf nesneleri için çaðrýlamaz.
	m2.func(); //geçerli
	m1.foo();  //geçerli, sýnýfýn const üye fonksiyonlarý, const sýnýf nesneleri ile de const olmayan sýnýf nesneleri ile de çaðýrýlýr.
	m2.foo();  //geçerli, T *'dan const T *'a dönüþüm yanlýþ ya da sentaks hatasý deðil.
}
///////////////////////////////////////////////////////////////////// 

Sýnýfýn const member functionlarý ile const olmayan member functionlarý overload edilir.
Ortada bir const overloading varsa fonksiyon kendisi const bir nesne ile çaðýrýlýrsa const olan fonksiyon, kendisi const olmayan bir nesne ile çaðýrýlýrsa 
const olmayan çaðýrýlýr.

Bir sýnýfýn iki non-statik üye fonksiyonu arasýndaki imza farký, biri const üye fonksiyon deðil, öbürü const üye fonksiyon þeklindeyse bu bir function
overloadingdir ve ayný zamanda da const overloadingdir.
Const bir sýnýf nesnesi ile çaðrýldýðýnda const olan üye fonksiyon, const olmayan sýnýf nesnesi ile çaðrý yapýldýðýnda const olmayan üye fonksiyon çaðrýlýr.
Standart kütüphane tarafýndan da çok sýk yapýlan bir overloadingdir.
///////////////////////////////////////////////////////////////////// 
class Myclass{
public:
	void func(); //1
	void func()const; //2
}
int main(){
	Myclass m;
	const Myclass cm;
	m.func(); //1 çaðýrýlýr
	cm.func(); //2 çaðýrýlýr, 1 zaten viable olmaktan çýktý, alttaki çaðrýlýr.
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Data{
public:
	void func();
	void cfoo()const;
}
void Data::func(){ //func'ýn parametresi Data *
	cfoo(); //cfoo'nun parametresi const Data *
}
//Data *'dan const Data *'a dönüþüm legal olduðundan geçerli bir çaðrý. Bir sýnýfýn const olmayan üye fonksyionunun, const üye fonksiyonunu
çaðýrmasý legal.

void Data::cfoo()const{ //parametresi const Data *
	func(); //parametresi Data *
}
//Const Data *'dan, Data *'a dönüþüm geçersiz olduðundan, geçersiz kod. Const bir üye fonksiyon içinde, sýnýfýn const olmayan bir üye fonksiyonu
çaðýrýlamaz. Const T *'dan, T *'a dönüþüm geçersiz.
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class A{
public:
	void func(); //1
	void func()const; //2
}
void A::func(){
	func(); //function overloading var, func'un parametresi A * türünden, dolayýsý ile fonksiyonun tanýmýnda çaðrýlan func fonksiyonuna gönderilen 
			parametre de A *, bu durumda kural gereði const olmayan func fonksiyonu çaðrýlýr, recursive çaðrý.
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class A{
public:
	void func(); //1
	void func()const; //2
}
void A::func()const{
	func(); //recursive call, ikinci func()const; recursive olarak çaðýrýlýr.
}
///////////////////////////////////////////////////////////////////// 
 
Const üye fonksiyonlar içinde sýnýfýn non-static data member'larý deðiþtirilemez.
Ancak const üye fonksiyonlar içinde sýnýfýn non-static veri elemanlarý deðiþtirme amacý olmadan kullanýlabilir.
Const üye fonksiyon içinde sýnýfýn const olmayan üye fonksiyonlarý çaðýrýlamaz.  
Const olmayan üye fonksiyonlar içinde sýnýfýn yine const olan üye fonksiyonlarý çaðrýlabilir.
Const sýnýf nesneleri ile sýnýfýn ancak const member functionlarý çaðýrýlabilir.
Const üye fonksiyonlarýn, statik veri elemanlarýný deðiþtirmesi legal.
 

THIS KEYWORD'U

This keywordünün sadece sýnýflarýn non-static member functionlar içinde kullanýlmasý legal. Sýnýflarýn statik üye iþlevlerinde ya da global fonksiyonlar 
içinde kullanýlamaz. This keywordü bir pointer, this pointer.

///////////////////////////////////////////////////////////////////// 
class A{
public:
	void func();
};

void A::func(){
	this; // Bu üye fonksiyon hangi nesne için çaðýrýlmýþ ise o nesnenin adresini taþýyan pointer
}
///////////////////////////////////////////////////////////////////// 

this göstericisi: fonksiyonun gizli parametre deðiþkeninin kendisini temsil eder.
this'in deðeri, fonksiyon hangi nesne için çaðrýldýysa o nesnenin adresi.
///////////////////////////////////////////////////////////////////// 
class A {
	int mx, my;
public:
	void func();
};
void A::func() {
	cout << "this = " << this << endl;
}
int main()
{
	A mya;
	cout << "&mya = " << &mya << endl;
	mya.func();
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class A{
	int mx, my;
public:
	void func();
	void foo();
};
void A::func(){
	int mx = 20; //fonksiyon bloðundaki mx, class scope'daki deðil
	this -> mx = 30; // class scope'daki x
	A::mx = 40; // class scope'daki mx
	this -> foo(); Bu þekilde de fonksiyon çaðrýsý yapýlabilir.
}
///////////////////////////////////////////////////////////////////// 

Peki this keywordü niçin var ? This keywordünün kullanýmýnýn mecburi olduðu yerler neler ?
Maskeleme bunlardan biri deðil, maskelemeyi aþmanýn tek yolu this keywordünü kullanmak deðil.
///////////////////////////////////////////////////////////////////// 
void A::func()
{
	int mx = 20;

	this -> mx = 30; //class scope'daki mx, maskeleme bu þekilde kaldýrýlabilir.

	A::mx = 40; //Ancak maskeleme bu þekilde de kaldýrýlabilir yani bunun tek yolu this anahtar sözcüðünü kullanmak deðil.
}
///////////////////////////////////////////////////////////////////// 

C++'da gerekmedikçe this kullanýlmaz. Örnek olarak üye fonksiyonlar içinde sýnýfýn öðelerinden bahsederken this kullanýlabilir, bu yanlýþ deðil ancak C++'da 
hakim bir tarz deðil. Aþaðýdaki gibi durumlarda this keywordü kullanmak yerine doðrudan data member'in ya da fonksiyonun adýnýn kullanýlmasý daha doðru.
///////////////////////////////////////////////////////////////////// 
void A::func(){

	this->mx; //yanlýþ deðil ancak C++'da tercih edilmez
	this ->foo(); //sýnýfýn baþka bir üye fonksiyonu da çaðrýlabilir
}
///////////////////////////////////////////////////////////////////// 

This keywordunu kullanmayý zorunlu kýlan senaryolar:

Birçok sýnýfýn üye fonksiyonu geri dönüþ deðeri olarak, hangi nesne için çaðrýldýysa o nesneyi geri döndürür.
func öyle bir fonksiyon ki, geri dönüþ deðeri Myclass &. func bir nedenden dolayý hangi nesne için çaðýrýrýlsa o nesneyi geri döndürecek.
this bir pointer olduðuna göre, *this ise o adresteki nesne. *this demek, fonksiyon hangi nesne için çaðrýlmýþ ise o nesne demenin kýsa yolu.
this ise fonksiyonun çaðrýldýðý nesnenin adresi demenin kýsa yolu.
C++'da çok sayýda fonksiyon bir nesne için çaðrýlýr ve o nesneyi geri döndürür, bu durumda geri dönüþ deðerinin o sýnýf türünden referans olmasý gerekir
ve *this ile geri dönmesi gerekir. 
m.func(); ifadesi m'nin kendisi demek, çünkü fonksiyonun geri dönüþ deðeri kendisine gönderilen nesne bu durumda ayný nesne için foo fonksiyonu da þekildeki
gibi çalýþýr.
///////////////////////////////////////////////////////////////////// 
class Myclass {
	int mx, my;
public:
	Myclass &func();
	void foo();
};

Myclass & Myclass::func(){

	return *this; //fonksiyon hangi nesne için çaðrýldý ise o nesneyi geri döndürür.
}
int main(){
	Myclass m;
	m.func().foo();

}
///////////////////////////////////////////////////////////////////// 

operator<<() fonksiyonlarýnýn geri dönüþ deðeri türü ostream &, hepsi kendilerine gönderilen *this nesnesini geri döndürür.
operator overloadgin aracý olmasaydý, derleyicinin yazdýðý kodu bizim yazmamýz gerekirdi.
///////////////////////////////////////////////////////////////////// 
using namespace std;
int main(){
	int x = 10;
	double d = 2.3;

	cout << x << " " << d << endl;	//cout.operator<<(x).operator<<(" ").operator<<(d).<<operator(endl);
}
///////////////////////////////////////////////////////////////////// 


func() fonksiyonu Myclass türünden m nesnesi için çaðrýlýr. func hangi nesne için çaðrýlmýþ ise o nesnenin adresi ile global f1 fonksiyonunu çaðýracaksa
bunu yapmanýn yolu yine this anahtar sözcüðünü kullanmak. this keywordü olmasaydý, o nesnenin adresini elde etmenin bir yolu olmazdý.
fonksiyonun çaðrýldýðý nesne ile f2 fonksiyonuna çaðrý yapmak için de, f2 fonksiyonu referans parametreli olduðundan nesnenin kendisini göndermek gerekli
bu durumda da *this parametre olarak geçilir.
Bu fonksiyon hangi nesne için çaðrýldýysa, o nesneye gm global nesnesini atamak da mümkün. Burada dikkat edilmesi gereken const olup olmamasý.
///////////////////////////////////////////////////////////////////// 
using namespace std;

class Myclass {
	int mx, my;
public:
	void func();
};
void f1(Myclass *ptr);
void f2(Myclass &r);
Myclass gm;
void Myclass::func() {

	f1(this);
	f2(*this);
	gm = *this; //global gm nesnesine, bu fonksiyon hangi nesne için çaðrýldýysa o atandý
	
	//*this = gm;

}
int main()
{
	Myclass m;
	m.func();
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx, my;
public:
	void func()const; 
};

void f1(Myclass *ptr);
void f2(Myclass &r);
void f3(const Myclass *ptr);
void f4(Myclass &r);
Myclass gm;

void Myclass::func(){	//parametresinin türü const Myclass * 
	f1(this); //geçersiz, const T *'dan T *'a dönüþüm geçersiz
	f2(*this); //geçersiz, const T *'dan T *'a dönüþüm geçersiz
	f3(this); //geçerli
	f4(*this); //geçerli
}
///////////////////////////////////////////////////////////////////// 

Eðer bir sýnýfýn üye fonksiyonu, hangi nesne için çaðýrýldýysa o nesnenin adresini döndürecekse geri dönüþ deðeri, T * ve return this olacak.
Eðer bir fonksiyon hangi nesne için çaðýrýldýysa o nesnenin kendisini döndürecekse, geri dönüþ deðeri T & ve return *this olacak.
Eðer bir fonksiyon global bir fonksiyona, hangi nesne için çaðýrýldýysa o nesnenin adresini gönderecekse global fonksiyona this adresini gönderecek
Global fonksiyon referans parametreli ise, yani nesnenin kendisini istiyorsa, fonksiyon *this ile çaðýrýlýr.
Const üye fonksiyon deðilse *this'e doðrudan atama da yapýlabilir.

///////////////////////////////////////////////////////////////////// 
Myclass g; //Myclass sýnýfý türünden bir nesne
void Myclass::func(Myclass *const this){ //this, top level const bir pointer
	*this = g; // const üye fonksiyon deðilse legal, const üye fonksiyon ise legal deðil.
	this = &g; // error, this her zaman top level const bir pointer, const fonksiyon olup olmamasý önemli deðil, geçersiz.
}
///////////////////////////////////////////////////////////////////// 
this deðiþtirilemez, error. Yani aslýnda func(), sýnýfýn const olmayan üye fonksiyonu, bu fonksiyonun gizli parametre deðiþkeninin türü Myclass *const this;
this kendisi const bir pointer.

///////////////////////////////////////////////////////////////////// 
void Mylcass::func(const Myclass *const this)const{ //func sýnýfýn const üye iþlevi
	*this = g; //geçersiz, ayný zamanda low level const
}	this = g; //geçersiz, this zaten deðiþtirilemez
///////////////////////////////////////////////////////////////////// 
ne *this deðiþtirilebilir, ne de this deðiþtirilebilir.
this low level const olsun mu olmasýn mý bu kodu yazana baðlý fakat this top level const olsun mu olmasýn mý bu dilin kuralý, this = top level const.

func(), foo() fonksiyonunu tüm bu þekillerde çaðýrabilir.
///////////////////////////////////////////////////////////////////// 
class Myclass{
	int mx, my
public:
	void func();
	void foo();
};

void Myclass::func(){
	foo(); //gizleme olmadýðý sürece yazýlabilir.
	Myclass::foo();
	this -> foo();
	(*this).foo();
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Date{
	int md, mm, my;
	int call_cnt = 0;
	mutable counter = 0;
public:
	void display()const; //tarih nesnesinin deðerini standart outputa yazdýrýr.
};

void Date::display()const{

	++call_cnt; //geçersiz
	++counter; //geçerli, counter mutable anahtar sözcüðünü almýþ
}
///////////////////////////////////////////////////////////////////// 
Örnek olarak sýnýfýn üye fonksiyonlarýnýn toplamda kaç kez çaðrýldýðýný öðrenmek istiyorum. Bir counter data memberi tanýmlansa ve bu counter deðeri her fonksiyon çaðrýsýnda
arttýrýlsa: YASAK, çünkü display const bir üye fonksiyon, dilin kurallarý buna izin vermiyor. Fakat benim call_cnt'yi deðiþtirmem, nesneyi deðiþtirmiyor ki.
Bu durumda kullanýlan anahtar sözcük: mutable anahtar sözcüðü. Sýnýfýn bir veri elemanýný mutable keywordü ile tanýttýðýmýzda, söylenen: "beu veri elemanýnýn sýnýf nesnesinin
gözlenebilir deðeri ile bir ilgisi yok". O nesne deðiþmiþ deðiþmemiþ, sýnýf nesnesini deðiþip deðiþmediði ile alakasý yok. Bu durumda const üye fonksiyonlarda da derleyici
bu nesnenin deðiþmesine olanak saðlar, legal kýlar, error vermez.
Mutable anahtar sözcüðü C++11 ile gelen bir özellik deðil, öteden beri mevcut.
Sýnýfýn bir non statik veri elemanýnýn mutable keywordü ile tanýtýlmasý: const üye fonksiyonlar içinde de bu deðiþtirilebilir, bunun deðiþmesi sýnýf nesnesinin deðiþmesi anlamýna 
gelmiyor.

INLINE FONKSÝYONLAR
 
Inline expansion: Derleyicilerin kullandýðý bir optimizasyon tekniði. Fonksiyona giriþ ve fonksiyondan çýkýþ kodlarýný devreden çýkartmýþ olur. 
  
Örnek olarak: derleyici square fonksiyonunun kodunu görmekte.
int square(int x){
	return x * x;
}
a = square(b); // Derleyici fonksiyonunun kodunu gördüðünden buraya direk a = b * b kodunu yapýþtýrýr. Ýþleve giriþ ve çýkýþ iþlemleri atlanmýþ olur.
Özellikle kodu küçük ve çok fazla çaðrý yapýlan fonksiyonlarda önemli bir özellik haline gelmiþtir.

Derleyicinin bunu yapabilmesi için kodu, fonksiyon tanýmýný görmesi zorunlu aksi halde bu expansion'u yapamaz. Yani çaðýrýlan fonksiyonun tanýmý  ile çaðýran fonksiyonun tanýmýnýn
ayný kaynak dosyada olmasý zorunlu. Farklý kaynak dosyalarda olmasý durumunda derleyici inline expansion yapamaz.
Fonksiyonun kodu çok uzunsa da derleyici bunu inline olarak açamayabilir.
Kontrol deyimleri sayýsý fazla ise de derleyicinin bu açýlýmý yapmasý mümkün olmayabilir.
C89'dan beri C'de yapýlan klasik bir optimizazyon. C99'dan itibaren bu açýlým derleyiciye programcý tarafýndan yaptýrýlabilir, tanýmý verilen fonksiyon için, fonksiyon çaðrýsý yapýlan
her yerde derleyicinin bu açýlýmý yapmasý derleyiciden talep edilebilir.(Derleyici bu talep karþýsýnda bu açýlýmý yapamayadabilir, bir garanti ya da zorunluluk yok)

Fonksiyonu inline yapmak için, derleyici yalnýzca fonksiyonun tanýmýný görüyorsa tanýmýnda geri dönüþ deðerinin önünde inline keyword'ü yazýlýr.
inline int square(int x){
	return x * x; // C'de ve C++'da square inline bir fonksiyon yani derleyicide inline expansion talep edilmiþ bir fonksiyon
}
 
Derleyici fonksiyonun hem tanýmýný hem de bilridimini görüyorsa o zaman inline keywordünün bildirimde yada tanýmda yada her ikisinde olmasýnýn bir sakýncasý yok, ikisinden en az birinde olmasý yeterli.

Inline expansion'dan kazanç saðlamak için en uygun adaylar; kýsa kod, çok çaðrý. Sýnýflarýn üye fonksiyonlarý söz konusu olduðunda bu tür fonksiyonlara çok sýk rastlanýr. 
///////////////////////////////////////////////////////////////////// 
//date.h
class Date{
	int md, mm, my;
public:
	int getMonthDay()const; //tek yaptýðý nesnenin deðerini get etmek, tek satýrlýk bir kod, inline yapýlmasý doðru.
};
///////////////////////////////////////////////////////////////////// 

C'de de C++'da da inline fonksiyonlarýn taným yeri baþlýk dosyasý. Inline fonksiyonlarýnýn tanýmlarýnýn yeri baþlýk dosyasý. Baþlýk dosyasý normalde bildirimler için kullanýlýr ve baþlýk dosyasýnda kod bulunmaz.
Sebebi örnek olarak x modülü y modülünden faydalanacak ama y'deki bir fonksiyonun inline olarak açýlmasý isteniyor bu durumda inline olarak açabilmesi için y.cpp'deki kodu görmesi lazým, kodu görebilmesinin tek yolu
da bunu baþlýk dosyasýna koymak, baþlýk dosyasý include edildiðinde de kendi kaynak dosyasýna yapýþmýþ olacak, böylece çaðýrýlan fonksiyon ile çaðýran fonksiyon ikisinin tanýmý da ayný kod dosyasýnda olacak.
Dolayýsýyla inline fonksiyonlarýn tanýmmlarýnýn yeri kesinlikle baþlýk dosyasý.
Bunun C++'da 3 tane önemli istisnasý var(baþlýk dosyasýnda kod bulunmasý durumu):
-inline functions
-function templates: Bir fonksiyonun kodu deðil, derleyiciye bir fonksiyonun kodunu yazdýrmak amaçlý verilen kod formülü.
-constexpr functions: Bu fonksiyonlar için derleyici eðer fonksiyonlara çaðrý sabit ifadesi ile yapýldýðýnda, fonksiyonlarýn geri dönüþ deðerini compile time'da elde eder. Geri dönüþ deðerinin compile time'da
elde edilmesi için derleyicinin fonksiyonun kodunu görmesi gerekir.

getMonthDay()const; fonksiyonu inline olmasý talebi olduðu için .h'ya yazýlýr, yine bildirimi de .h dosyasýnda yapýlýr. Bu durumda tanýmda ya da bildirimde herhangi birinde inline keywordü kullanýlýr.
///////////////////////////////////////////////////////////////////// 
//date.h
class Date{
	int md, mm, my;
public:
	inline int getMonthDay()const
};
int Date::getMonthDat()const{
	return md;
}
///////////////////////////////////////////////////////////////////// 

Bunun yerine ise, zaten hem taným hem bildirim ayný dosyada olacaðýndan aþaðýdaki konsepte izin verilmiþtir.
///////////////////////////////////////////////////////////////////// 
//date.h
class Date{
	int md, mm, my;
public:
	<inline> int getMonthDay()const{ //inline keywordü kullanýlmasa da ayný anlam.
		return md;
	}
};
///////////////////////////////////////////////////////////////////// 
Böylece baþlýk dosyasýnda sýnýfýn dýþýnda ayrý bir fonksiyon yazýlmasýna gerek kalmaz. Java yada C#'daki gibi deðil. Bir fonksiyonun kodunu class definition içinde yapmak, o fonksiyonu doðrudan inline ricasýna sokar.
Yukarýdaki durumda inline keywordü kullanýlmasa da bu bir inline function.
Fonksiyonun inline yapýlmasý isteniyorsa, baþlýk dosyasýnda bu þekilde açýlýr. Inline olmasý istenmiyorsa kod dosyasýna konur.
Kurs süresince fonksiyonlarýn inline yapýlmasýnýn bir nedeni de fonksiyon taným ve bildirimlerini ayrý ayrý yazýp vakit kaybetmemek. Yani normalde hiç de inline yapýlmasý istenmeyen fonksiyonlar da sýnýf içinde vakit 
kaybýný önlemek adýna tanýmlanýp inline yapýlabilir.

Fonksiyon çaðrýsýnda ise deðiþen bir þey yok, fonksiyon için inline açýlým ricasýnda bulunulmuþ olmasý fonksiyon çaðrý semantiðini deðiþtirmez.

///////////////////////////////////////////////////////////////////// 
class Date{
public:
	int getMonthDay()const{
		return md; //Burada isim arama class scope'un her yerinde yapýlýr.
	}
private:
	int md, mx, my;
};
///////////////////////////////////////////////////////////////////// 
Derleyici fonksiyon tanýmýndaki md ismini önce blok içinde ardýndan class scope'da arar. md ismi daha aþaðýda olmasýna raðmen geçerli bir kod.
Inline fonksiyon olmasý, sýnýf içinde inline olarak açýlmýþ olmasý, isim arama kurallarýný deðiþtirmez. Fonksiyonun sýnýf dýþýnda;
int Date::getMonthDay()const{
	return md;
}
þeklinde tanýtýlmasý ile inline olarak sýnýf içinde tanýmlanmýþ olmasý durumunda isim arama kurallarý açýsýndan bir kural farký yok.
Bu þekilde sýnýf dýþýnda tanýmý yapýlsa idi, md ismi önce blok içinde bulunamazsa class scope'da yine bulunamazsa global scope'da aranacaksa, fonksiyon sýnýf içinde inline
olarak tanýtýlmýþsa da isim arama aynen böyle gerçekleþir. Öðelerin inline tanýmýnýn üstünde ya da altýnda olmuþ olmasý ile alakasý yok. Fonksiyonun kodu sýnýf dýþýnda nasýlsa
isim arama inline fonksiyonlar için de ayný þekilde gerçekleþir.

///////////////////////////////////////////////////////////////////// 
class Date{
	typedef int Word;
	Word mx;
}; // geçerli kod

class Date{
	Word mx; 

	typedef int Word;
}; // geçersiz kod, 
///////////////////////////////////////////////////////////////////// 
Bu isimlerin aranmasý önceki arama kurallarýna tabi deðil. Word ismi önce class definition'da kullanýldýðý yere kadar aranýr ama daha aþaðýda deðil ardýndan da isim global
alanda aranýr. 

Derleyicinin fonksiyonun kodunu görmemesi durumunda, herhangi bir þekilde o fonksiyonu inline olarak açmasý mümkün deðil. Derleyicilerin tipik olarak optimizasyon switchleri olur.
Optimizasyon seçenekleri derleyici ayarlarýndan da farklýlaþtýrýlabilir. Derleyici inline olarak açýlmasý istenen fonksiyonu her zaman inline olarak açamayabilir, bu durumda herhangi
bir geçersizlik söz konusu deðil. Derleyicinin o fonksiyonu inline olarak açýp açmadýðýný assembly koda bakarak anlaþýlabilir.

SPECIAL MEMBER FUNCTIONS(ÖZEL ÜYE ÝÞLEVLER)

CONSTRUCTOR

Run time'da bir nesnenin kullanýlabilir olmasý için bir bellek alanýnda yer kaplamasý gerekiyor, nesnenin bellekteki yeri anlamýnda kullanýlan terim storage.
Ortada bir nesneden bahsediliyor ise nesnenin bellekte bir yeri olmasý gerekir. Bu birlerin ve sýfýrlarýn olduðu bellek bloðunun bir nesne olarak kullanýlabilmesi için bazý iþlemlerin 
yapýlmasý gerekiyor. Bazý durumlarda bu iþlemler çok basit olabilir, örnek olarak veri elemanlarýna deðer yerleþtirmek. Ancak nesne yönelimli programlama tarafýndaki nesneler kompleks de 
olabilir, nesne bir takým dýþsal kaynaklarý kontrol edilebilir, bir takým baþka dosyalar olabilir, bazý iþlemler için veri tabanýna baðlantý yapýlacak gibi gibi. Dolayýsýyla bir nesnenin 
bellekteki yerini edinmesi baþka, o nesnenin iþini görebilecek varlýk nedenini haklý çýkaracak hizmeti verebilecek duruma gelmesi baþka. Ýþte sýnýfýn constructor denilen üye fonksiyonu, 
nesneyi hayatý getirme görevini üstlenen üye fonksiyon. Ortada bir byte yýðýný var, bir takým kodlar çalýþacak o byte yýðýný iþi görebilecek bir nesne haline gelecek. C'de bunun en 
yakýn karþýlýðý handle sistemini kullanan kütüphanelerde, handle veren fonksiyonlar. Örnek olarak createobject diye bir fonksiyon çaðýrýlýyor, o fonksiyon aslýnda onu kullanýlabilir
bir fonksiyon haline getiriyor. Ya da setdate isimli bir fonksiyon sayesinde o nesne kullanýlabilir hale geliyor.

Bazý fonksiyonlarýn yokluðu söz konusu deðil, karar verilmesi gereken bu fonksiyonlar programcý tarafýndan mý yazýlacak yoksa derleyici tarafýndan mý ? Ýþte bu tür fonksiyonlara özel
fonksiyonlar denir.(special member functions). Constructor da bu özel fonksiyonlardan biri. 

Nesneyi hayata getiren iþlev, sýnýfýn kurucu iþlevi. Bulunmasý zorunlu olan bir fonksiyon, special member function. Constructor da bir member function. Bir sýnýf nesnesi 
hayata geleceði zaman constructor çaðýrýlýr. Bir sýnýf nesnesinin hayata gelmiþ kabul edilmesi için, sýnýfýn constructor'ýnýn çalýþmasý ve bitmesi gerekir.
Bir sýnýf nesnesi contructor kodunun çalýþmasý bittikten sonra hayata gelmiþ kabul edilir.
Bir nesnenin hayata gelmesi için = storage + çalýþan kod, nesnenin bir yerinin olmasý gerekiyor ve o yer üstünde iþlem yapan bir fonksiyonun çalýþýp bitmesi gerekir(constructor)
C++, C# ve Java arasýnda en eskisi olduðundan bu diller birçok öðeyi C++'dan almýþtýr. Ancak geliþim süreci içinde C++'da diðer dillerden bir takým öðeleri almýþtýr. Örneðin C++11 ile gelen
araçlarýn bir kýsmý zaten C# ve Java'da olan araçlardý. 
Bir sýnýfýn kurucu iþlevi, sýnýfýn ismi ile ayný isimli iþlevdir. Derleyici bir fonksiyonun constructor olduðunu sýnýfýn ismi ile ayný isimli olmasýndan anlar.
Sýnýflarýn kurucu iþlevleri geri dönüþ deðeri kavramýna sahip olmayan iþlevlerdir. C++'da bir fonksiyonun geri dönüþ deðerinin olmamasý baþka bu kavrama sahip olmamasý baþka. Fonksiyonun geri
dönüþ deðeri yoksa, void anahtar sözcüðü ile kullanýlýrlar. Bazý fonksiyonlarda ise geri dönüþ deðeri kavramý konsepti yok. Bu tür fonksiyonlar tanýmlanýrken geri dönüþ deðeri türü yazýlan yere 
birþey yazýlmaz.
C++'da kurucu iþlev sýnýfýn static iþlevi olamaz. Non-Static member function olmak zorunda. Bir contsructor static anahtar sözcüðü ile bildirilmeye ya da tanýmlanmaya çalýþýlýrsa sentaks hatasý.
Yani constructorlarýn this pointeri olmak zorunda.
Constructor, sýnýfýn const üye iþlevi olamaz. const anahtar sözcüðü ile kullanýlamaz.
Kurucu iþlevler herhangi bir parametrik yapýda olabilir.
Sýnýfýn kurucu iþlevleri sýnýfýn diðer üye iþlevleri gibi overload edilebilirler. 
Bir sýnýfýn kurucu iþlevleri, sýnýfýn public, private yada protected iþlevleri olabilir.(Çok büyük çoðunlukla public olurlar)
Sýnýflarýn kurucu iþlevleri(diðer üye iþlevlerden farklý olarak) isimleriyle yani nokta yada ok iþleciyle çaðýrýlamazlar.

///////////////////////////////////////////////////////////////////// 
class Myclass{
public:
	Myclass();
	void func(int);
}; 
int main(){
	Myclass m;
	m.func(3); //geçerli
	m.Myclass(); //geçersiz
}
///////////////////////////////////////////////////////////////////// 

Bir sýnýfýn 
a) parametresi olmayan
b) parametresi olan ancak tüm parametreleri varsayýlan argüman alan kurucu iþlevine
varsayýlan kurucu iþlev denir.(default constructor)
Argüman gönderilmeden çaðýrýlabilecek kurucu iþlevlere default constructor denir.
Default constructor(varsayýlan kurucu iþlev) bir special member function.(özel fonksiyon)

Bir sýnýf için programcý, herhangi bir constructor yazmamýþ ise derleyici sýnýf için parametresi olmayan
a)nonstatik
b)public
c)inline    bir default constructor yazar. 

Bir tane bile constructor bildirilse, derleyici default constructor yazmaz. Derleyici default constructor'ý ancak bir tane bile constructor yazýlmamýþ ise yazar.
Sýnýfa constructor yazmamak ile bunu derleyiciye yazdýrmak arasýnda bir fark yok. Bir nesne hayata gelmiþ ise mutlaka bir constructor çaðýrýlmýþtýr.

///////////////////////////////////////////////////////////////////// 
class Myclass{
public:
	Myclass(){ //sýnýfa constructor yazmamak ile derleyiciye böyle bir constructor yazdýrmak arasýnda bir fark yok.
	
	}//public, inline ve non-statik
};
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Myclass{
public:
	Myclass(){
	std::cout << "Myclass::Myclass()" << std::endl; //bir sýnýf nesnesi hayata gelince bu fonksiyon çalýþacak
	}
};
Myclass g; //global sýnýf nesnesi; Java, C# gibi dillerde global sýnýf nesnesi kavramý yok
int main(){
	std::cout << "main basladi" << std::endl;
}
///////////////////////////////////////////////////////////////////// 
Birçok programlama dilinde global sýnýf nesnesi, yerel sýnýf nesnesi gibi bir kavram yok. C++'da sýnýf nesneleri ayný primitif nesne türleri gibi statik ömürlü de olabilir, otomatik ömürlü de 
olabilir dinamik ömürlü de olabilir. Yani primitif nesnelerin bütün ömür kategorileri sýnýf nesneleri için de geçeri.
Statik ömürlü global nesneler hayata main çaðýrýlmadan önce gelirler. 
Önce statik ömürlü global nesneler hayata gelir, onlar hayata geldikten sonra main çaðýrýlýr, o yüzden önce "Myclass::Myclass()" yazýsý çýktýda görülür ardýndan "main basladi" yazýsý görülür.
Statik ömürlü global nesneler için constructor, main çaðýrýlmadan önce çaðýrýlýr.

///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {

		cout << "Myclass::Myclass()" << endl;
		cout << "this = " << this << endl;
	}
};
Myclass g;
int main(){
	cout << "main basladi" << endl;
	cout << "&g = " << &g << endl;
}
///////////////////////////////////////////////////////////////////// 
Hayata gelen nesnenin adresi this olduðuna göre, main'de ve constructor içinde yazdýrýlan adres ayný olur.

Daha önce tanýmlanan global nesnelerin constructorlarý, daha sonra tanýmlanan global nesnelerin constructorlarýndan daha önce çalýþýr.
///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {
		std::cout << "Myclass::Myclass()" << endl;
	}
};
class Data {
public:
	Data() {
		std::cout << "Data::Data()" << endl;
	}
};
Myclass g; //önce g'nin constructor'ý çaðrýlýr.
Data d;
int main()
{
	cout << "main basladi" << endl;
}
///////////////////////////////////////////////////////////////////// 


Otomatik ömürlü yerel sýnýf nesneleri için constructor programýn akýþý o koda her girdiðinde tekrar tekrar çaðýrýlýr.
///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {
	cout << "Myclass::Myclass()" << endl;	
	}
};
void func(){
	cout << "func cagirildi" << endl;
	Myclass m;
	getchar(); //buraya girip beklemeye girdiðinde ctor zaten çaðýrýlmýþ, bitmiþ, nesne hayata gelmiþ olur.
	cout << "func devam ediyor" << endl;
}
int main(){
	cout << "main basladi" << endl;
	func();
	cout << "main devam ediyor" << endl;
	func(); //m yerel nesne olduðu için her fonksiyon çaðrýsýnda yeni bir nesne hayat gelir.
}
///////////////////////////////////////////////////////////////////// 

Fonksiyona 20 kez yapýlan çaðrýlar sonucunda, fonksiyon bloðunda tanýmlý m otomatik ömürlü nesnesi için 20 kez
constructor çaðýrýlýr.
///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {
		cout << "Myclass::Myclass()" << endl;
	}
};

void func() {
	Myclass m;
}

int main() {
	for (int k = 0; k < 20; ++k) //20 kez constructor çaðýrýlmýþ olur
		func();
}
///////////////////////////////////////////////////////////////////// 

m yine otomatik ömürlü bir nesne, sadece fonksiyon ana bloðu için deðil, bu þekilde bir for döngü bloðu içinde de her döngüde
m nesneni hayata gelir. Otomatik ömürlü nesne demek illa fonksiyonun ana bloðu baþýnda olmasý gerekmiyor, for bloðu da bir blok olduðundan
program akýþý for bloðuna her geldiðinde otomatik ömürlü m nesnesi hayata gelir, bu bloktan çýktýðýnda hayata veda edecek.
Döngünün her turunda bu nesne tekrar tekrar hayata gelir.
///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {
		cout << "Myclass::Myclass()" << endl;
	}
};
int main(){
	int cnt = 0;
	for(int k = 0; k < 20; ++k){  //Yine 20 kez constructor çaðýrýldý.
		Myclass m;
		cout << "dongunun " << ++cnt <<". turu\n";
	}		
}
///////////////////////////////////////////////////////////////////// 

Statik yerel nesne statik ömürlü bir kere hayata gelir.
Statik yerel nesne'lerin global nesnelerden farký; global nesneler main çaðýrýlmadan önce mutlaka hayata gelir. C++'da statik ömürlü yerel nesnelerin hayata gelmesi için
statik ömürlü yerel nesnenin tanýmýný içeren fonksiyonun, en az bir kez çaðýrýlmasý gerekiyor, fonksiyon hiç çaðýrýlmazsa nesne de hayata gelmemiþ olur.
Fonksiyona yapýlan ilk çaðrýda meydana gelir, ve programýn sonuna kadar hayatý devam eder.
///////////////////////////////////////////////////////////////////// 
class Myclass {
public:
	Myclass() {
		cout << "Myclass::Myclass()" << endl;
	}
};
void func() {
	static int cnt = 0;
	cout << "func " << ++cnt << ". kez cagirildi\n";
	static Myclass m;}
int main() {
	cout << "main basladi" << endl; //main baþlamadan önce hayata gelen bir nesne yok.
	getchar();
	for (int k = 0; k < 10; ++k) {
		func();
	}
}
///////////////////////////////////////////////////////////////////// 

18_11_2017_CUMARTESÝ

C++'da bütün constructorlar non-statik.
Constructor ismi ile çaðýrýlamaz.
Constructor, const olamaz, const anahtar sözcüðü ile bildirilmesi sentaks hatasý.
Public, private ya da protetected olabilir. Çoðu zaman public olur. Constructor private olduðunda, o constructor'ýn çaýðýrýlacaðý bir senaryo olmasý durumunda
access kontrole takýlýr ve derleyici error verir.
C++'da yer demek nesne demek deðil, C'de çoðunlukla yer demek ile nesne demek ayný þey. C++ ve diðer OOP dillerinde ise 
sadece yerin olmasý nesnenin kullanýlmasý için yeterli deðil. Nesnenin hayata gelebilmesi için önce bazý kodlarýn çalýþmasý gerekir.
Bazý sýnýf nesnelerinin hayatýnýn bitmesi durumunda da bir takým kodlarýn çalýþmasý gerekir, bu iþi yapan fonksiyon ise destructor.
Parametresi olmayan ya da tüm parametreli varsayýlan argüman alan kurucu iþlevlere default ctor denir.
Bir sýnýfa default constructor yazýlmazsa ve baþka constructor da yazýlmazsa derleyici kendisi default constructor yazar.
Bir tane bile ctor yazýlmýþ olursa derleyici default constructor yazmaz.
Derleyici tarafýndan yazýlmýþ constructor için kullanýlan terim: Compiler generated constructor yada synthesized constructor.
Bazý özel amaçlarýn dýþýnda constructor public olur.


Özel fonksiyonlar C++11 ile default edilebilirler. Bir fonksiyonun derleyiciye yazdýrýlmasý saðlanýr.
///////////////////////////////////////////////////////////////////// 
class Neco{
public:
	Neco() = default; 
}
///////////////////////////////////////////////////////////////////// 

///////////////////////////////////////////////////////////////////// 
class Neco{
public:
	Neco(int);
	Neco() = default; //default constructor, derleyiciye yazdýrýldý
};
///////////////////////////////////////////////////////////////////// 

inline fonksiyonlarýn her zaman header file'da olmasý gerekir. Bir fonksiyonu inline yapmak demek, derleyiciye linkeri aradan çýkartmasý, fonksiyona çaðrý yapýlan yerde 
fonksiyonun derlenmiþ halini kullanmasýný, doðurdan makine kodunu çaðrý yapýlan yere gömmesini söylemektir. Derleyiciden bunu istemek için, derleyicinin fonksiyonun
kodunu(tanýmýný) görmesi gerekir. Derleyici de bunu ancak kod, header'a konulduðunda görür.

Inline fonksiyonlarýn bildirim ve tanýmlarýný ayýrmak için þöyle bir vitrin hilesi kullanýlýr
///////////////////////////////////////////////////////////////////// 
//ismail.h
inline void func(); //inline fonksiyon
void f1(int);
void f2();
void f3(int, int);

#include "ismail.hpp"
///////////////////////////////////////////////////////////////////// 
C'de bir baþlýk dosyasý baþka baþlýk dosyalarýný içerebilir ancak C'de bu tür durumlarda include iþlemi dosyanýn baþýnda yapýlýr.
Burada include komutu dosyanýn sonunda, bu inline func fonksiyonun tanýmý ismail.hpp'ye konsa ve örnek olarak enes.c, ismail.h yý
include ettiðinde önce yukarýdaki bildirimler enes.c'ye yapýþtýrýlýr ondan sonra da ismail.hpp'den gelen (ismail.hpp'de de inline
fonksiyonlarýn tanýmlarý olmuþ olsun) tanýmlar da yapýþtýrýlmýþ olur. Böyle bir kullanýmýn sebebi, inline fonksiyonlarýn bildirimleri
ile implementasyonlarýný birbirinden ayýrmak. Sonuçta deðiþen bir þey yok, sadece bildirim ve taným birbirinden ayrýlmýþ oldu.


Global sýnýf nesneleri main çaðýrýlmadan önce hayata gelir. Global düzeyde birden fazla nesne tanýmlanmýþsa önce tanýmlanmýþ olanýn constructor'ý
daha önce çaðýrýlýr. 

Data gdata, kardelen.cpp'de tanýmlanmýþ global bir sýnýf nesnesi; Neco nec, huseyin.cpp'de tanýmlanmýþ global bir sýnýf nesnesi, Murat mr de
ismail.cpp'de tanýmlanmýþ bir global sýnýf nesnesi. Main fonksiyonu da ismail.cpp'de olmuþ olsun.(main fonksiyonunun kodunun olduðu dosyaya 
genellikle iki farklý iki isim verilir, main.c ya da .cpp veya driver denir). Bu sýnýf nesnelerinin hepsi statik ömürlü nesneler olduðundan
hepsi main'den önce hayata gelir. Ancak hangisinin daha önce hayata geleceði ile ilgili dilin belirleyiciliði yok, bu tamamen derleyiciye baðlý.
Farklý modüllerde tanýmlanmýþ statik ömürlü sýnýf nesnelerinin hayata gelme sýrasýna iliþkin dilin kurallarýnýn bir belirleyiciliði yoktur. 
Main fonksiyonunun olduðu modülün de diðerlerine bir belirginliði yok.(Mecbur olmadýkça global nesne kullanýlmaz.)
Arada bir baðýmlýlýk iliþkisi olmadýðý sürece problem yok ancak örnek olarak bir þekilde nec nesnesi gdata'yý kullansa ya da gdata'nýn hayata
gelmesiyle oluþan bir sonuçtan faydalanýyorsa bu durumda nec hayata gelirken, nec'in constructor'ý çalýþýrken gdata hayata gelmemiþ olabilir.
Çünkü hangisinin daha önce hayata geleceði belirsiz.

C++'da çok özel bir durum olmadýðý sürece diziler kullanýlmaz. Diziler C++ gibi bir dil için altseviyeli bir araç, bunun yerine container sýnýflardan
vektör kullanýlabilir. Bu durumda da tabi vektörün dinamik bellek yönetimi yüzünden ilave maliyeti de mevcut. Bir de ismi array olan bir wrapper, 
sarmalayýcý sýnýf var. En kötü ihtimalle elemanlarý sýnýf türünden olan bir dizi yerine, array isimli sýnýf kullanýlabilir. Dilin kurallarý elemanlarý
sýnýf türünden olan dizilerin kullanýlmasýna engel deðil tabii ki kullanýlabilir.

Array ayný türden nesnelerin oluþturduðu grup, burada 10 tane nesne var, bu sebeple constructor 10 kez çaðrýlýr.
Derleyici dizinin her bir elemaný olan sýnýf nesnesini hayata getirir. Her eleman için this adresleri farklý, sizeof(Myclass) 16 byte olduðundan,
dizinin elemanlarýnýn adresleri 16'þar artarak gider.
/////////////////////////////////////////////////////////////////////
class Myclass{
	int x, y, z, t;
public:
	Myclass{
		std::cout << "Myclass::Myclass()" << std::endl;
		std::cout <<"this = " << this << std::endl;
	}
};

int main(){

	Myclass a[10];

}
/////////////////////////////////////////////////////////////////////

std::cout yazmak yerine, kodun baþýna using bildirimi yapýlýp yani, using namespace std; bildirimi yapýlmýþ olsa idi bu durumda nitelemeden sadece cout
yazmak yeterliydi. Bunun nedeni, normalde Myclass header file'da olur, ancak header file'da using bildirimi kullanýlmaz. Bazý kodlarda yalnýzca cout
þekilde yazýlmasýnýn sebebi, ayrý bir sýnýf dosyasý açýp, zaman kaybýný önlemek.


Constructor bir kez çaðýrýlýr, pointer deðiþken tanýmlamak sýnýf türünden nesne yaratmak anlamýna gelmez.
/////////////////////////////////////////////////////////////////////
int main(){
	Myclass m;
	Myclass *p = &m;
}
/////////////////////////////////////////////////////////////////////


Constructor, yanlýzca bir kez m1 nesnesi için çaðýrýlýr, diðerleri sadece eþ isim, yeni bir nesne hayata gelmez.
/////////////////////////////////////////////////////////////////////
int main(){
	Myclass m1;
	Myclass &m2 = m1;
	Myclass &m3 = m2;
}
/////////////////////////////////////////////////////////////////////


main'deki Myclass m1() ifadesi function declarationdur, default constructor çaðrýsý deðildir. Adý m1 geri dönüþ deðeri türü
Myclass türünden olan fonksiyonun local bildirimidir. Derleyici buna sentaks hatasý vermez, ancak tipik yapýlan bir hata olduðundan
bazý derleyiciler warning verebilir, legal. Bu local funciton declaration'dur.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() { //default constructor
		cout << "Myclass::Myclass()" << endl;
	}
};
int main() {
	Myclass m1(); //function declaration, deðiþken tanýmý deðil, default ctor bu þeiklde çaðýrýlamaz.
	Myclass m1; // deðiþken tanýmý, default constructor çaðýrýlýr.
	Myclass m1{}; //since C++11, uniform initializer ile deðiþken tanýmý, default ctor çaðýrýlýr.
	
	//Yalnýzca sýnýf nesneleri için deðil primitif türler için de ilk deðer verme sentaksý aþaðýdaki gibi olabilir.
	int x = 10;
	int y(20);
	int z{30};
}
/////////////////////////////////////////////////////////////////////

Parametreli Constructor'ýn çaðýrýlmasý:
/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	Myclass(int x){
	cout << "Myclass::Myclass(int)"<<endl;
	cout << "x = " << x << endl;
	}
};
int main(){
	Myclass m1(10); // constructor çaðýrýldý, parantez içine ifade yazýldýðýndan, fonksiyon bildirimi olma ihtimali yok
	Myclass m2{20}; //C++11'den itibaren geçerli
	Myclass m3 = 30; //constructor'un tek parametreli olmasý durumunda geçerli
}
/////////////////////////////////////////////////////////////////////


DESTRUCTOR

Sýnýfýn özel iþlevlerindendir.
Sýnýf nesnesinin hayatýný sonlandýrmak için sýnýfýn destructor'ý(özel üye iþlev) çaðýrýlýr.(sonlandýrýcý iþlev)
Ýsmi sýnýfýn ismi ile aynýdýr. Ýsmin baþýnda ~ karakteri kullanýlýr.
Geri dönüþ deðeri kavramý yok.
Parametresi olamaz, sýnýfýn destructor'ý parametresi olmayan bir iþlevdir ve varsayýlan argüman da alamaz.
Overload edilemez, bir sýnýfýn ancak tek bir destructor'ý olabilir.
Sýnýfýn non-static üye iþlevidir, statik olamaz.
Public, private, protected olabilir.
Const üye fonksiyon olamaz.
Ýsmiyle çaðýrýlmasý sentaks hatasý deðildir.(Tek bir durum dýþýnda hiçbir zaman ismi ile çaðýrýlmamalý)

Programcý sýnýf için destructor yazmazsa derleyici ilgili sýnýf için:
non-static
public
inline	bir destructor yazar.

Yazýlmadýðý taktirde derleyici bu þekilde bir constructor ve destructor yazar.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{

	}
	~Myclass()
	{

	}
}
/////////////////////////////////////////////////////////////////////

Sýnýflarýn büyük çoðunluðu için constructor'ýn yazýlmasý gerekir, ancak destructor her durumda programcý tarafýndan yazýlmasý
gereken bir fonksiyon deðildir. Dosyanýn kapatýlmasý, free store'dan alýnan bir yerin geri verilmesi gibi destructor yazýlmasýný
gerektiren bazý nedenler olmasý gerekir. Date sýnýfýndan bir nesnenin hayatý sonlandýðýnda arka planda yapýlmasý gereken bir iþlem
yok. Fakat bir baðlý liste sýnýfý olsa idi, destructor yazmak gerekirdi, sýnýf nesnesinin hayatý bittiðinde baðlý listede tutulan
öðelerin destruct edilmesi gerekir. Sýnýf nesnesinin hayatý bittiðinde yapýlacak birtakým iþlemler varsa destructor yazýlmalý.

RAII idiyomu(Resource Acquisition is Initilization)
Bazý sýnýf nesneleri iþlerini görebilmek için hayata geldiklerinde bazý kaynaklarý edinmek zorunda. Bu kaynaklar dosya olabilir, bir
bellek alaný olabilir, veri tabaný baðlantýsý olabilir. Bu nesneler hayata geldiklerinde kullanacaðý kaynaklar da nesneye baðlanýr, bu
kaynaklarý baðlama iþini yapan constructor. Nesneye ilk deðeri verilir. Kaynak edinimi ilk deðer verme yolu ile olur. Nesnenin hayatý
sonlanacaðý zaman ise bu kaynaklarý geri veren destructor. Böyle durumlarda derleyicinin yazdýðý destructor; içi, ana bloðu boþ bir
destructor olduðundan gereksinimi karþýlayamaz, destructor programcý tarafýndan yazýlýr. Her sýnýf nesneleri deðil, bazý sýnýf nesneleri
bu biçimde.

Yazý tutan sýnýf string sýnýfý, string gibi bir sýnýfýn kodunu bizim yazmamýz gerektiði düþünülsün, string sýnýfý türünden nesne bir yazýyý 
tutar. Yazýnýn tutulmasý için bir yer gerekiyor, bu durumda dinamik bellek yönetimi kullanýlmalý. Tutulacak yazý neyse onu tutabilecek kadar
bir bellek alaný gerekir. Sentaks önemli olmaksýzýn string s{ptr}; ifadesinde ptr bir char türden pointer. Arkadaki kod: ptr'nin gösterdiði yazýyý
tutabilecek kadar bir bellek alanýnýn tam bu noktada dinamik olarak elde edilmesi ve yazýnýn oraya yerleþtirileceði þekilde çalýþýr. Bu durumda
constructor bir yer ayýracak, bu yeri de destructor geri verecek.

Logger xlog; Logger bir sýnýf, loglama iþlemini yapmakta kullanýlýr. Bu durumda bir dosya oluþturmasý gerekiyor, loglama yapýldýðý sürece o dosyaya
yazýlýr bu durumda bir dosyanýn açýp kapanmasý gerekir. Constructor dosyayý açar destructor ise dosyayý kapatýr. 

Böyle nesnelere RAII nesneleri denir. Kaçýnýlmaz olarak destructor'a ihtiyaç var daha doðrusu kodunu bizim yazacaðýmýz bir destructor.

Hiç yazýlmasa da destructor'ý yazarken parantez içine void yazmak sentaks hatasý deðil.
Unutulmamali ki bu özel fonksiyonlarýn da inline olma zorunluluðu yok.
Global sýnýf nesneleri main baþlamadan önce hayata gelir, main'in kodu çalýþtýktan sonra hayatlarý biter.
/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data() {
		std::cout << "constructor" << std::endl;
		std::cout << "this = " << this << std::endl;
	}
	~Data() {
		std::cout << "destructor" << std::endl;
		std::cout << "this = " << this << std::endl;
	}
};
using namespace std;
Data gdata;
int main() {
	cout << "main basladi" << endl;
	cout << "&gdata = " << &gdata << endl;
	cout << "main sonlaniyor" << endl;
}
/////////////////////////////////////////////////////////////////////

Otomatik ömürlü yerel nesnelerin ömrü, yaratýldýklarý blok içinde sýnýrlýdýr. Closing brace'e gelindiðinde destructor çaðýrýlmýþ olur.
Func fonksiyonunun her çaðrýsýnda Data x nesneni için constructor ve destructor çaðýrýlýr.
/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data() {
		cout << "constructor" << endl;
	}
	~Data() {
		cout << "destructor" << endl;
	}
};

void func() {
	cout << "func cagirildi" << endl;
	Data x; //func() bloðu içerisinde constructor ve destructor'ý çaðýrýlýr.
}
int main() {
	
	cout << "main basladi" << endl;
	func(); 
	cout << "main devam ediyor" << endl;
}
/////////////////////////////////////////////////////////////////////


Statik yerel nesneler için destructor main'in sonunda çaðýrýlýr, programýn sonuna kadar ömürleri devam eder.
Func birden fazla kez çaðrýlsa da, nesne hayata bir kere gelir ve bir kere hayatý sonlanýr. Destructor açýsýndan global statik
ömürlü nesne ile bir farký yok, programýn sonunda nesnenin hayatý son bulur, fark constructorda, global nesnelerin constructor'larý
main baþlamadan önce çaðýrýlýr, statik yerel nesnelerin constructorlarý koda ilk kez giriþte çaðýrýlýr.
/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data() {
		cout << "constructor" << endl;
	}
	~Data() {
		cout << "destructor" << endl;
	}
};
void func() {
	cout << "func cagirildi" << endl;
	static Data x;
}
int main() {
	
	cout << "main basladi" << endl;
	func();
	cout << "main sonlaniyor" << endl;
}
/////////////////////////////////////////////////////////////////////


Dizinin her bir öðesi için constructor ve destructor çaðýrýlýr. Önce main basladi yazýsý ardýndan 5 kere constructor yazýsý gelir. Main sonlanýyor
yazýsýndan sonra da 5 kez destructor çaðýrýlýr.
/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data() {
		cout << "constructor" << endl;
	}
	~Data() {
		cout << "destructor" << endl;
	}
};

int main(){

	cout << "main basladi" << endl;
	Data a[5];
	cout << "main sonlaniyor" << endl;
}
/////////////////////////////////////////////////////////////////////


Eðer hayatta iki sýnýf nesnesi varsa constructor'ý daha sonra çaðrýlan nesnenin destructor'ý daha önce çaðýrýlýr.
Hayata gelme sýralarý ile hayatlarýnýn sonlanmasý ters orantýlý þekilde. Daha önce hayata gelen daha sonra destruct edilir.
Constructor'ý daha önce çaðrýlan x nesnesinin destructor'ý daha sonra çaðýrýldý.
/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data() {
		cout << "constructor, this = "<< this << endl;
	}
	~Data() {
		cout << "destructor, this = "<< this << endl;
	}
};
int main() {
	Data x, y;
	//Data a[4]; ayný kural burada da geçerli, hayata önce gelenin destructor'ý en son çalýþýr
	cout << "&x = " << &x << endl;
	cout << "&y = " << &y << endl;
}
/////////////////////////////////////////////////////////////////////
NOT: Bir sýnýfýn kaç tane üye fonksiyonunun olduðu sýnýf nesnesinin sizeof'u ile ilgili deðil. Fonksiyonlarýn kodu, sýnýf nesnesinin
bellekte kapladýðý alanda deðil. Üye fonksiyonlar sýnýf nesnelerinin içinde deðil.


DÝNAMÝK ÖMÜRLÜ NESNELER

Bir nesne dinamik olarak hayata getirildiðinde onun hayatýnýn bitmesinden de programcý sorumludur. 
Bir nesneyi dinamik yapan: progamcý açýsýndan istendiði zaman hayata getirilen, istendiði zaman hayatýna son verilen nesneler 
dinamik ömürlü nesnelerdir. Global nesneler dinamik ömürlü deðil çünkü ne zaman hayata geleceði ve destroy edileceði
programcý tarafýndan belirlenemez. Fonksiyon içindeki yerel nesneler eðer statik ömürlü deðillerse programýn akýþý oraya girdiðinde
hayata gelirler, programýn akýþý o koddan çýktýðýnda hayatlarý biter. Nesne tam þu noktada hayata gelsin bu noktada da hayata
veda etsin denirse bu durumda dinamik ömürlü nesneler kullanýlmalý. 
Her nesne için o nesnenin kullanacaðý bir bellek alaný gerekir. Nesne otomatik, statik ya da dinamik ömürlü de olsa bellekte 
o nesne için storage'e ihtiyaç var. Otomatik ve statik ömürlü nesnelerin bellek ihtiyacý compile time'da belirlenir ve yer ayrýlýr.
Ancak compilerin run time sýrasýnda ne zaman hayata geleceði belli olmayan bir nesne için compile time'da yer ayýrma þansý yok.
Dinamik ömürlü nesnelerin storage'ý ise run time'da elde edilir. C'de dinamik ömürlü nesneye ihtiyaç olduðunda en sýk kullanýlan
model, dinamik bellek yönetimi fonksiyonlarýný kullanmak. Malloc fonksiyonu ile yer elde edilir, nesne artýk kullanýlmayacaðý zaman
ise free fonksiyonu ile yer geri iade edilir. Bu kaynak kullanan sýnýflar ile karýþtýrýlmamalý, az önceki string sýnýfý söz konusu 
olduðunda string sýnýfý türünden nesne dinamik deðildi. Kaynak olarak kullanýlan bellek alaný ile storage birbirinden farklý kavramlar.

Bu nesnelerin hayatta olduklarý sürece, iþlerini yapabilmesi için yazýlarýn tutulduðu bellek alanýna ihtiyaç var. Bu bellek alaný resource.
Storage ile karýþtýrýlmamalý.
/////////////////////////////////////////////////////////////////////
void func()
{
	static string name("muhsin"); //statik ömürlü yerel nesne
}
int main()
{
	string s("mustafa"); //s, otomatik ömürlü yerel nesne
}
/////////////////////////////////////////////////////////////////////

String sýnýfýnýn kodunu biz yazýyor olsaydýk:
Örnekte string sýnýfýnýn sizeof'u 12 byte. Her string nesnesi için 12 bytelik yere ihtiyaç var, bu storage. Nesnenin statik, dinamik,
otomatik ömürlü olmasý farketmeksizin bu storage'a ihtiyaç var.
/////////////////////////////////////////////////////////////////////
class String{
	char *mp;
	size_t len;
	size_t mx;
}
void func(){
	static string name("muhsin"); //muhsin yazýsýnýn tutulacaðý bellek alaný ise resource olarak kullanýlan bellek alaný
}
int main()
{
	string s("mustafa");
}
/////////////////////////////////////////////////////////////////////

Kaynak olarak kullanýlan bellek alaný ile, örneðin "muhshin" yazýsýnýn tutulacaðý bellek alaný ile bu yazýyý tutmaktan ve kullandýrmaktan
sorumlu olan buradaki s nesnesinin kendisinin yerleþeceði bellek alaný birbirine karýþtýrýlmamalý. 
s nesnesi düþünüldüðünde, string nesnesinin kendisi, yukarýdaki koddaki gibi bir sýnýf olduðu düþünüldüðünde 12 bytle'lýk yeri olmalý.
mustafa yazýsý bu nesne hayata geldiði zaman bellekte bir yerde tutulmalý, bir þekilde sýnýfýn constructor'ý bu yazýyý belleðe yerleþtirir.
Bu yazýnýn tutulduðu adres 5600 adresi ise, bunu da muhtemelen veri elemanlarýndan birinde tutacak. Böylece aslýnda sýnýf nesnesi bu yazýyý
elemaný olan pointer vasýtasý ile kullandýrýr. Bu bellek alaný storage yani *this'in yerleþtiði bellek alaný ancak "mustafa" yazýsý resource.
Bu resource buradaki gibi heapten bir bellek alaný olabilir, bir dosya olabilir. Otomatik ya da statik ömürlü nesneler için bu storage'i
derleyici elde eder. Ancak dinamik ömürlü sýnýf nesnelerinin storage ihtiyaçlarý run time'da karþýlanýr.

Dinamik bellek yönetimi ile dinamik nesne ayný þey deðildir, dinamik ömürlü nesne için storage default olarak dinamik bellek 
yönetimi fonksiyonlarý ile elde edilir, ancak zorunluluk yok. 
Önce storage elde edilir, ardýndan bu storage adresini this adresi olarak kullanacak bir constructor çalýþtýrýlýr.
C'de dinamik ömürlü yapý nesnesi oluþturmanýn yolu, önce storage ayarlanýr ardýndan birtakým fonksiyonlar ile bu bellek alaný üzerinde iþlemler
yapýlýr. C++'da dinamik ömürlü nesneler operatör kullanýmý ile hayata getirilirler ve yine operatör kullanýmý ile hayatlarý sonlandýrýlýr.
Hayata getirmek için kullanýlan operatörler new operatörleri. Nesnelerin hayatlarýný bitirmek için ise delete operatörleri kullanýlýr.

new bir anahtar sözcük. Bu anahtar sözcükten sonra hayata getirilecek nesnenin türü yazýlýr. 
new Fighter;
Derleyici böyle bir operatör kullanýmýnda arkaplanda iki iþ yapar. Öncelikle storage gerekir.
Bunun için operator new fonksiyonunu çaðýrýr. Opeator new, malloc benzeri bir fonksiyon.
operator new'in parametrik yapýsý: void *operator new(size_t n); //operator new C'deki malloc'un karþýlýðý
Ne kadarlýk yer elde edilmek istenirse byte deðeri operator new fonksiyonuna argüman olarak geçilir.

operator new fonksiyonu kullanýcý tarafýndan da ayný malloc gibi çaðýrýlabilir, çaðrý yapýlýrken operator keywordu de kullanýlýr.
/////////////////////////////////////////////////////////////////////
int main(){
	size_t n;
	cout << "kaç byte :";
	cin >> n;
	operator new(n); //C'de olduðu gibi geri dönüþ deðeri cast edilip bir pointera atanabilir.
}
/////////////////////////////////////////////////////////////////////

new Fighter; dendiðinde derleyici operator new(sizeof(Fighter)); kodunu üretir. operator new void * geri döndürür.
operator new baþarýsýz olduðunda exception throw eder, malloc'da olduðu gibi null pointer geri döndürmez.
operator new çaðrýsý sonucu sonuç olarak void * türden bir ifade elde edilir. Fakat C++'da void * baþka bir türe otomatik olarak
dönüþtürülemez. Derleyici operator new ile elde edilen, sizeof(Fighter) kadar büyüklükteki bellek bloðunu this adresi olarak 
(hayata gelecek nesne adresi olarak)kullanýp, o adres için ilgili constructor'ý çaðýracak þekilde kod üretir.


static_cast<Fighter *>(operator new(sizeof(Fighter)))->Fighter() //sembolik gösterim, new ifadesi karþýlýðý derleyicinin ürettiði kod

Dilin böyle bir aracý olmasaydý bu kodu bizim yazamamýz gerekirdi ancak constructor'a da açýkça çaðrý yapýlamayaðýndan ortada problematik
bir durum oluþurdu.
opeator new baþarýlý olduðunda o sýnýfýn sýnýfýn sizeof'u kadar bellek bloðu elde eder, onun adresini void * olarak döndürür. Derleyici de
bu adresi alýp this adresi, yani hayata gelecek nesnenin adresi olarak alýp o adres için constructor'ý çaðýrýr.
Yani operator new'in verdiði adres ile constructor içindeki this adresi ayný. Constructor çalýþtýktan sonra hayata gelmiþ olan
dinamik nesneyi kullanmanýn yolu, pointer semantiði. 

new Fighter ifadesinin türü Fighter * dolayýsý ile bu nesneyi kullanabilmek adýna Fighter * türünden pointer kullanýlýr.
Kod çalýþtýrýldýðýnda destructor'ýn çaðýrýlmadýðý görülür, hayata gelmiþ nesnenin hayatý bitirilmedi. Bu nesnenin hayatý bitirilmezse
elde edilmiþ kaynaklar geri verilmemiþ olur, buna resource leak denir. Ayný zamanda memory leak'te oluþur, sizeof(T) kadar bellek
alaný geri verilmemiþ olur, bu memory leak. Ancak asýl problem sýnýf nesnesinin destructor'ý çaðýrýlmadýðýndan elde edilen kaynaklarýn geri
verilmemesi, bu yüzden bu sýnýf nesnesi iþi bittiðinde delete edilmeli.
Örnek olarak string sýnýfý düþünüldüðünde, string *p = new string{"Mustafa Kemal"}; Mustafa Kemal yazýsý heap'te tutulur. O alaný constructor
aldý, orayý geri verecek ise destructor.
Hayate gelen nesne delete edilmezse, memory leak kesinlikle olacak çünkü sizeof(T) kadar bellek alanýný, new almýþtý o geri verilmemiþ olur,
ilave olarak da bu bir RAII nesnesi ise, constructor'ý bir kaynak ediniyor, destructor'ý geri veriyor ise destructor çaðrýlmaz, destructor
çaðýrýlmadýðý için de sýnýf nesnesinin edindiði kaynaklar geri verilmemiþ olur.

/////////////////////////////////////////////////////////////////////
class Fighter {
	int a, b, c, d;
public:
	Fighter() {
		cout << "Fighter default constructor" << endl;
		cout << "this = " << this << endl;
	}
	~Fighter() {
		cout << "Fighter destructor" << endl;
		cout << "this = " << this << endl;
	}
};
int main() {
		
	cout << "main devam ediyor 1" << endl ;
	
	Fighter *p = new Fighter;  //auto p = New Fighter;
	
	cout << "p = " << p << endl; //p'nin deðeri olan adres, this adresi ile ayný.

	cout << "main devam ediyor 2" << endl;
}
/////////////////////////////////////////////////////////////////////

C++11 ile gelen yenilikler sonucu bu þekilde pointerlar kullanýlmaz, bunun yerine aslýnda pointer olmayan kendisi de sýnýf nesnesi
olan ve dinamik ömürlü nesneleri kullanýp, yönetmeye yarayan smart pointerlar kullanýlýr. Bu þekildeki C'deki pointerlara raw pointers 
denir. Smart pointerler kullanýlmadýðý zaman ise Fighter * demek yerine auto keywordü kullanýlabilir.

Dinamik nesne sentaksýnda kullanýlan yöntemler:
Fighter *p1(new Fighter);  // () ve {} kullanýlabilir.
Fighter *p2{new Fighter};
Fighter *p3 = new Fighter(); //dinamik ömürlü nesnelerde fonksiyon bildirimi ile karýþma durumu yok.
Fighter *p4 = new Fighter{};
Fighter *p5 = new Fighter;

Tümünde auto kullanýlabilir ve kullanýlmalý da.

Fighter &f = *new Fighter; //þeklinde referans semantiði de kullanýlabilir fakat tercih edilmez.


19_11_2017 PAZAR

auto p = new Fighter;
if(p->getAge() > 18) //ok operatörünün kullanýmý
	p->shoot();


Bir nesne görevi tamamlandýðýnda, o nesnenin hayatý da bitmeli, kullanýlmayacak ama hayatta olan nesneler kodlama hatasý.
Diðer programlama dillerinde olan garbage collector'un dezavantajlarýndan biri de nesnenin iþi bittiðinde otomatik olarak hayatý
sonlandýrýlýyor ancak bu her zaman nesnenin kullanýmý bittikten hemen sonra olmayabiliyor, nesnenin boþa çýkmasýyla hayatýnýn sonlanmasý 
arasýnda ne kadar süre geçeceði programcýnýn elinde deðil. C++'da ise nesnenin iþi biter bitmez nesneyi sonlandýran programcýnýn kendisi, 
baþka bir koda baðýmlýlýk yok. Verim kritik uygulamalarda problem haline dönüþebiliyor.

Nesne dinamik olmasa, nesnenin hayatýnýn bittiði yer derleyici tarafýndan tespit edilir ve destructor'ý çaðrýlýr. Ancak nesne dinamik olduðunda
nesnenin hayata ne zaman veda edeceði de programcý tarafýndan belirlenir. Bu durumda dinamik nesne delete edilmeli.
Nesne dinamik olduðunda, nesnenin hayatýnýn bitmesini saðlayacak programcýnýn yazdýðý koddur, nesne delete edilmeli. Nesne neden dinamik
yapýlýr: Bir fonksiyon yaratýr, baþka bir fonksiyona verir(factory, fabrika modeli), nesnenin türünün ne olmasý gerektiði run time'da
belli oluyordur, birden fazla nesne bir kaynaðý paylaþýmlý olarak kullanacaktýr. 

delete bir operatör, operandý dinamik nesnenin adresi. 
/////////////////////////////////////////////////////////////////////
class Fighter {
	int a, b, c, d;
public:
	Fighter() {
		cout << "Fighter default constructor" << endl;
		cout << "this = " << this << endl;
	}
	~Fighter() {
		cout << "Fighter destructor" << endl;
		cout << "this = " << this << endl;
	}
	int getAge()const{
	return 25;
	}
	void shoot(){
	cout << "shoot" << endl;
	}
};
int main() {
		
	auto p = new Fighter;
	//////
	if (p->getAge() > 18)
		p->shoot();
	////////
	delete p; // p, dinamik nesnenin adresi 
}
/////////////////////////////////////////////////////////////////////

delete operatörü için derleyicinin ürettiði kod:
delete'e operand olan adres için(buradaki p adresi için) destructor'ý çaðýrýr.
p->~Fighter();  Burada bu adres için hangi sýnýfýn destructor'ýnýn çaðrýlacaðýný p'nin türünden bilir.
p hangi türden bir adres ise o sýnýfýn destructor'ý çaðýrýlýr.
Buradan sonra geri verilmesi gereken storage, yani Fighther nesnesinin kendi durduðu yer. Bu bellek alaný operator new ile elde 
edilmiþti. Derleyici operator delete fonksiyonu ile bu kaynaklarý geri verir.
void free(void *vp); //free fonksiyonunun parametrik yapýsý
void operator delete(void *vp); //operator delete fonksiyonunun parametrik yapýsý
  
operator new C'deki malloc gibi bir fonksiyon, operator delete ise C'deki free gibi bir fonksiyon.
Nesnenin hayatý bitti fakat(destructor'ý çaðýrarak), nesnenin storage'ý da geri verilmeli;
operator delete(p); // böylece p adresindeki yerde geri verilmiþ oluyor.

delete p; -----------> p->Fighter();
					   operator delete(p); //operator new ile alýnmýþ bellek bloðu geri verilir.

programcýnýn new operatorünün karþýlýðýnda derleyicinin ürettiði kodu deðiþtirme imkaný yok, derleyici new operatörü karþýlýðý
hep ayný kodu üretir; operator new'i çaðýrýr, sonucunda bir adres elde eder, bu elde edilen adresi this adresi olarak kullanýp
constructor'ý çaðýrýr. 
delete operatörü için de derleyicinin ürettiði kodun deðiþtirilme þansý yok. delete operatörü için ise, delete'in operandý olan
adres için ilgili sýnýfýn destructor'ý çaðýrýlýr. Ardýndan operator delete fonksiyonuna bu adresi gönderir.
new operatörü overload edilemez, ancak operator new fonksiyonu overload edilebilir bu durumda derleyici yeni bir dinamik nesne
yaratýldýðýnda, onun storage ihtiyacýný elde etmek için kendisininkine deðil, sýnýfýn operator new fonksiyonuna çaðrý yapar böylece
bellek alaný elde etme iþlemi programcýnýn istediði gibi yapýlabilir.

operator keywordu, operator fonksiyonlarý denilen fonksiyonlarýn tanýmlanmasýnda kullanýlýr bu fonksiyonlar operator overloading
mekanizmasýnda kullanýlan fonksiyonlar. C'de bir yapý nesnesi; atama, adres, sizeof(), nokta operatörlerinin dýþýndaki operatörlerin
operandý olamaz. C++'da sýnýf nesneleri belirli kýsýtlamalar dahilinde istenen operatörün operandý yapýlabilir. Bu durumda derleyici
hangi operatörün operandý yapýldýysa, operator o isimli bir fonksiyona çaðrýya dönüþtürür. Ýsmi operator keywordu ile baþlayan
fonksiyonlara operator fonksiyonlarý denir. 

yalnýzca dinamik nesneler için deðil, operator new, malloc gibi de çaðýrýlýp, kullanýlabilir. Bu durumda dikkat edilmesi gereken
operator new'in geri dönüþ deðerinin void * olduðu.
/////////////////////////////////////////////////////////////////////
int main(){
	int n;
	cout << " kaç tam sayý: " <<;
	cin >> n;

	int *pd = static_cast<int *>(operator new(n*sizeof(int)));
	
	operator delete(pd);
}
/////////////////////////////////////////////////////////////////////

Dinamik nesne;
auto p = new Fighter;
auto p = new Fighter();
auto p = new Fighter{}; þeklinde oluþturulabilir.

Constructor'ýn parametreleri veya parametresi de olabilir. int türden tek parametreli bir ctor olduðu düþünülsün;
Otomatik ömürlü bir nesne oluþturulmak istense;
Fighter f(34);
Figther f{45};
Fighter f = 45; þeklinde oluþturulabilir.

Dinamik nesneler de bu þekilde oluþturulabilir
auto p = new Fighter(45);
auto p = new Fighter{25}; // narrowing conversion'a yine izin yok 


MIL SENTAKSI(Member Initializer List, Constructor Initializer List)

Constructorlarýn, snýýf nesnesinin non-statik memberlarýna ilk deðer vermesini saðlayan sentaks. Bir sýnýf nesnesi hayata geldiðinde
memberlar da hayata gelir. Bu memberlara ilk deðer vermek için MIL sentaksý kullanýlýr. MIL sentaksý sadece constructor'a özel bir
sentaks, sýnýfýn destructor'ý yada diðer fonksiyonlarý için geçerli deðil. Buradaki data memberlar, non statik data memberlar.
Statik veri öðelerine ilk deðer veren zaten constructor deðil.
Sentaksýn, constructorýn sýnýf içinde inline olarak yada cpp dosyasýnda yazýlmasý ile bir ilgisi yok.
MIL sentaksý kullanmak zorunda olunan bir sentaks deðil, buna iliþkin de dilin kurallarý mevcut.

/////////////////////////////////////////////////////////////////////
class Data {
	int mx, my;
public:
	Data();
	Data(int x, int y);
	void display()const;
};
//data.cpp
Data::Data() : mx(10), my(20) // mx'e 10 ile my'ye 20 ile ilk deðer verildi.
{
	std::cout << "Data::Data()" << endl;
}
Data::Data(int x, int y) : mx(x), my(y) // mx'e x ile, my'ye y ile ilk deðer verildi.
{
	std::cout << "Data::Data(int, int)" << endl;
}
void Data::display()const {
	std::cout << "mx = " << mx << std::endl;
	std::cout << "my = " << my << std::endl;
}
int main() {
	Data mydata;
	mydata.display();

	Data mydata1(30,40);
	mydata1.display();
}
/////////////////////////////////////////////////////////////////////

Þeklinde yapýlmýþ olsa idi: mx ve my hayata çöp deðerleriyle gelirdi, ardýndan programýn akýþý constructor'ýn kodunun içine girdiðinde
atama iþlemi yapýlýrdý. Bu durumda sýnýf nesnesinin elemanlarýna ilk deðer verilmiþ olunmaz, atama yapýlmýþ olunurdu.
Ancak mil sentaksý ilk deðer vermek için kullanýlýr. Bu bir initialization deðil, bir assignment.
/////////////////////////////////////////////////////////////////////
Data::Data(int x, int y){
	mx = x;
	my = y;
	std::cout << "Data::Data(int, int)" << endl;
}
/////////////////////////////////////////////////////////////////////

Yukarýdaki gibi bir durumda, mil sentaksýnýn kullanýlýp kullanýlmamasý derleyicinin ürettiði kodun verimliliði açýsýndan ciddi bir
farka neden olmaz. Fakat yine de bu þekilde yazýlmasý tercih edilmez. Sýnýfýn non-statik veri elemanlarýna mil sentaksý ile ilk deðer
vermeyi engelleyen bir durum olmadýðý sürece mil sentaksý tercih edilir. Mil sentaksýnda sýnýf nesnesinin veri elemanlarý hayata
istenen deðerler ile gelir. 

/////////////////////////////////////////////////////////////////////
Data::Data(int x, int y) : mx(x), my(y) 
{
	std::cout << "Data::Data(int, int)" << endl;
}
/////////////////////////////////////////////////////////////////////

Dilin net kuralýnca ...: mx(x), my(y) buradaki kodlar, her zaman programýn akýþý constructor'ýn ana bloðuna girmeden önce  çalýþýr. Sýnýf
elemanlarý hep primitif türlerden olmaz, sýnýf elemanlarý baþka sýnýflar türünden olduðunda bu durum daha büyük önem kazanýr. Baþka sýnýflar
türünden olduðu zaman onlar için de ctor çalýþmasý gerekecek, onlarýn ctorlarý önce çalýþýr ondan sonra programýn akýþý bizim nesnenin
constructor'ýnýn ana bloðu içine girer. Bir sýnýf nesnesinin eleman olarak, baþka sýnýf nesnesini veya nesnelerini almasý durumuna
composition denir. Bu durumda önce mil sentaksýndaki kodlar çalýþacak, yani önce elemanlar hayata gelecek, tüm elemanlarýn hayata 
gelmesinden sonra programýn akýþý ctorun koduna girecek. Bizim nesnemiz ise ctor'un kodu tamamen yürütüldüðünde hayata gelir.
C++'da bir nesne hayata gelirken, önce öðeler hayata gelir ardýndan o öðelere sahip sýnýf nesnesinin ctor'unun kodunun ana bloðu çalýþýr.
Benim nesnemin hayata gelmiþ olmasý için öncelikle öðeleri hayata gelecek ve bitecek ardýndan constructor'ýn ana bloðuna girecek,
ana bloða girdiði zaman da zaten öðeler hayata gelmiþ olacak, öðeler hayata gelmiþ olmasa constructor'ýn ana bloðýna akýþ gelmez.
  
Bazý varlýklara ilk deðer vermemek sentaks hatasý: referanslar ve const olanlara. Bir sýnýfýn elemaný referans ise, ve referanslar
ilk deðer almak zorunda olduðundan, ilk deðer verme sentaksý da mil sentaksý ile olduðundan, bu durumlarda mil sentaksýnýn kullanýmýndan
baþka bir kullaným olamaz.

/////////////////////////////////////////////////////////////////////
class Data{
	int &r;
public:
};
int main(){
	Data x; //sentaks hatasý
}
/////////////////////////////////////////////////////////////////////
int &r'ye ilk deðer vermek gerekiyor ancak derleyici kendi yazdýðý fonksiyonda buna ilk deðer verme þansýna sahip deðil.

/////////////////////////////////////////////////////////////////////
class Data{
	int &r;
public:
	Data(int &x){
		r = x;
	}
};
int main(){
	Data x; //sentaks hatasý
}
/////////////////////////////////////////////////////////////////////
Sýnýfýn non-statik data member'ina ilk deðer verilmedi, atama yapýldý. Fakat referanslara ilk deðer verilmesi zorunlu.

/////////////////////////////////////////////////////////////////////
class Data{
	int &r;
public:
	Data(int &x) : r(x)
	{
	}
};
int main(){
	int val = 34;
	Data x(val); //geçerli
}
/////////////////////////////////////////////////////////////////////
Data türünden x nesnesini hayata getirirken, data sýnýfýnýn non-statik memberi olarak kullanýlan referansý x ile baþlatmýþ olduk.
r, x'in yerine geçmiþ oldu. Mil sentaksý olmasa legal olma ihtimali yoktu.

/////////////////////////////////////////////////////////////////////
class Data {
	const int mx;
public:
	Data() //geçersiz
	{
		mx = 23; //ilk deðerini almalý, atama yapýlmasý geçersiz.
	}
};
/////////////////////////////////////////////////////////////////////
Sýnýfýn non-statik veri elemanýnýn kendisinin const olmasý durumunda da mil sentaksý kullanýlmak zorunda çünkü const veri elemanlarýna
da ayný referanslar gibi ilk deðer verilmesi zorunlu.


/////////////////////////////////////////////////////////////////////
class Date {
	int mday, mmon, myear;
public:
	Date(int d, int m, int y) : mday(d), mmon(m), myear(y) {}
}
/////////////////////////////////////////////////////////////////////
Yapýlmasý gereken tek iþin sýnýfýn non-statik veri elemanlarýna, constructor ile argüman olarak gönderilen deðerlerin set edilmesi
durumunda mil sentaksý kullanýlýr, ilk deðer verme iþlemi ile yapýlmasý gereken iþ tamamlansa yani ctor'un ana bloðu içinde yazýlacak
baþka hiçbir kod yoksa dahi ana blok olmak zorunda. Ana bloðun içinde yapýlacak herhangi bir kod olmasa dahi bir ana blok olmak zorunda

C++11 ile birlikte mil sentaksý'nda uniform initializer kullanýmý da legal hale gelmiþtir. Kýsýtlayýcý bir neden yoksa bu durumda
uniform initializer kullanýlmalý. Uniform initializer'ýn kullanýmýnýn avantajlarýndan biri de vexing parse'ý engellemesi. Derleyici
kimi zaman kodu parse(öðelerine ayýrmak) ederken, dilin kurallarýna göre kodu farklý þekillerde parse edebilir bu durumda hangi þekilde
parse edilmesi gerektiði dilin kompleks kurallarý tarafýndan belirli. Bu kurallar programcýnýn beklentisinin dýþýnda olabilir. 
C++'da bu öðelere ayýrma iþlemi fonksiyon bildirimi ile fonksiyon çaðrýsý arasýndaki farkdan kaynaklanabilir. Yani kodu yazan
bir fonksiyon çaðrýsý yaptýðýný düþünür ancak dilin kurallarýna göre beklenmeyecek bir þekilde aslýnda o bir fonksiyon çaðrýsý deðil, 
bir fonksiyon bildirimidir.
/////////////////////////////////////////////////////////////////////
#include <iostream>
#include <iterator>
#include <list>
using namespace std;
int main()
{
	list<int> mylist(istream_iterator<int>(cin), istream_iterator<int>()); //fonksiyon bildirimi
	list<int> mylist{istream_iterator<int>(cin), istream_iterator<int>()};//nesne tanýmý
}
/////////////////////////////////////////////////////////////////////
Bu kod legal, nesne tanýmlarken kullanýlan bir kod. Ancak dilin kurallarýna göre bu bir nesne tanýmý deðil, bir fonksiyon bildirimi.
Bunun vexing parse olmasý, yani nesne tanýmlamaya göre fonksiyon bildiriminin öncelikli olmasý parantez atomlarýnýn kullanýlmasýna iliþkin.
Parantez yerine uniform initializer kullanýlmasý durumunda bu bir nesne tanýmý.
Uniform initializer kullanýlarak derleyicinin burada ikilik yaþamasýnýn önüne geçilir, parantezin neden olduðu kodun birden fazla þekilde
yorumlanabileceði ve bir tercih yapýlmasýnýn önüne geçilir.


Nesnelerin hayata gelme sýralarý, bildirimdeki sýradýr yani önce md1 ardýndan md2 en son md3 hayata gelir. Nesneler mil sentaksýnda
ilk deðer verme sýrasýna göre hayata gelmezler. Mil sentaksýndaki yazým sýrasý belirleyici deðil. Aþaðýdaki gibi bir durumda mil
sentaksýnda hangi veri elemanýnýn önce ilk deðer aldýðýnýn bir önemi yok ancak eðer veri elemanlarýndan bir tanesi ilk deðerini
yine bir veri elemaný ile ya da o veri elemanýnýn yaratýldýðndaki sonuçlardan alýyorsa bu durumda nesnelerin hayata gelme sýralarýna 
göre mil sentaksý kullanýlmalý. Bir veri elemaný henüz hayata gelmemiþ bir veri elemanýnýn yaratacaðý sonuçlar ile ilk deðerini alamaz.
Bunun önüne geçmek adýna, bildirimdeki sýra ile mil sentaksýndaki sýralama ayný þekilde kullanýlýr.
Aþaðýdaki örnekte önce md1{d1} sonra md2{d2} ardýndan md3{d3} çalýþýr.(bildirim sýrasý bu þekilde)
/////////////////////////////////////////////////////////////////////
class Triangle{
	double md1, md2, md3;
public:
	Triange(double d1, double d2, double d3) : md2{d2}, md3{d3}, md1{d1} {} //geçerli
};
/////////////////////////////////////////////////////////////////////

Bildirimde önce char *mp; bildirildiðinden mil sentaksýnda ilk deðer önce mp'ye verilir. Ancak mp'ye ilk deðer verilirken mlen'in
deðeri kullanýlýr, fakat mlen daha sonra bildirildiðinden, mp{new char[mlen + 1 ]} ifadesinde mlen'in deðeri çöp deðerdir. Bu durumda
run time error oluþur. Bu durumda size_t mlen; bildirimi char *mp; bildiriminden önce yapýlmalýdýr.  
/////////////////////////////////////////////////////////////////////
class Name{
	char *mp;
	size_t mlen;
public:
	Name(const char *p) : mlen{ strlen(p)}, mp{ new char[mlen + 1 ] } //Run time error
	{
		strcpy(mp, p);
	}
	~Name(){
		delete[]mp;
	}
	void display()const{
		std::cout << "(" << mp << ")\n";
	}
	size_t length()const{
		return mlen;
	}
};
int main()
{
	Name myname{ "necati ergin" };
	myname.display();
}
/////////////////////////////////////////////////////////////////////

IN-CLASS INITIALIZER(C++11)

C++11 ile gelen özelliklerden biri in-class initializer. Non-statik veri elemanlarý için geçerli, C++11 öncesi sýnýfýn non-statik
veri elemanlarýna sýnýfýn içinde bu þekilde bir ilk deðer verme sentaksý yoktu. Bu kullaným ile derleyici þu þekilde bir bilgilendirme
yapýlýr: Derleyici eðer default constructor yazarsa normalde non-statik, public, inline ve ara bloðu boþ bir constructor yazar ve 
sýnýf öðelerine herhangi bir þekilde dokunmaz. Bu sentaksýn kullanýmý ile derleyici default constructor yazdýðýnda mil sentaksý ile 
int mx = exp; ifadesi ne ise bunu mil sentaksý ile kullanýr. Eðer programcý constructor yazarsa ancak bu veri öðesine dokunmazsa
derleyici yine ayný þekilde o constructora(programcýnýn yazdýðý) mx{exp}'nin eklendiðini varsayýp kodu ona göre derler.
/////////////////////////////////////////////////////////////////////
class Data{
	int mx = 10; //int mx = exp; herhangi bir ifade olabilir
public:
	void display()const{
		std::cout << "mx = " << mx << std::endl;
	}
};
int main(){
	Data mydata;
	mydata.display();
}
/////////////////////////////////////////////////////////////////////
Derleyici constructor yazýlmadýðý için sýnýfa default ctor yazar. Derleyici normalde default ctor'da, primitif öðelere dokunmaz ama 
burada default ctor yazarken, mil sentaksýný kullanýr ve mx'i deðeri ile construct eder.
Bir sýnýfýn kodunu yazarken, bazý veri elemenlarýnýn hep ayný deðer ile baþlatýlmasý isteniyorsa constructor'ýn kodunu yazarken
onu mil sentaksý ile initialize etmek yerine bu þekilde de yazýlabilir.
Birden fazla constructor overload'u varsa, in-class initializer bütün constructor overloadlarýný ilgilendirir.
in-class initializer header'da; diðer türlü mil sentaksý ile constructorýn kodunun yazýlmasý implementasyon dosyasýnda olabilir.
in-class initializer'da;
int mx(10) //kullanýmý geçersiz
int mx{10} //uniform initializer kullanýmý geçerli
/////////////////////////////////////////////////////////////////////
class Data{
	int mx{10};
	int my;
public:
	Data(int a) : my{a} {} // : mx{10}, my{a} 'ya eþdeðer
};
/////////////////////////////////////////////////////////////////////

COPY CONSTRUCTOR

/////////////////////////////////////////////////////////////////////
class Data {
public:
	Data()
	{
		cout << "Data::Data()" << endl;
	}
	~Data()
	{
		cout << "Data::~Data()" << endl;
	}
};
void foo(Data x)
{
}

int main()
{
	Data mydata;

	foo(mydata);
}
/////////////////////////////////////////////////////////////////////
Kod çalýþtýrýldýðýnda, main'deki mydata nesnesi için constructor ve destructor'ýn çaðýrýldýðý görülür ancak fonksiyona yapýlan çaðrý
neticesinde parametre deðiþkeni için yalnýzca destructor'ýn çaðýrýldýðý, constructor'ýn çaðýrýlmadýðý görülür. Aslýnda parametre 
deðiþkeni için de bir constructor çaðýrýlýr ancak çaðrýlan constructor, copy constructor'dýr. Fonksiyonun parametresi olan x için
derleyicinin yazmýþ olduðu copy constructor çaðrýlmýþtýr.


Bazý durumlarda nesneler hayata kendisi gibi ayný türden bir nesneden deðerini alarak gelirler. Bir nesne hayata deðerini kendisiyle
ayný türden olan baþka bir nesneden alarak geliyorsa, hayata gelen nesne için özel bir constructor olan copy constructor çaðýrýlýr.
(kopyalayan kurucu iþlev)
Hangi durumlarda bir nesne hayata kendisi gibi baþka bir nesneden deðerini alarak gelir: 
1)açýk ilk deðer verme sentaksý; 
T x = y; 
T x(y);
T x{y};
Hayata gelen x nesnesi için copy constructor çaðrýlýr. x ve y ayný türden ve T class type.
Copy constructor x için çaðýrýlýr.
2)call-by-value fonksiyon çaðrýsý: fonksiyon parametresi bir sýnýf türünden, argümanda yine o sýnýf türünden bir nesne. 
void func(T x); fonksiyonuna T türünden bir nesne ile çaðrý yapýlýrsa func(T y); þekinde bu durumda yine yeni bir nesne hayata gelir,
bu nesne copy constructor tarafýndan hayata getirilir. Copy ctor parametre deðiþkeni olan nesne için çaðrýlýr.
3)Geri dönüþ deðeri T türünden olan fonksiyonlarda: (T * veya T & deðil)
Fighter func(){

	return f; //geri dönüþ deðeri türü de Fighter türünden, f Fighter türünden bir nesne
}; 
Bu durumda fonksiyonun geri dönüþ deðerini tutacak bir geçici nesne olmasý gerekir. Bu geçici nesne deðerini return ifadesindeki
nesneden kopyalanarak alýr. Return ifadesi derleyicinin hayata getirdiði, aktarým iþindeki geçici nesneyi initalize eder. 

Bu 3 durumda da ortak olan, hayata gelen bir nesne var ve bu nesne hayata kendisi gibi bir nesnenin deðerini alarak hayata geliyor.

Default constructor ve destructor'dan sonraki 3.special member function.
Programcý bir sýnýf için copy ctor yazmazsa, derleyici o sýnýf için 
non statik
public
inline     bir copy constructor yazar.

Copy constructor'ýn da geri dönüþ deðeri kavramý yok.

Copy constructor'ýn diðer constructorlardan farklý olarak iki temel muhattabý var, biri hayata gelecek nesne yani fonksiyonun
kodu içerisindeki *this, diðeri de ona deðerini verecek, kopyalamada kullanýlacak nesne.
T x = y; düþünüldüðünde *this, x olur. Copy constructor x için çaðrýlýr. Copy ctor içindeki this adresi x'in adresi olur.
Bu iþlem için fonksyion y'ye, y'yi parametresine çekerek ulaþýr. Bu durumda copy constructor'ýn parametresi const & olur.

void func(T x); durumunda hayata gelecek nesne fonksiyonun parametresi olan x. Copy ctor bu x için çaðýrýlýr. This adresi x'in
adresi. y ise fonksiyona argüman olarak gönderilecek nesne.

Fighter func(){
	
	return f;
}
Durumunda ise hayata gelecek nesne, kod içinde görülmeyen, ismi olmayan, derleyicinin ürettiði kodda olan fonksiyonun geri dönüþ
deðerini tutacak geçici nesnedir. Copy ctor bu görülmeyen nesne için kullanýlýr, this o nesnenin adresi. f copy ctor'a referans yolu
ile argüman olarak gönderilir.

Ýsmi Fighter olan sýnýf için derleyicinin yazacaðý copy constructor'ýn yapýsý:
/////////////////////////////////////////////////////////////////////
class Fighter{
	int mx, my, mz;
public:
	Fighter(const Fighter &r) : mx{r.mx}, my{r.my}, mz{r.mz}{} //Derleyicinin yazacaðý copy constructor
};
/////////////////////////////////////////////////////////////////////

Derleyicinin yazacaðý copy constructor'ýn kodunda ise bütün non-statik data memberlar, parametresine çekilen diðer nesnenin ilgili,
karþýlýklý non-statik data memberlarý ile hayata getirilecek.
Derleyicinin yazdýðý copy ctor kodunun deðiþtirilme imkaný yok. Bu copy constructor programcýnýn isteðini karþýlamýyorsa, copy
constructor programcý tarafýndan yazýlmalý. 
Birçok sýnýf için istenilen, ihtiyaç duyulan derleyicinin yazdýðý copy constructor. 
Derleyici birden fazla constructor içinde hangisinin copy constructor olduðunu, parametrik yapýdan anlar.
Copy constructor da doðal olarak diðer bir constructor overload'u.
Birden fazla copy constructor yazýlmasý gibi bir durum olamaz çünkü tek bir imza var, farklý parametrik yapýda bir copy ctor olamaz.

Sýnýfa bir copy constructor yazýldýðýnda, derleyici o sýnýf için default constructor yazmaz çünkü sýnýfa herhangi bir constructor
yazýldýðýnda derleyici ilgili sýnýf için constructor yazmaz.

Copy constructor ile hayata gelen nesne y, dolayýsýyla copy constructor'daki this adresi ile y'nin adresi ayný.
Copy constructorýn parametresine ise argüman olarak x gönderildiðinden, copy ctor'daki &r adresi ile x'in adresi ayný.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() {
		std::cout << "Myclass::Myclass()" << std::endl;
		std::cout << "this	= " << this << std::endl;
	}
	Myclass(const Myclass &r) {
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
		std::cout << "this	= " << this << std::endl;
		std::cout << "&r	= " << &r   << std::endl;
	}
};
int main() {

	Myclass x;
	cout << "&x	= " << &x << endl;
	Myclass y{ x };
	cout << "&y	= " << &y << endl;
}
/////////////////////////////////////////////////////////////////////

Copy constructor ile hayata gelen nesne, func fonksiyonundaki parametre. Bu yüzden copy ctor'daki this adresi m'nin adresi ile 
ayný. Copy constructor'daki &r ise x'in adresi ile ayný, çünkü parametreye ilk deðerini veren nesne x nesnesi.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() {
		std::cout << "Myclass::Myclass()" << std::endl;
		std::cout << "this	= " << this << std::endl;
	}
	Myclass(const Myclass &r) {
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
		std::cout << "this	= " << this << std::endl;
		std::cout << "&r	= " << &r   << std::endl;
	}
};
void func(Myclass m) {
	cout << "func cagirildi" << endl;
	cout << "&m = " << &m << endl;
}
int main() {

	Myclass x;
	func(x);

	cout << "&x	= " << &x << endl;
}
/////////////////////////////////////////////////////////////////////


Ýlk olarak global nesne hayata gelir, ardýndan main baþlar ve fonksiyon çaðrýlýr. Copy ctor fonksiyonun geri dönüþ deðerini tutacak
geçici nesne için çaðýrýldý. Copy constructor'daki this adresi bu geçici nesnenin adresi ile aynýdýr, &r adresi ise global nesnenin
adresi ile aynýdýr çünkü geçici nesneye ilk deðerini veren global g nesnesidir.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() {
		std::cout << "Myclass::Myclass()" << std::endl;
		std::cout << "this	= " << this << std::endl;
	}
	Myclass(const Myclass &r) {
		std::cout << "Myclass::Myclass(const Myclass &r)" << std::endl;
		std::cout << "this	= " << this << std::endl;
		std::cout << "&r	= " << &r   << std::endl;
	}
};
Myclass g;
Myclass func() {
	cout << "func cagrildi" << endl; 
	return g;
}
int main() {

	cout << "main basladi" << endl;
	func();
	cout << "main devam ediyor" << endl;
}
/////////////////////////////////////////////////////////////////////

25_11_2017 CUMARTESÝ

Copy constructor derleyicinin yazmasýna býrakýlýrsa, hayata gelen nesnenin öðeleri diðer nesnenin karþýlýklý öðesi tarafýndan hayata
getirilir, bu da value semantic yapýsýný implemente eder. Ýki nesnenin deðerleri aynýdýr, bir deðer paylaþýmý olmaz, birinde bir deðer
deðiþikliði yapýlýrsa diðerine yansýmaz. Uygulanan value semantic ise, copy constructor'ýn derleyici tarafýndan yazýlmasýnda bir problem
yok hatta bu þekilde olmasý gerekir.

Birçok durumda sýnýfýn öðeleri, handle denilen varlýklar. Handle, baþka bir nesneye eriþimi saðlayan adres ya da referans.
Örnek olarak ayný türden A ve B isimli iki sýnýf nesnesi var, ve sýnýf nesnelerinin data memberlarýndan bir tanesi bir pointer.
B sýnýf nesnesinin data memberý olan pointer'ýn dinamik ömürlü bir nesneyi gösterdiði düþünülsün, bu durumda ptr'nin deðeri 
bir adrestir. Hayata gelecek olan sýnýf nesnesi ise A sýnýf nesnesi. Copy constructor derleyici tarafýndan yazýlýrsa, B sýnýf
nesnesinin pointer'ý, A sýnýf nesnesinin pointer'ýna ilk deðer verecek. Yani iki sýnýf nesnesinin pointerlarýnýn deðerleri de 
ayný olacak, ayný adresi gösterecekler. Bu durumda ikisi de ayný kaynaðý göstermiþ olacak. Nesnelerden biri bu adresteki kaynaðý
deðiþtirirse diðer sýnýf nesnesinin kaynaðý da deðiþmiþ olacak. Value semantic olmaktan çýktý. 
Derleyicinin yazmýþ olduðu copy constructor kaynak paylaþýmý sonucunu doðurur. Bu duruma müsaade edilmesi hemen her zaman run
time hatasýna neden olur. B' nin içindeki pointer, B'nin bir kaynaðýný gösterir. Bu kaynaðý B nesnesine baðlayan B nesnesi
için çaðrýlan constructor. Yine bu kaynaðý geri verecek olan ise destructor. A ve B ayný türden olduðu için hangisi hayata
daha önce veda ederse onun için destructor çaðrýlýr. Destructor bu kaynaðý geri verir, diðer nesne halen hayatta olmasýna
raðmen kaynaðý geri verilmiþ olacak. Bu nesnenin kaynaðý kullanma giriþimi run time hatasý olur.
Bu durumda istenen kod, copy constructor ile nesne hayata getirildiðinde pointer'ý doðrudan kopyalamak yerine value semantic'i
sürdürmek adýna hayata gelen nesne'de bir kaynak edinsin, hayata gelen nesnenin pointer'ý da onun kaynaðýný göstersin. Kopyalama
ise bu iki kaynak arasýnda olsun, yani hayatta olan nesnenin kaynaðý, hayata yeni gelen nesnenin oluþturduðu kaynaða kopyalansýn.
Böylece iki nesne ayný kaynaðý paylaþmamýþ olur. Eðer kaynak deðerin bir parçasý ise deðerler ayný olmuþ olur ve nesnelerden biri
kendi kaynaðý üzerinde deðiþiklik yaptýðýnda bundan diðer nesne etkilenmez. Destructor bir sýnýf nesnesi için çaðýrýldýðýnda ve 
o sýnýf nesnesinin kaynaklarýný iade ettiðinde, diðer sýnýf nesnesinin kaynaðý bu durumdan etkilenmemiþ olur.

Derleyicinin yazdýðý copy ctor, deðerleri kopyalama yani pointer da olsa pointerý kopyalayacak böyle kopyalamaya sýð kopyalama
anlamýnda shallow copy veya memberwise copy denir yani öðe öðe kopyalama. Ancak eðer öðelerin handle olmasý durumunda yapýlmasý
gereken pointerlarý birbirine kopyalamak deðil onlarýn gösterdiði nesneleri birbirine kopyalamak tabi yeni kaynak edindikten
sonra, böyle kopyalamaya da derin kopyalama anlamýnda deep copy denir. Rai nesneleri söz konusu olduðunda eðer zaten kaynaklarýn
paylaþýlmasý istenmiyorsa sýnýfa copy constructor yazmak zorundayýz, derleyicinin yazmýþ olduðu copy constructor run time hatasýna
neden olur. Gerçekten de ayný kaynaðýn paylaþýlmasý isteniyorsa bu tabi yapýlabilir ancak bu þekilde olmaz, shallow copy yoluyla
ayný kaynak paylaþýlmýþ olur ancak destructor'ýn çaðýrýlmasý ile kaynaðýn iade edilmesi problemi çözülmüþ olmaz. Yani kaynak paylaþýmý
isteniyor olsa da derleyicinin yazmýþ olduðu copy constructor kullanmak yeterli deðil.

/////////////////////////////////////////////////////////////////////
class Logger {
	FILE *mf;
public:
	Logger(const char *pfname)
	{
		mf = fopen(pfname,"w");
		////////
	}
	~Logger()
	{
		fclose(mf);
		cout << "dosya kapatildi\n";
	}
	void log(const char *p)
	{
		fprintf(mf, "%s\n", p);
	}
};
int main()
{
	Logger log1{"logneco.txt"};
	//////
	log1.log("neco log verileri\n");
	
	if (1) {
		Logger log2{ log1 };
		log2.log("ahmet log verileri\n");
	}

	log1.log("neco yeni bir log\n"); //Run Time Hatasý
}
/////////////////////////////////////////////////////////////////////
Logger sýnýfýnýn constructor'ý, sýnýf türünden bir nesne hayata geldiðinde belirtilen isim ile bir dosya oluþturur, log isimli fonksiyon
ise o dosyaya yazý yazýlmasýný saðlar, destructor ise dosyayý kapatýr. Main içinde log1 nesnesi ile logneco.txt adlý dosya oluþturulur
ve içine "neco log verileri" yazýlýr. Ardýndan if bloðunun içinde log2 nesnesi log1 nesnesinin deðeri ile hayata gelir. Bu durumda 
derleyicinin yazmýþ olduðu copy constructor çaðýrýlýr ve log1'in karþýlýklý öðeleri log2'ye kopyalanmýþ olur, ayný kaynaðý paylaþýr 
durumdadýrlar. if bloðu sona erdiðinde o blokta hayata gelen log2 nesnesi için destructor çaðýrýlýr ve dosya kapatýlmýþ olur, if
bloðunun ardýndan log1 nesnesi üzerinden dosyaya tekrar yazý yazýlmak istenir ancak dosya, log2'nin if bloðu içinde hayatýnýn sona
ermesi sonucu çalýþan destructor ile kapatýldýðýndan iþlem baþarýsýzlýkla sonuçlanýr ve run time hatasý meydana gelir.


/////////////////////////////////////////////////////////////////////
class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp { new char[mlen + 1]} {
		strcpy(mp, pa);	
	}
	~Address(){
		delete[]mp;
	}
	void print()const{
		std::cout << "Adres = " << mp << endl;
	}
	size_t getlen()const{
		return mlen;
	}
};
void func(Address a)
{
	std::cout << "func cagrildi\n";
	a.print();
	std::cout << "func sona erdi\n";
	getchar();
}
int main()
{
	Address a1{ "Necati Ergin Astoria Plaza Kat 27 Esentepe" };
	cout << a1.getlen() << endl;
	a1.print();
	func(a1);

	a1.print();
}
/////////////////////////////////////////////////////////////////////
Kodda func fonksiyonu çaðýrýldýðýnda, copy constructor çaðrýlýr. Func fonksiyonunun parametresi olan a nesnesine, fonksiyona 
argüman olarak gönderilen a1 nesnesi copy ctor vasýtasýyla kopyalanýr, ve her iki nesne için de göstericiler de kopyalanmýþ olur.
Fonksiyonun ana bloðu bittiðinde, a nesnesinin de ömrü biteceðinden, a nesnesi için destructor çaðrýlýr ve nesnenin kaynaklarý
geri verilir. Bu durumda a1 nesnesinin kaynaklarý da iki nesne ayný kaynaðý kullandýðýndan geri verilmiþ olur. Program akýþýnýn
devamýnda a1 nesnesinin bir kaynaðý yoktur, bu durumda a1 nesnesinin pointer'ý invalid hale geldi, bu pointerýn kullanýmý run time
error'a neden olur. a1 nesnesinin print fonksiyonunun çaðrýlmasý ile error meydana gelir, çünkü artýk a1 nesnesinin pointerinin 
tuttuðu adreste bir kaynak mevcut deðil, bunun kullanýmýna iliþkin kodlar run time errora sebep olur.

Bu durumu engellemenin 2 yolu var. Ýlk olarak sýnýf kopyalanmaya kapatýlabilir. Bu durumda sýnýf kopyalanamaz olarak sunulmuþ olur.
Clientlar kopyalama iþlemlerinde bu sýnýflarý kullanamaz. Adress nesneleri birbirine kopyalanamaz. Birtakým C++ araçlarý kullanýlarak
kopyalama giriþiminin run time hatasý deðil compile time hatasý olmasý saðlanabilir.
Ýkinci çözüm ise copy constructor'ýn programcý tarafýndan yazýlmasý.

Yukarýdaki örnekte bir run time hatasý'da main'de hayata gelmiþ a1 nesnesinin main sonunda destructor'ýnýn çaðrýlmasýnda. Kaynaklarý 
zaten geri verilmiþ bir sýnýf nesnesi için destructor'ýn çaðrýlmasý da bir baþka run time hatasý.
Copy constructor ile hayata gelecek nesne için yeni bir bellek alaný alýnmalý. Bellek alaný paylaþýlmamalý. Nesnenin pointerý'da bu 
yeni bellek alanýný göstermeli. Kendisinden kopyalama yapýlacak nesnenin kaynaðýndaki, bellek alanýndaki verilerin de copy ctor ile
hayata gelecek nesnenin bellek alanýna kopyalanmasý gerekir.

Örnek olarak a1 nesnesinin edindiði kaynaðýn adresinin 3400 olduðu düþünülsün yani a1 nesnesinin pointer'ýnýn deðeri 3400 adresidir.
Copy ctor derleyici tarafýndan yazýldýðýnda a1 nesnesi ile ilk deðerini alan, copy constructor ile hayata gelen nesnenin pointerý'da
3400 adresini gösterir, çünkü derleyicinin yazmýþ olduðu copy ctor karþýlýklý deðerleri birbirine kopyalar. Bu durumda iki farklý 
nesnenin göstericilerinin deðerleri ayný olur böylece birinin destructor'ý çaðrýldýðý anda o adresteki kaynak geri verilmiþ olur ve diðeri
ile o adresteki kaynaklara eriþim run time hatasýna neden olur. Bizim yazdýðýmýz copy constructor'da hayata getireceðimiz nesne için
ayrý bir bellek alaný alýnmalý ve nesnesnin göstericisi bu bellek alanýnýn adresini tutmalý. Bellek alaný iki nesne tarafýndan paylaþýlmamalý.

Dilin kurallarý her ne kadar farklý parametrik yapýlarda da copy constructor yazýlmasýna izin verse de asla baþka parametrik yapuda bir 
copy ctor yazýlmamalý. Yazýlacak olan copy ctor'un parametrik yapýsý derleyicinin yazdýðý ile ayný olmalý.
Teorik olarak Address sýnýfý için Address(Address) þeklinde bir copy ctor da yazýlabilir, ancak eðer bu þekilde yazýlýrsa copy 
constructror'ýn parametre deðiþkeni için de copy ctor çaðrýlýr, bu durumda recursive çaðrý olur. Bu yüzden de copy ctor'un
parametresi T türünden deðil const T & türünden olnmalý.

Address sýnýfý için böyle bir copy constructor yazýlýr.
/////////////////////////////////////////////////////////////////////
Address(const Address &r) : mlen{ r.mlen }, mp{ new char[mlen + 1] } {
	strcpy(mp, r.mp);
}
/////////////////////////////////////////////////////////////////////
copy ctor derleyiciye býrakýlsa derleyici mp için, mp{r.mp} kodunu yazar. Kendi yazdýðýmýzda ise mp için yeni bir dinamik bellek bloðu
elde edilir. strcpy fonksiyonu ile de edinilmiþ kaynaklar kopyalanýr.

Copy constructor eriþim kontrollerine dahil, yani eðer copy ctor sýnýfýn private bölümünde yazýlýrsa copy constructor'ýn çaðrýlacaðý
kodlar geçersiz. Geçersiz olma sebebi eriþim kontrolüne takýlmasý.Bu durumun sakýncasý ise sýnýfýn kendi kodlarý içindeki kopyalamaya 
engel olmaz. Copy constructor private ancak sýnýfýn üye fonksiyonlarý sýnýfýn private bölümüne eriþebilir, sýnýfýn üye fonksiyonlarý
tarafýndan copy constructor halen eriþilebilir.
/////////////////////////////////////////////////////////////////////
class NotCopy{
	NotCopy(const NotCopy &r);
public:
	NotCopy();
	void func(NotCopy &r){
		NotCopy a;
		NotCopy b(a); //geçerli
		*this = r;  //geçerli
		}
};
int main()
{
	NotCopy x;
	NotCopy y(x);  //gecersiz private copy constructor
}
/////////////////////////////////////////////////////////////////////

Ýþlevlerin default ve delete edilmesi: Bir iþlev ancak special member function ise default edilebilir. Delete edilmesi ise herhangi bir 
fonksiyona tanýnan bir özellik.
/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	Myclass() = default; //C++11'den itibaren
	Myclass(const Myclass &) = default;
};
/////////////////////////////////////////////////////////////////////
Örnekte default constroctur ve copy constructor'ýn default edilmesi ile bunlarýn derleyici tarafýndan olmasý gerektiði gibi yazýlmasýnýn
derleyiciye bildirilmesi demek. Bir özel fonksiyonun kodunun özellikle derleyici tarafýndan yazýlmasý isteniyorsa kullanýlan anahtar sözcük.
Bu örnekte default edilmeseydi de derleyici kendisi yazacaktý ancak default etmek ile hiç bildirmemek arasýnda da fark mevcut, bu ileride
iþlenecek. Normal koþullarda derleyici bu özel fonksiyonlarýn kodunu yazmýyor olabilir(bu durumda ileride görülecek) default anahtar sözcüðü 
ile normalde derleyici bu fonksiyonu yazmýyor ise yazýlmasý saðlanýr. Örnek olarak int parametreli bir ctor yazýldýðýnda derleyici default ctor
yazmaz, derleyicinin default ctor'u olduðu gibi yazmasý için default keywordü kullanýr.

/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	Myclass() = delete; //C++11'den itibaren
};
/////////////////////////////////////////////////////////////////////
delete herhangi bir fonksiyona tanýnan bir hak.
Bir fonksiyonun delete edilmesi "bu fonksiyon var ama fonksiyona yapýlan çaðrýlar geçersiz olsun" anlamýna gelir. Delete edilmiþ fonksiyonlar
function overload resolution'a katýlýr. Ancak buna yapýlan çaðrý dilin kurallarýna göre geçersiz olur.

/////////////////////////////////////////////////////////////////////
void func(float) = delete;
void func(double);
void func(long);
int main{
	func(12.F); //geçersiz, sentaks hatasý
}
/////////////////////////////////////////////////////////////////////
Bir fonksiyon delete edildiðinde yok muamelesi görmüþ olsaydý bu durumda func(12.F) çaðrýsýnda double parametreli func fonksiyonu çaðrýlýrdý.
Delete edilmiþ iþlevler function overload resolution'a katýlýr, derleyici resolution iþlemi sonucunda birinci iþlevin çaðrýlmasý gerektiðine
karar verdikten sonra delete kontrolünü yapar, ve bu fonksiyona yapýlan çaðrýlarýn geçersiz olacaðýný görür, kod geçersiz olur.
Delete kontrolü, function overload resolution sonuçlandýktan sonra yapýlýr.
Böylece bir fonksiyonun belirli türden bir argüman ile çaðrýlmasý engellenebilir.

/////////////////////////////////////////////////////////////////////
template<typename T>
void func(T x) = delete;

void func(int x) 
{
	cout << "islev sablonundan uretilmeyen islev" << endl;
}

int main()
{
	func(10); //geçerli
	func(2.9); //geçersiz
}
/////////////////////////////////////////////////////////////////////
Template kullanýmý ile bir fonksiyonun yalnýzca belirlenmiþ bir tür ile çaðýrýlmasý onun dýþýndaki türlerin argüman olarak kullanýlmasý durumunun
geçersiz olmasý saðlanabilir. Þablonlara iliþkin önemli bir kural: standartlara göre bir fonksiyon þablonuyla beraber bir gerçek fonksiyon ayný
scopeda bulunursa bu fonksiyona bir çaðrý yapýlýrsa ve çaðrýda kullanýlan argümanýn türü ile gerçek fonksiyonun parametresinin türü farklýysa 
derleyici þablondan iþlev yazar. Ancak tam da gerçek fonksiyon parametresi ile ayný türden bir argüman ile çaðrý yapýlýrsa bu durumda derleyici
bir fonksiyon yazmaz ve gerçek fonksiyona çaðrý yapýlmýþ olur. Burada da yapýlan hile template iþlevin delete edilmesi ile yalnýzca tanýmlanmýþ
gerçek fonksiyona yapýlan çaðrýlar geçerli olmuþ olur.

Sýnýfýn özel fonksiyonlarý da delete edilebilir. Kopyalanamayan sýnýf nesneleri olsun isteniyorsa, copy constructor private yapýlmaktansa
delete edilir. Delete edilmesi durumunda sadece client kodlarýn kopyalamasý deðil, sýnýfýn kendi kodlarý içerisinde de copy constructor'ýn
çaðrýlmasý sentaks hatasý olur. 
/////////////////////////////////////////////////////////////////////
class NotCopy{
	NotCopy(const NotCopy &r) = delete;
public:
	NotCopy();
	void func(NotCopy &r){
		NotCopy a;
		NotCopy b(a); //gecersiz, delete iþlevin çaðrýlmasý geçersiz
		}
};
/////////////////////////////////////////////////////////////////////

Bir sýnýf için destructor yazýlmasý gereken durumlar varsa, çoðu zaman o sýnýf için copy constructor da yazýlýr. Çünkü destructor yazýlmýþsa bir
takým kaynaklar elde edilmiþ ve geri veriliyor demek yani bu bir rai sýnýfý. Copy ctor yazýlmazsa kaynaklar paylaþýlýr. Kaynaklarýn paylaþýlmasýný
engellemek için de copy ctor da yazýlmalý.


ATAMA OPERATOR FONKSÝYONU

/////////////////////////////////////////////////////////////////////
class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp { new char[mlen + 1]} {
		strcpy(mp, pa);	
	}
	Address(const Address &r) : mlen{r.mlen}, mp{new char[mlen + 1]}
	{
		strcpy(mp, r.mp);
	}
	~Address(){
		delete[]mp;
	}
	void print()const{
		std::cout << "Adres = " << mp << endl;
 	}
	size_t getlen()const{
		return mlen;
	}
};
void func(Address a)
{
	std::cout << "func cagrildi\n";
	a.print();
	std::cout << "func sona erdi\n";
	getchar();
}
int main()
{
	Address a1{ "Necati Ergin Astoria Plaza Kat 27 Esentepe" };
	a1.print();

	if (a1.getlen() > 10) {
		Address a2{ "Mustafa Yilmaz Buyukdere Caddesi Cikmaz Sokak" };
		a2.print();
		a2 = a1;
		a2.print();
		getchar();
	}
	a1.print();
}
/////////////////////////////////////////////////////////////////////
main içindeki if bloðunda Address türünden bir a2 nesnesi hayata gelir ve blok içinde a2 nesnesine a1 nesnesi atanýr, eðer kod doðru çalýþýyor
olsaydý, if bloðu bittikten sonra, a1.print(); ifadesi ile a1 nesnesinin print fonksiyonu çalýþýyor olurdu. Ancak akýþ tam da buraya geldiðinde
Run Time Error meydana gelir.

Nasýl ki bir sýnýf nesnesi hayata deðerini baþka nesneden alarak geldiðinde sýnýfýn özel bir fonksiyonu olan copy constructor çaðrýlýyor ise
C++'da ayný türden nesneler birbirine atandýðýnda, assignment yapýldýðýnda yine bir fonksiyon çaðrýlýr. Sýnýf nesnelerinin birbirine atanmasý
sýnýfýn özel bir fonksiyonu tarafýndan yapýlýr. Bu atama iþlemini yapan bir fonksiyondur. Örnekte a2 = a1; denildiðinde bu iþi yapan operatör 
atama, operator = fonksiyonudur.(Assignment operator function) 

Bütün operatör fonksiyonlarý gibi atama operatör fonksiyonu da ismi ile çaðrýlabilir. Yani a2 = a1; iþlemi operatör fonksiyonu ile yapmak
yerine;
a2.operator=(a1); þeklinde de yapýlabilirdi.
Zaten a2 = a1; yazýldýðýnda derleyici bunu operatör atama fonksiyonuna yapýlan bir çaðrýya dönüþtürür.
Sýnýfýn atama operatör fonksiyonu sýnýfýn bir diðer özel fonksiyonudur.
Atama operatör fonksiyonu bir nesne hayata getirmez, zaten hayata gelmiþ nesneler ile iþlem yapar.
Sýnýfýn non-statik member function'u. Bir nesne için çaðrýlýr, atama operatörünün sol operandý, sol tarafýndaki nesne *this.
a2'nin adresi this pointeri olarak kullanýlýr. a1 ise fonksiyona argüman olarak gönderilen nesnedir.
Bir sýnýfýn atama operatör fonksiyonu olmak zorunda. Programcý tarafýndan yazýlýrsa bir sýnýf nesnesine ayný türden baþka bir sýnýf nesnesi
atamasý yapýldýðýnda programcýnýn yazdýðý atama operatör fonksiyonu çaðrýlýr. Programcý yazmazsa, derleyicinin oluþturduðu atama operatör
fonksiyonu çaðrýlýr.

Derleyicinin sýnýf için yazdýðý atama operatör fonksiyonu;
non-static
public
inline		fonksiyonudur.

Atama operatör fonksiyonu normal bir member function olduðundan yani constructor olmadýðýndan, constructor'larda olduðu gibi geri dönüþ 
kavramý yok deðil. Atama operatör fonksiyonunun geri dönüþ deðeri vardýr.
Derleyicinin yazdýðý(compiler generated) atama operatör fonksiyonunun geri dönüþ deðeri sýnýf türünden referans.
Geri dönüþ deðeri ise *this. 
a = b; gibi bir ifade ayný zamanda C++'da a'nýn kendisi demek.
/////////////////////////////////////////////////////////////////////
class Myclass{
	T x;	// T, U ve M primitif yada class type türler.
	U y;
	M z;
public:
	Myclass &operator=(const Myclass &r){ //compiler generated operator assignment function
		x = r.x;
		y = r.y;
		z = r.z; 

		return *this;
	}
};
/////////////////////////////////////////////////////////////////////
m1 = m2; m1 ve m2 Myclass türünden nesneler olduðunda böyle bir atama yapýldýðýnda derleyici bu fonksiyonu m1 için çaðýrýr. m2'yi ise 
fonksiyona argüman olarak gönderir. m2'nin deðiþtirilmesi gibi bir amaç olmadýðýndan parametre const Myclass &.
Derleyicinin yazdýðý atama operatör fonksiyonunun kodunda *this'in her bir öðesine atama operatörünün sað tarafýndaki nesnenin ilgili öðesi 
atanýr. Atama operatör fonksiyonunun geri dönüþ deðeri kendisine atama yapýlmýþ nesnenin kendisi.

a2 = a1; dendiðinde derleyicinin yazmýþ olduðu atama operatör fonksiyonu çaðrýldý, ve sýnýfýn öðeleri(mlen ve mp) karþýlýklý olarak birbirlerine 
atandý. Bu durumda pointerlar'da birbirine atanmýþ oldu. a2 = a1; atamasýnda a2'nin mp'si, a1'in mp'sinin deðerini aldý ve yine kaynak paylaþýmý
olmuþ oldu. if bloðundan çýkýldýðýnda a2 destroy olduðu için destructor çaðrýldý ve destructor mp'yi delete etti. Ayný kaynaðý hem a1 hem a2 
kullanýyor olduðu için if bloðu içinde a2 nesnesinin hayatý sonlanýp, kaynaklarý geri verilmiþ olmasýna raðmen a1 nesnesi halen hayatýna devam
etmekte. Ancak a2 nesnesinin kaynaklarý geri verildiðinde a1'in de kaynaklarý geri verilmiþ olduðundan, a1'in kaynaklarýný kullanacak þekilde
yazýlmýþ olan kodlar run time hatasýna sebep olur.
/////////////////////////////////////////////////////////////////////
class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp { new char[mlen + 1]} {
		strcpy(mp, pa);	
	}
	Address(const Address &r) : mlen{r.mlen}, mp{new char[mlen + 1]}
	{
		strcpy(mp, r.mp);
	}
	~Address(){
		delete[]mp;
	}
	void print()const{
		std::cout << "Adres = " << mp << endl;
 	}
	size_t getlen()const{
		return mlen;
	}
};
void func(Address a)
{
	std::cout << "func cagrildi\n";
	a.print();
	std::cout << "func sona erdi\n";
	getchar();
}
int main()
{
	Address a1{ "Necati Ergin Astoria Plaza Kat 27 Esentepe" };
	a1.print();

	if (a1.getlen() > 10) {
		Address a2{ "Mustafa Yilmaz Buyukdere Caddesi Cikmaz Sokak" };
		a2.print();
		a2 = a1;
		a2.print();
		getchar(); //if bloðunda herhangi bir run time error yok
	}
	a1.print(); //akýþ buraya geldiðinde run time error
}
/////////////////////////////////////////////////////////////////////
Copy ctor'da da olduðu gibi a1'in kaynaðý eriþilebilir durumda deðil, çünkü orayý gösteren bir pointer kalmadý.
Bir diðer önemli nokta ise, copy constructor da nesne hayata gelip kaynak ediniyor burada ise nesne zaten hayatta ve kaynaðý var, edinmiþ.
a2 = a1, atamasý yapýlmadan önce bellekte iki farklý kaynak var biri "Necati Ergin ..." yazýsýný tutuyor diðeri de "Mustafa Yilmaz..."
yazýsýný tutuyor. Atama yapýldýðýnda ve pointerlar kopya edildiðinde artýk "Mustafa Yilmaz..." bellek alanýný gösteren bir pointer
kalmadýðýndan bu bellek alanýnýn geri verilmesi de mümkün deðil.

Bu durumda atama operatör fonksiyonu da programcý tarafýndan yazýlýr.
Derleyici atama operatör fonksiyonunun geri dönüþ deðeri üstünde bir kýsýtlama koymaz. Yani geri dönüþ deðeri olmayan bir atama operatör
fonksiyonu yazýlsa dahi dilin sentaksýna göre geçerli.
Çoðu zaman atama operatör fonksiyonu yazýlýrken, geri dönüþ deðeri derleyicinin yazdýðý gibi sýnýf türünden referans olarak alýnýr.
/////////////////////////////////////////////////////////////////////
Address &operator=(const Address &r){
	
	delete[]mp; //kaynak geri verildi
	mlen = r.mlen;
	mp = new char[mlen + 1];
	strcpy(mp, r.mp);

	return *this;
}
/////////////////////////////////////////////////////////////////////
Öncelikle deðeri deðiþeceði için atama iþleminin sol operandý olan nesnenin kendi kaynaðý geri verilecek.
Devamýnda ise copy ctor'dakine benzer bir kod olacak.

Önceden çok popüler bir terim olan Big 3 terimi artýk kullanýmda deðil. Bir sýnýfýn assignment operator function, destructor ve copy 
constructor'ýnýn oluþturduðu gruba büyük 3'lü denilir. Çoðu zaman bu 3'lüden biri yazýlýrsa diðerleri de yazýlýr yani çoðu durumda
bu fonksiyonlar bir arada bulunan fonksiyonlardýr.
Þu an daha çok kullanýlan terim ise Big 5 terimi. Big 3'ye ek olarak, C++11 ile gelen iki özel fonksiyon ile bu terim oluþmuþtur.
C++11 ile gelen bu iki fonksiyon, dilin en büyük semantik farklýlýklarýndandýr.

a1 = a1; //self assignment
C++'da bir çok fonksiyon birden fazla parametreye sahip ve referans, pointer semantiði ile birden fazla nesnenin kendisini alýr. Bu fonksiyonlar
bazý iþlemleri yapabilmek adýna parametreleri birbirine atar. Bazý durumlarda böyle fonksiyonlarýn farklý parametrelerine ayný nesnenin geçilmesi
gerekir. Self assignment(a1 = a1; þeklindeki atama) doðrudan yapýlmaz. Bir fonksiyona bir nesne gönderildðinde fonksiyon o nesneyi self assignment'a
tabi tutabilir. Yazýlan kodun self assignment olmasý durumunda da problemsiz çalýþmasý gerekir. Sýnýf nesneleri bir þekilde self assignment'a tabi
tutulursa herhangi bir run time hatasý olmamalý. 
Örnek olarak yukarýdaki Address sýnýfý için a1 = a1; þeklinde bir atama yapýldýðýnda atama operatör fonksiyonu çaðrýlýr. Atama operatör fonksiyonu
çaðýrýldýðýnda a1'in kaynaklarý delete edilip geri verilir. a1 = a1; ifadesinde ortada tek bir nesne var, *this ile r ayný nesne. Oratadaki nesnenin
kaynaðý geri verildi. mp çöp deðerinde olduðundan run time hatasý. Ortada bir kaynak kullanýmý varsa ve atama operatör fonksiyonunda self assignment'a 
karþý bir önlem alýnmamýþsa run time hatasý oluþur. Bu durumda self assignment kontrolü de yapýlmalý.
Bu kontrol yapýlýrken, eðer atama operatörünün sol tarafýndaki nesne ile sað tarafýndaki nesne ayný ise bu nesnelerin adresleri de aynýdýr bu
durumda bir þey yapýlmasýna gerek yoktur, sadece *this ile return edilir.
/////////////////////////////////////////////////////////////////////
Address &operator=(const Address &r){
	if(this == &r)	// self assignment
		return *this;
		
	delete[]mp; //kaynak geri verildi
	mlen = r.mlen;
	mp = new char[mlen + 1];
	strcpy(mp, r.mp);

	return *this;
}
/////////////////////////////////////////////////////////////////////
Atama operatör fonksiyonunda *this kendi kaynaðýný geri verir, yeni kaynak edinir ve diðerinin kaynaðýndan yeni kaynaða kopyalama yapýlýr yani
aslýnda semantik yapý release resources ve ardýndan deep copy. Ancak atama operatör fonksiyonunun yazýlmasýna iliþkin popüler baþka bir terimde
var bu popüler idioma copy and swap idiomu denir.(ileride iþlenecek)

new operatörlerini kullanarak realloc benzeri bir yapý yani operatör new ile bir char array oluþturup ardýndan bunu büyütmem mümkün deðil, new
operatörlerinin böyle bir büyütme iþlevi yok.

Tüm özel fonksiyonlar ile beraber Address sýnýfý;
/////////////////////////////////////////////////////////////////////
class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp{ new char[mlen + 1] }
	{
		strcpy(mp, pa);
	};
	Address(const Address &r) : mlen{ strlen(r.mp) }, mp{ new char[mlen + 1] }
	{
		strcpy(mp, r.mp);
	}
	Address &operator=(const Address &r)
	{
		if (this == &r)
			return *this;

		delete[]mp;
		mlen = r.mlen;
		mp = new char[mlen + 1];
		strcpy(mp, r.mp);

		return *this;
	}
	~Address()
	{
		delete[] mp;
	}
	void print()
	{
		cout << "Address  = " << mp << endl;
	}
	size_t getlen()
	{
		return mlen;
	}
};
/////////////////////////////////////////////////////////////////////


MOVE SEMANTIC
/////////////////////////////////////////////////////////////////////
class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp { new char[mlen + 1]} {
		std::cout << "parametreli constructor" << std::endl;
		strcpy(mp, pa);	
	}
	Address(const Address &r) : mlen{ r.mlen }, mp{ new char[mlen + 1] }{
		std::cout << "copy ctor" << endl;
		strcpy(mp, r.mp);
	}
	Address &operator=(const Address &r){
		std::cout << "assignment operator function" << std::endl;
		if (this == &r)    //self assignment
			return *this;

		delete[]mp;  //release resources
		mlen = r.mlen;
		mp = new char[mlen + 1];
		strcpy(mp, r.mp);
		return *this;
	}
	~Address(){
		std::cout << "destructor" << std::endl;
		delete[]mp;
	}
	void print()const{
		std::cout << "Adres = " << mp << endl;
	}
	size_t getlen()const{
		return mlen;
	}
};
Address func(Address x){
	//
	return x;
}
int main()
{
	Address a("kadikoy istanbul ");
	Address b = func(a);
}
/////////////////////////////////////////////////////////////////////
return x; ifadesinde x nesnesinin hayatý biter, x nesnesi destruct olur. Main'de ise b, func(a) fonksiyonunun geri dönüþ deðeri ile copy construct 
edilir. copy ctor'un çalýþmasý sýrasýnda bellek alaný bir yerden bir yere kopyalanýr. x'in kaynaðý büyük bir bellek alaný ise fonksiyona yapýlan
her bu þekildeki çaðrýda, bu büyük bellek alaný geri verilir ardýndan copy constructor ile tekrar elde edilir. 
Derleyicinin yaptýðý optimizasyonlara benzer þekilde, derleyici bu tip durumlarda x'in kaynaðýný hiç iade etmese ve hayata gelen nesne hayata veda
edecek nesnenin kaynaklarýný kullanmaya devam etse bu bellek alanýnýn kopyalanmasýna gerek kalmazdý. Bu durumda hayata gelecek olan b nesnesi,
hayata veda edecek olan x nesnesinin kaynaðýný devralýr. Buna taþýma semantiði denir(move semantic).
Move semantic olmasa böyle durumlarda, nesne hayata veda edecek, destructor'ý çaðrýlacak, destructor kaynaklarý geri verecek ve ayný kaynaklar sýfýrdan
kopyalama yolu ile tekrar elde edilecek. 
Move semantic C++11 ile gelen bir özellik.
Move semantic gelmeden önce bu þekildeki büyük bellek alanlarýnýn kopyalanmasý ancak derleyicinin yaptýðý bir takým optimizasyonlar sayesinde elimine
ediliyordu. C++11 ile birlikte böylesi durumlarda taþýma semantiði devreye girer. 
Derleyici dilin kurallarýna göre nerede hayatý bitmekte olan bir nesnenin baþka bir nesneye kopyalandýðýný ya da atandýðýný görürse sýnýfýn eskiden
olmnayan özel bir takým fonksiyonlarýna çaðrý yapar ve bu fonksiyonlar kaynaðý geri verip yeni kaynak elde etmek yerine sadece handle'larý kopyalarlar.
Bu fonksiyonlara move constructor denir, taþýyan kurucu iþlev. Atama yolu ile kopyalama yapýlýyor ise de move assignment operator function denir.

Eðer bir taþýma olacaksa bunun compile time'da derleyici tarafýndan anlaþýlýp, taþýmayý yapacak kodun çalýþtýrýlmasý ama taþýma mümkün deðilse kopyalama
kodunun çalýþtýrýlmasý gerekir, dilin daha önceki kurallarý bunu anlamaya müsait deðildi. Dilin core sentax'ýnda yapýlan deðiþikliklerle dile yeni bir
referans modeli daha eklendi: r-value referanslar. Dilin sentaksýna r-value referans modelinin eklenme sebeplerinden biri de derleyicinin kopyalama 
yapýlacaksa kopyalama kodunun, taþýma yapýlacaksa taþýma kodunun çalýþtýrýlmasýnda seçim yapmasýný saðlamasý. Taþýma semantiðini implemente etmek için
sað taraf referanslarý modeli dile eklenmiþtir. Sað taraf referanslarýnýn dile eklenme nedenlerinden ilki move semantic ikincisi ise perfect forwarding.

Sað taraf referansý da olsa, sol taraf referansý da olsa, referans bir nesnenin yerine geçen eþ isim.
Sol taraf referansý l-value expression olan bir nesnenin yerine geçer. Sað taraf referansý r-value olan bir nesnenin yerine geçer.
Sol taraf referansýna, sað taraf deðeri ile ilk deðer vermek sentaks hatasý. Sað taraf referansýna da sol taraf deðeri ile ilk deðer vermek sentaks hatasý.

T x;
t &r = x; //sol taraf referansý

t &&r = exp; //sað taraf referansý

Bir fonksiyon, T bir type olmak üzere T türüne geri dönüyorsa o fonksiyona yapýlan çaðrýnýn oluþturduðu ifade r-value expressiondur.
Ama referans döndürüyorsa l-value expression'dýr
Myclass func(); yapýlan çaðrýnýn oluþturduðu ifade r-value expression
Myclass &func(); yapýlan çaðrýnýn oluþturduðu ifade l-value expression
/////////////////////////////////////////////////////////////////////
class Myclass {

};

Myclass func(); // T türüne geri dönen fonksiyona yapýlan çaðrýnýn türü r-value
Myclass &foo(); // T & geri dönen fonksiyona yapýlan çaðrýnýn türü ise l-value

int main()
{
	Myclass m;
	Myclass &r = m; // geçerli l value referansa bir l value ile ilk deðer verilir
	Myclass &&r = m; // geçersiz, r; r-value referans ancak m; l value 

	Myclass &&r = func(); //geçerli, r-value referansa, r-value ile ilk deðer verilir.
	Myclass &&r = foo(); //geçersiz, r-value referansa, l-value ile ilk deðer verilemez	
}
/////////////////////////////////////////////////////////////////////

Ayný scope'da iki tane ayný isimli fonksiyon varsa ve birinin parametresi l-value referans, diðerinin parametresi r-value referans ise;  fonksiyona l-value ifadesi
ile çaðrý yapýldýðýnda parametresi l-value referans olan fonksiyon, r-value ifadesi ile çaðrýldýðýnda ise parametresi r-value referans olan fonksiyon çaðrýlýr. r-value
referanslarýn eklenmesi ile function overloading mekanizmasýnda da yeni kurallar dile eklenmiþtir.
/////////////////////////////////////////////////////////////////////
class Myclass {

};
void func(Myclass &r)
{
	cout << "L value Ref\n";
}
void func(Myclass &&r)
{
	cout << "R value Ref\n";
}
Myclass foo(); // yapýlan çaðrý ifadesi r-value
Myclass &g(); // yapýlan çaðrý ifadesi l-value
int main()
{
	Myclass m;
	
	func(m); // L value ref parametreli olan çaðýrýlýr.
	func(Myclass()); // R value ref parametreli olan çaðýrýlýr.
	func(foo()); // R value ref olan çaðýrýlýr, foo fonksiyonuna yapýlan çaðrý r-value, gönderilen argüman r- value expression
	func(g()); // L value ref çaðýrýlýr, func fonksiyonuna yapýlan çaðrý l-value
}
/////////////////////////////////////////////////////////////////////

const l-value parametreli fonksiyonlara, r-value expression ile çaðrý yapýlmasý geçerli.
r-value parametreli fonksiyonlara, r-value expressin ile çaðrý yapýlmasý zaten geçerli.
const l-value referans parametreli fonksiyon ile r-value parametreli iki fonksiyonun overload edilmesi durumu ise geçerli, ambiguity oluþmaz. Ancak sað taraf referansý
parametreli fonksiyonun, const sol taraf referansý parametreli fonksiyona üstünlüðü vardýr tabi fonksiyon r-value expressin ile çaðrýlýrsa.
/////////////////////////////////////////////////////////////////////
class Myclass {

};
void func(const Myclass &r)
{
	cout << "const L value Ref\n";
}
void func(Myclass &&r)
{
	cout << "R value Ref\n";
}
int main()
{
	func(Myclass()); // her iki fonksiyonun çaðýrýlmasý da geçerli, ancak r-value ref olanýn diðerine seçiciliði var

}
/////////////////////////////////////////////////////////////////////

 const l-value ref ile r-value ref bir arada bulunabiliyorsa ve aralarýndaki funciton overloading kurallarý dilin kurallarý tarafýndan belirlenmiþse
 ayný þey sýnýfýn üye fonksiyonlarý için de geçerli olur.
 /////////////////////////////////////////////////////////////////////
 class Myclass{
 public:
	Myclass(const Myclass &r); //const l-value ref, copy constructor
	Myclass(Myclass &&r);	   //r-value ref, move constructor
 };
 /////////////////////////////////////////////////////////////////////

 Bu iki fonksiyonun bir arada bulunmasý sentaks hatasý deðil. Yine bu durumda r-value expression ile çaðrý yapýlýrsa move constructor, l-value expression ile
 çaðrýlýrsa ise copy constructor çaðrýlýr. Üstteki fonksiyon kopyalama, alttaki fonksiyon ise taþýma yapacak. Derleyici r-value expression ile bir nesnenin hayata
 getirildiðini gördüðünde dilin kurallarýna göre move constructor'ý çaðýracak, nesne l-value expression ile hayata gelecekse copy constructor çaðrýlýr.
 r-value expression ise ortadaki nesnenin hayata veda etmesi söz konusu. Hayatý sona erecek bir nesneden aktarým yapýldýðýnda move constructor, hayatý devam edecek
 bir nesneden aktarým yapýldýðýnda copy contsructor çalýþýr.
 Move constructor'ýn çaðrýlmasý gereken bir durum varsa ve move ctor yoksa, o zaman her durumda onun yerine copy ctor çaðrýlýr.

 Ayný durum atama operatör fonksiyonu için de geçerli.
 Aþaðýdaki durum da geçerli, function overloading, ayný function overloading resoulution kurallarý geçerli.
 Atama operatörünün sað tarafýndaki ifade r-value expression ise alttaki, l-value expression ise üstteki atama operatör fonksiyonu çaðrýlýr.
 2011 ile üsttekine copy assginment operator function, alttakine ise move assignment operator function denir.
 /////////////////////////////////////////////////////////////////////
 class Myclass{
 public:
	Myclass &operator=(const Myclass &r); // copy assignment, atama operatör fonksiyonunun sað tarafindaki ifade l-value expression ise çaðýrýlýr.
	Myclass &operator=(Myclass &&r);	  // move assignment , atama operatör fonksiyonunun sað tarafindaki ifade r-value expression ise çaðýrýlýr.  
 };
 /////////////////////////////////////////////////////////////////////

 Zaten kaynak kullanan bir sýnýf söz konusu deðilse move'a gerek yok. Move construcor'ýn çaðýrýlmasý gereken bir durum varsa ve move ctor yoksa her
 zaman onun yerine copy ctor çaðýrýlýr.
 /////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{
		cout << this << " adresindeki nesne icin kaynaklar edinildi\n";
	}
	Myclass(const Myclass &r)
	{
		cout << this << " adresindeki nesne icin kaynak edinildi\n" << &r << " adresindeki nesnenin kaynaklari kopyalandi\n";
	}
	Myclass(Myclass &&r)
	{
		cout << this << " adresindeki nesne icin\n" << &r << " adresindeki nesnenin kaynaklari calindi\n";
	}
	~Myclass()
	{
		cout << this << " adresindeki nesne icin kaynaklar geri verildi\n";
	}
};
void func(Myclass x){ }
Myclass foo(Myclass x)
{
	return x;
}
int main()
{
	Myclass m;

	func(foo(m));
}
/////////////////////////////////////////////////////////////////////
foo(m), ifadesi foo fonksiyonunun geri dönüþ deðeri türü Myclass olduðundan, fonksiyona yapýlan çaðrý ifadesi r-value'dur. 
Bu durumda func fonksiyonuna bir r-value ifadesi ile çaðrý yapýlmýþ olur. Derleyici bu durumda fonksiyon bir r-value ile çaðýrýldýðýndan
move constructor'u çaðýrýr. func fonksiyonuna parametre deðiþkeni olan x'e fonksiyona argüman olarak gönderilen r-value ifadeden taþýma 
gerçekleþir. Fonksiyona bir l-value ifadesi ile çaðrý yapýlmýþ olsaydý, derleyici copy constructor'ý çaðýrýrdý.


 Address sýnýfý için move constructor:
 r, hayatý birazdan bitecek nesneyi temsil eden, onun yerine geçen bir isim. Hayatý bitecek nesnenin handle'ý null pointer'a çekildi.
 r nesnesinin kaynaklarý çalýnmýþ oldu, r nesnesinin kaynaklarýnýn adresini tutan göstericinin deðeri, kendisine r nesnesinden taþýma yapýlacak
 olan nesnenin göstericisine atandý. 
 /////////////////////////////////////////////////////////////////////
 Address(Address &&r) : mlen{r.mlen}, mp{r.mp}
 {
	r.mp = nullptr;
 }  
 
 Bu durumda destructor'ýn da kodunda küçük bir deðiþiklik yapýlýr:
 ~Address(){
	if(mp)
	delete[]mp;
 }
 /////////////////////////////////////////////////////////////////////
 Eðer mp'nin deðeri null pointer deðilse kaynak geri verilecek. mp'nin deðeri zaten null pointer'sa kaynaklarý çalýnmýþ olduðundan geri verme iþlemi yapýlmaz.
 Bu durumda kaynaðý çalýnmýþ nesnenin kaynaklarý geri verilmemiþ olur. Kaynaðý çalýnsa dahi nesne için yine de destructor çaðýrýlýr, destructor için bu 
 düzenleme yapýlmadýðýnda bu durumda kaynaðý çalýnan nesne için yine destructor çaðýrýldýðýnda onun kaynaðýný geri vermeye çalýþýr, desctructor'a onun
 kaynaðýnýn çalýnmýþ olduðunu gösteren bir iþaret verilir. Bu düzenleme yapýlmazsa kaynaðý çalýnan nesne için destructor çaðýrýldýðýnda, kaynaðýný geri
 vermeye çalýþýr.

 Taþýyan atama operatör fonksiyonu:
/////////////////////////////////////////////////////////////////////
 Address &operator=(Address &&r){ //move assignment operator function
 
	if(this == &r)	//self assignment
		return *this;
 
	delete[]mp;
	mp = r.mp;
	r.mp = nullptr;
 }
/////////////////////////////////////////////////////////////////////

 Address Sýnýfý:
 /////////////////////////////////////////////////////////////////////
 class Address {
	size_t mlen;
	char *mp;
public:
	Address(const char *pa) : mlen{ strlen(pa) }, mp{ new char[mlen + 1] }
	{
		std::cout << "parametreli constructor" << std::endl;
		strcpy(mp, pa);
	}
	Address(const Address &r) : mlen{ r.mlen }, mp{ new char[mlen + 1] }
	{
		std::cout << "copy ctor" << endl;
		strcpy(mp, r.mp);
	}
	Address(Address &&r) : mlen{r.mlen}, mp{r.mp}  //Move ctor
	{
		r.mp = nullptr;
	}
	Address &operator=(Address &&r) //move assignment op.
	{
		std::cout << "move assignment operator function" << std::endl;

		if (this == &r)    //self assignment
			return *this;

		delete[]mp;
		mp = r.mp;
		r.mp = nullptr;
	}
	Address &operator=(const Address &r)
	{
		std::cout << "assignment operator function" << std::endl;

		if (this == &r)    //self assignment
			return *this;

		delete[]mp;  //release resources
		mlen = r.mlen;
		mp = new char[mlen + 1];
		strcpy(mp, r.mp);

		return *this;
	}
	~Address()
	{
		std::cout << "destructor" << std::endl;
		if (mp)
			delete[]mp;
	}
	{
		std::cout << "Adres = " << mp << endl;
	}
	size_t getlen()const
	{
		return mlen;
	}
/////////////////////////////////////////////////////////////////////
};

C++11 ile, standart kütüphanelerinin kaynak kullanan bütün sýnýflarýn move constructor'ý da var, move assignment' ý da var. Böylece hayatý bitmekte olan bir nesne
baþka bir nesneye ilk deðer vermekte ya da atama yapmakta kullanýlýrsa akýllý bir þekilde derleyici durumdan vazife çýkartýp sað taraf parametreli fonksiyonlarý
çaðýrýr.
Bu yeni gelen semantik yapý, client kodu yazan programcýyý kod çok da ilgilendirmiyor. Zaten derleyici her þeyi doðru þekilde yapýyor. l-value ile çaðrýldýðýnda kopyalama
r-value ile çaðrý yapýldýðýnda taþýma yapýlýyor. 
Eðer kopyalama maliyeti taþýma yoluyla azaltýlabilecek bir sýnýfsa, sýnýf için move constructor yazýlmalý. Derleyici sýnýf için move ctor'u yazsa taþýmanýn nasýl yapýlacaðýný
bilmesinin imkaný yok, derleyici belirli koþullarda move ctor'u yazar ancak bunlar özel durum. 

26_11_2017 PAZAR

/////////////////////////////////////////////////////////////////////
class Myclass{ 
	Myclass() = default;
	Myclass(const Myclass &r); //copy ctor
	Myclass(Myclass &&r);	   //move ctor
	Myclass &operator=(const Myclarr &r);  //copy assignment
	Myclass &operator=(Myclass &&r);	   //move assignment
};
Myclass func();
int main(){
	Myclass m = func();  //move constructor çaðrýlýr
	Myclass m2 = m1;	 //copy constructor çaðrýlýr, m1 bir l-value
	Myclass m3;

	m3 = m2;		//copy assignment çaðrýlýr(l-value expression)
	m3 = func();	//move assignment çaðrýlýr(r-value expression)
}
/////////////////////////////////////////////////////////////////////
Derleyici compile time'da 
Myclass m = func(); gördükten sonra
func fonksiyonunun geri dönüþ deðeri türünün Myclass sýnýfý türünden olduðunu görür. Dilin kurallarýna göre func() çaðrýsýnýn r-value expression olduðu anlaþýldý
function overload resoluton kurallarýna göre m'nin hayata gelmesi için copy constructor'ý deðil, move constructor'ý çaðýrdý.

Kimi durumlarda programcý, derleyiciye zorla move constructor'ý çalýþtýrabilir. 
Myclass m1;
Myclass m2 = m1;
gibi bir kodda derleyici m2'yi copy ctor ile hayata getirecektir. Ancak programcý programýn devamýnda m1'i hiç bir þekilde  kullanmayacaksa bu gibi bir durumda
copy ctor yerine move constructor ile m2'nin hayata getirilmesi saðlanabilir. Örnek olarak primitif türler için yazýlan bir swap kodu ile iki sýnýf nesnesi takas edilirse
onlarca kaynak tekrar tekrar her çaðrýþta kopyalama yolu ile elde edilir. Ancak kaynaklarý elde etme iþi birinin diðerinin kaynaðýný çalmasý üzerine yapýlýrsa swap 
iþleminin maliyeti düþmüþ olur.
Dilin kurallarýna göre bir tür dönüþtürme iþlemi ile l-value expression'dan r-value expression'a cast yapýlabilir. Bunun için standart bir fonksiyon oluþturulmuþ. Fonksiyona
bir l-value expression gönderildiði zaman fonksiyonun geri dönüþ deðeri yine ayný nesne ancak tür olarak r-value expression.
Fonksiyonun ismi move.
Myclass m1;
Myclass m2 = move(m1); //move(m1) fonksiyonunun geri dönüþ deðerinin türü r-value expression olduðundan derleyici move constructor'ý çaðýrýr.
Böylece bir nesnenin kopyalanarak hayata gelmesi yerine kaynaklarý çalarak hayata gelmesi isteniyorsa nesneyi kullanmak yerine o nesne move fonksiyonuna argüman olarak gönderilir
ve move fonksiyonunun geri dönüþ deðeri kullanýlýr.
Taþýyan fonksiyon move deðil!!! Taþýma iþlemini yapan move constructor. Move sadece l-value expression, r-value expression'a dönüþümü saðlayan fonksiyon.

/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() = default;
	Myclass(const Myclass &r)
	{
		cout << "copy ctor\n";
	}
	Myclass(Myclass &&r)
	{
		cout << "move ctor\n";
	}
	Myclass &operator=(const Myclass &r);
	Myclass &operator=(Myclass &&r);
};



int main()
{
	Myclass m1;
	Myclass m2 = m1; //copy constructor çaðýrýlýr.
	Myclass m3 = move(m1); // move constructor çaðýrýlýr.
}
/////////////////////////////////////////////////////////////////////

C'de eþ isim vermenin tek yolu typedef ile mümkün.
typedef int Word; //C++'da da geçerli ancak artýk ilk tercih deðil.
Birinci tercih using anahtar sözcüðü ile eþ isim oluþturma.
using Word = int //C++'da eþ isim verme sentaksý 
standart C fonksiyonu olan strcmp fonksiyonunun adresinin türünün; fcmp ismi ile eþ isim yapýlmasý. Strcmp'nin adresi olan türe fcmp ismi verilmesi:
typedef int (*Fcmp)(const char *, const char *); //typedef ile 
using Fcmp = int (*)(const char *, const char *) //using ile
Bu örnek için düþünüldüðünde using ile typedef kullanýmý arasýnda sonuç açýsýndan bir fark yok. Ancak C++11 için using kullanýmý. Bazý eþ isim bildirimleri var ki using ile 
yapýlabiliyor ancak typedef ile yapýlamýyor bu sebepten de using daha kapsayýcý.

ENUMERATORLER

C'deki enum türü ile C++'daki enum türü farklý.
enum Color {White, Yellow, Gray Magenta, Black};
C'de bu türün ismi Color deðil enum Color. C++'da türün ismi hem enum Color hem Color.
C'de enum'un underlying type'ý int olmak zorunda. C derleyicisi geri planda her enum nesnesini int olarak görür. size of(enum T) = sizeof(int).
C++'da enumlar için underlying type ise int olmak zorunda deðil. C++11 öncesi derleyici enumlar için verilen numaralandýrma sabitlerine bakarak underlying type'ý belirlerdi.
int'e sýðýyor ise int kullanýr, int'e sýðmýyorsa kendisi en uygun türü seçiyordu. Enum türünün underlying type'ý farklý türlerden alýnabilirdi.
Enum'ýn int olduðuna güvenilerek yazýlmýþ C kodlarý, C++'da ayný þekilde çalýþmayabilirdi.
C derleyicisi enum'ýn underlying type'ýnýn int olmasýnýn yaný sýra tür dönüþümleri açýsýndan da enum'a int muamelesi yapar.
int türünden ve int türüne olan otomatik tür dönüþüm kurallarý C derleyicileri açýsýndan enum için de geçerli.
C++'da eskiden beri olan kuralý, diðer türlerden enum türüne dönüþüm yok. Enum türünden bir nesneye sadece ya enumatörleri atanýr yada enum türünden baþka bir nesne atanýr.
Diðer türlerden enum'a dönüþüm yok ama enum'dan diðer türlere dönüþüm var.
/////////////////////////////////////////////////////////////////////
enum Color {White, Yellow, Gray, Magenta, Black};
int main(){
	Color c = 1;	//geçersiz, int'den enum'a dönüþüm geçersiz
	int x = White;  //geçerli, enum'dan int'e dönüþüm geçerli, standart conversion
}
/////////////////////////////////////////////////////////////////////

Incomplete type: Öyle bir tür ki, derleyici o ismin tür olduðunu biliyor ancak o tür hakkýnda bütün bilgileri henüz elde etmemiþ. Örnek olarak struct Data diye bir tür var ancak
derleyici henüz declaration'u görmemiþ. Türlerin bu hallerine incomplete type denir. Bu þekilde bir pointer tanýmlanabilir, yani struct Data *ptr C'de error deðil, derleyici struct
Data'nýn tanýmýný görmese dahi geçerli, bir pointer'ýn storage'ýný zaten derleyici biliyor. Yani bazý iþlemler için türün kesinlikle complete olmasý gerekiyor bazý durumlarda ise 
incomplete olsa da bazý iþlemler için yeterli. 
Bir projedeki dosyalar arasýndaki baðýmlýlýk iliþkisini minimize etmek için bir baþlýk dosyasýnýn mümkün olduðu kadar daha az baþlýk dosyasýnýn include etmesi istenir. Örnek olarak
iki baþlýk dosyasýný include ederek bir interface'i oluþturabiliyorken, daha fazla sayýda baþlýk dosyasý include edip yapmanýn dezavantajlarý var. Bunlardan biri compile time 
süresinin uzamasý, ve include edilen dosyalardan birinin deðiþmesi durumunda bu dosyanýn da deðiþmesi veya yeniden compile edilmesi gerekir.
Incomplete declaration ile iþ görülebiliyorsa, incomplete declaration kullanýlýr böylece bir baþlýk dosyasý da include etmek zorunda kalýnmaz.

Enum'ýn underlying type'ýnýn ne olduðunun derleyiciye baðýmlý olmasý eski C++ kodlarýnda enum türlerinin incomplete type alarak kullanýlmasýna çoðu yerde engeldi. 
Çünkü derleyicinin o tür ile ilgili underlying type'ýn ne olacaðýný bilmesi gerekiyor. Özet olarak enum'ýn underlying type'ýnýn derleyiciden derleyiciye deðiþebilmesi incomplete
type olarak kullaným senaryolarýný daraltýr.

C'de de C++'da da enum sabitlerinin enumeratorlerinin scope'larý enum türünün scope'u ile ayný. Yani Color'ýn bilindiði her yerde white, yellow ve diðer isimlerde biliniyor.
Bütün enumeratorler global isim alanýnda hep olmak zorunda, enumerator isimleri global isim alanýný kirletiyor. Ayný isim baþka bir amaç ile kullanýlamaz, bu durum isim çakýþmasýna
neden olabiliyor. Bu çakýþmayada en fazla konu olan ise yine diðer enumeratorler.

/////////////////////////////////////////////////////////////////////
//screen.h
enum ScreenColor{White, Yellow, Gray, Magenta, Black};
//traffic.h
enum TrafficLight{Yellow, Red, Green};
/////////////////////////////////////////////////////////////////////
Client kod her iki baþlýk dosyasýný da include ettiðinde C'de de, C++'da da sentaks hatasý.
Global alanda ayný isim birden fazla varlýða verilmiþ durumda.
Scope problemi ile baþ etmek için yapýlanlardan biri isimler mümkün olduðu kadar özelleþtirilebilir.

Bir diðer yöntem ise global scope'dan ayrý olarak class scope kullanmak. 
/////////////////////////////////////////////////////////////////////
class Screen {
public:
	enum ScreenColor{White, Yellow, Gray, Magenta, Black};
	//////
}
class Traffic {
public:	
	enum TrafficLight{Yellow, Red, Green};
	//////
}
int main()
{
	Screen s = Screen::White; 

}
/////////////////////////////////////////////////////////////////////

Modern C++'da ise bu durumlarý ortadan kaldýrmak adýna yeni bir araç olan enum class(scoped enum) eklenmiþtir.(C++11)
C++'da iki farklý enum var, biri eski C++'da var olan enum(traditional enum, conventional enum, unscoped enum).
Enum class'ýn asýl amacý scope kazandýrmak ancak enum ile ilgili diðer problemleri de kapsýyor.

enum sözcüðünü deðil, enum'dan sonra class sözcüðü kullanýlýrsa bu artýk ayrý bir yapý: enum class
/////////////////////////////////////////////////////////////////////
	enum ScreenColor{White, Yellow, Gray, Magenta, Black}; //eski enum türü
	enum class ScreenColor{White, Yellow, Gray, Magenta, Black}; //enum class
/////////////////////////////////////////////////////////////////////

enum class olduðunda deðiþenlerden biri scope, artýk enumeratorlarýn týpký class scope gibi ayrý scope'larý var.
Böylece isim çakýçmasý engellenir, scopelandýrýlmýþ olmasý client kodun enumeratorleri kullanma sentaksýný da deðiþtirir.
/////////////////////////////////////////////////////////////////////
enum class ScreenColor{White, Yellow, Gray, Magenta, Black};
enum class TrafficLight{Yellow, Red, Green};
int main()
{
	ScreenColor color = Yellow; //sentaks hatasý, Yelow ismi enum class scope'unda aranmaz
	ScreenColor color = ScreenColor::Yellow; //geçerli
	TrafficColor tcolor = TrafficColor::Yellow;//geçerli
	TrafficColor tcolor = ScreenColor::Yellow;//geçersiz, baþka türden atama yine yapýlmaz

}
/////////////////////////////////////////////////////////////////////

Eski C++ olsaydý Status::Hold, error olurdu çünkü scope deðil, þimdiyse scope olmamasýna raðmen bazý yerlerde kod yazmayý kolaylaþtýrmak adýna
bunlarýnda yine çözünürlük operatörü ile kullanýmýna izin verilmiþtir(C++11)
Bu sadece sentetik bir farklýlýk, Hold demek ile Status::Hold demek arasýnda bir fark yok.
/////////////////////////////////////////////////////////////////////
enum class ScreenColor{White, Yellow, Gray, Magenta, Black};
enum class TrafficLight{Yellow, Red, Green};

enum Status {Off, On, Hold, StandBy};
int main()
{
	ScreenColor color = ScreenColor::Yellow; 
	TrafficColor tcolor = TrafficColor::Yellow;
	Status s = Status::Hold;
}
/////////////////////////////////////////////////////////////////////

Ýkinci farklýlýk ise, enum class'lar söz konusu olduðunda sadece diðer aritmetik türlerden enum türüne deðil, enum türünden diðer türlere olan dönüþümler de geçersiz.
Otomatik tür dönüþümü yok. Bilerek yapýlmak istenirse tür dönüþtürme operatörü kullanýlýr.
/////////////////////////////////////////////////////////////////////
enum class ScreenColor{White, Yellow, Gray, Magenta, Black};
enum class TrafficLight{Yellow, Red, Green};
int main()
{
	int c;
	//////
	c = White;				//geçersiz, zaten White ismi aranýr bulunamaz
	c = ScreenColor::White; //geçersiz, tür dönüþümü de yok.
}
/////////////////////////////////////////////////////////////////////

Enum türlerine artýk underlying type'ýn ne olmasý gerektiði programcý tarafýndan derleyiciye dikte ettirilebilir. Derleyiciye býrakmak gibi bir durum artýk söz konusu deðil.
Ya programcý kendisi istediði underlying type'ý deklare eder, eðer etmezse de zaten default olan underlying type kullanýlýr.
Underlying type'ý belirtmek sadece enum class'lar için deðil, conventional enumlara da özellik olarak eklendi(C++11)
/////////////////////////////////////////////////////////////////////
enum Color : unsigned int {Black, Blue, Purple}; //geçerli, conventional enum
enum class Color : unsigned int { Black, Blue, Purple};//geçerli, enum class
/////////////////////////////////////////////////////////////////////
Artýk derleyici underlying type olarak unsigned int olarak almalý.


Asýl önemli faydasý ise artýk forward declaration da mümkün. 
Artýk bir enum türünün, underlying type bildirimi ile önbildirimi yazýlabilir.
/////////////////////////////////////////////////////////////////////
enum Color : int; //forward declaration, underlying type'ýn int olmasý gerektiði anlatýlýr
/////////////////////////////////////////////////////////////////////

Sýnýfýn özel fonksiyon sayýsý önceden adlandýrýlan Big 3'ye eklenen move constructor ve move assignment operator özel fonksiyonlarý ile birlikte 5' yükselmiþ oldu.
 
C'de r value expression var, l value expression var. Ancak l-value expressionlar modifiable ve non-modifiable olabilir. L-value expressionlar deðiþtirilebilir yada deðiþtirilemez 
olabilir. Örnek olarak int a[100] = { 0 }; dilin kurallýna göre dizi ismi l-value expression'dur, bellekte yeri var. Ancak dizi ismine atama yapýldýðýnda deðil, dizi ismini sizeof 
operatörünün dýþýndaki bir opeatörün operandý yapýldýðýnda derleyici dizi ismini, dizinin ilk öðesinin adresine dönüþtürür, array-to-pointer conversion. Dolayýsýyla dizi isminin
atamada kullanýlamamasý veya dizi isminin atama operatörünün sol operandý olamamasýnýn sebebi dizi isminin l-value expression olmamasý deðil atama yapýlamamasý.
Bu nedenden dolayý dilin kurallarý modifiable l-value, non-modifiable l-value kavramlarý ortaya çýktý. 
L-value olmasýna raðmen deðiþtirilemeyen expressionlara non-modifiable l-value dendi.
int x = 10; //x modifiable l-value
const int x = 10 //x yine l-value ama modifiable deðil
C'de bir ifade l-value mi deðil mi bakmak için atama operatörünün sol operandý yapýlýr ve legal olursa l-value, illegal olursa r-value expression denmiþti. Bu durumda ifadenin r-value mu
l-value mý olduðunu bu þekilde anlamak her zaman kesin sonuç vermez. 
Daha doðru þekilde anlamanýn yolu: adres operatörünün operandý yapmak. Ýfade adres operatörünün operandý yapýldýðýnda legal ise l-value expression, illegal ise r-value expression.
++x; //önek ++ operatörü C++'da l-value expression, C'de r-value expression
x,y; //virgül operatörünün operandlarý nesneyse C++'da l-value expressiondur. C'de r-value expression.
Koþul operatörü C'de r-value expression ancak C++'da l-value expression.
int x = 10, y = 56;
&(1 ? x : y) //C'de r-value expression, C++'da l-vale expression

if(x>10)
	a = y;
else
	b = y;
þeklindeki C kodu C++'da:
(x > 10 ? a : b) = y; þeklinde yazýlabilir. 
Koþul ifadesi ile oluþturulan ifade C'de l-value olmadýðý için benzer yapý þu þekilde kurulur:
*(x > 10 ? &a : &b) = y;

CONVERSION CONSTRUCTOR(DÖNÜÞTÜREN KURUCU ÝÞLEV)

/////////////////////////////////////////////////////////////////////
struct Data {
	int x, y, z;
};
int main(){
	struct Data mydata;
	mydata = 10; //geçersiz
}
/////////////////////////////////////////////////////////////////////
C'de geçersiz kod. Atama operatörünün sað tarafý int, sol tarafý struct data. int türünden struct data türüne otomatik tür dönüþümü yok.
Tür dönüþtürme operatörünün de böyle bir kullanýmý yok, C'de bu ifadeyi legal kýlmanýn bir yolu yok.

/////////////////////////////////////////////////////////////////////
class Myclass{
	int mx;
public:
	Myclass(int val) : mx{val}{}
	void print()const{
	std::cout << "()" << mx << ")";
	}
	int get()const{
	return mx;
	}
};	    
int main(){
	Myclass m{36};
	m.print();

	m = 12; //error deðil!
}
/////////////////////////////////////////////////////////////////////
Myclass nesnesine int türden bir deðer atandý ancak error deðil. Sýnýflarýn tek parametreli constructorlarýna conversion constructor denir.(dönüþtüren kurucu iþlev)
Myclass sýnýfýndaki constructor ayný zamanda dönüþtüren kurucu iþlevdir. Dilin kurallarýna göre sýnýfýn tek parametreli ctor'larý parametresinin türünden bir deðeri, bu sýnýf  
türüne dönüþtürme amacý ile de kullanýlabilir. Derleyici ne zaman int türden bir deðerin Myclass sýnýfýna dönüþtürülmesi gerektiðini görürse bu fonksiyonu kullanarak bu
dönüþtürme iþlemini gerçekleþtirir. Constructor burada ayný zamanda bir tür dönüþtürme iþlemi yapar.
Derleyici atama operatörünün sol operandýnýn sýnýf türünden olduðunu, sað operandýn ise int türden olduðunu gördü. Bu atamanýn yapýlabilmesi için int'in Myclass 
sýnýfý türüne dönüþtürülmesi gerekir.Derleyici bu ctor'un varlýðýný gördüðünde int'i, Myclass türüne dönüþtürdü. Derleyici bunu yaparken, Myclass sýnýfý türünden 
bir nesne oluþturur, bu nesneyi sýnýfýn tek parametreli constructor'ýný kullanarak hayata getirir ve atama opeatörünün kullanýldýðý yerde m'nin operatör atama fonksiyonunu 
çaðýrýr ona bu geçici nesneyi argüman olarak gönderir.

/////////////////////////////////////////////////////////////////////
/* Derleyicinin m = 12; ifadesi için yazmýþ olduðu kod(pseudo kod)
{Myclass temp{12};
m.operator=(temp);}
*/
/////////////////////////////////////////////////////////////////////

Derleyici bu þekilde bir kod üretir. Buradaki temp nesnesi derleyicinin hayata getirmiþ olduðu bir geçici nesnedir. Geçici nesnelerin ömürleri, kullanýldýklar ifadelerin
evaluate edilmesinden sonra, bu geçici nesnelerin hayatýnýn bitmesi þeklindedir. Geçici nesne m = 12; ifadesinde oluþturulduðundan, bu ifadeden sonraki noktada artýk
ortada derleyicinin oluþturduðu geçici nesne yok.
Oluþturulan temp bir r-value expression, bu þunu deðiþtirir; eðer ki ortada taþýma semantiði varsa, taþýma versiyonu devreye girer çünkü r-value expression.

/////////////////////////////////////////////////////////////////////
class Myclass{
	int mx;
public:
	Myclass(int val) : mx{val}
	{
		std::cout << "Myclass(int)\n"; 
	}
	void print()const
	{
		std::cout << "(" << mx << ")\n";
	}
	Myclass &operator=(const Myclass &r)
	{
		std::cout << "Myclass::operator=(const Myclass &)" << std::endl;
		mx = r.mx;
		return *this;
	}
	int get()const
	{
		return mx;
	}
	~Myclass()
	{
		std::cout << "~Myclass()\n";
	}
};
int main(){
	Myclass m{36};
	m.print();

	m = 12; 
	getchar();
	cout << "main devam ediyor" << std::endl;
}
/////////////////////////////////////////////////////////////////////
Öncelikle Myclass m{36}; ifadesinde tek parametreli constructor çaðýrýldý. Ardýndan m.printf() ifadesi ile ekrana 36 deðeri yazdýrýlmýþ oldu. Ardýndan derleyicinin yaratmýþ olduðu geçici nesne 
için de tek parametreli constructor çaðýrýlýr(bu nesne kodda görünmüyor ancak run time'da yaratýldý). Bu constructor'un da çaðýrýlmasýndan sonra atama operatör fonksiyonu çaðýrýlýr(derleyicinin
m = 12 ifadesi için yazmýþ olduðu kod sebebiyle). Son olarak iki tane destructor çaðýrýlýr, bunlardan biri m nesnesi için diðeri ise derleyicinin oluþturmuþ olduðu geçici nesne için.
Derleyicinin yarattýðý geçici nesnenin destructor'ý, getchar() fonksiyonu çaðýrýlmadan çaðýrýlýr. Geçici nesnelere iliþkin kural; geçici nesnenin içerisinde bulunduðu ifade evaluate edildikten
sonra onlarýn hayatý bitiyor. m = 12; ifadesinin hemen ardýndan bu geçici nesnenin hayatýnýn sonra ermiþ olmasý dil tarafýndan garanti altýnda.

Peki bu durum, yani derleyicinin durumdan vazife çýkartýp böyle bir dönüþüm yapmasý istenen bir özellik mi ? 
m = 12 yazmak yerine m = 1.2 yazýlsa idi, derleyici yine de böyle bir dönüþümü yapar mýydý ? 
Böyle bir özelliðin istenip istenmemesi tamamen bu sýnýf için verilmek istenen interface'e baðlý. Bilerek isteyerek intlerin myclass türüne otomatik olarak dönüþtürülmesi talep edilmiþ olabilir.
Yani sýnýfa bu özellik kazandýrýlmak istenmiþ olabilir veya gerçekten de kodu yazan yanlýþlýkla böyle bir dönüþüme neden olmuþtur.

Bilerek isteyerek böyle bir dönüþümün yapýlmasý temasý;
/////////////////////////////////////////////////////////////////////
int main(){
	string s;

	s = "mustafa";
}
/////////////////////////////////////////////////////////////////////
Atama operatörünün solundaki bir sýnýf nesnesi, saðýndaki ise const char *, 8 elemanlý const bir char dizi. Dilin bir sentaks aracý olmasa bu ifadenin error olmasý gerekir.
Bunu legal kýlmanýn yollarýndan biri conversion constructor kullanmak. String sýnýfýnýn const char * parametreli bir constructoru olduðu düþünülürse, derleyici yine atama 
operatörünün sað tarafýndaki ifadenin const char * türünden olduðunu gördüðünde yine bir geçici nesne oluþturur, bu geçici nesneyi atama operatör fonksiyonuna argüman olarak
geçer, yani bazý yerlerde conversion constructor'ýn olmasý istenen bir konvensiyon.(string sýnýfýnýn gerçekten de const char * parametreli bir ctoru var, bu ctorun olmasý bu
ctoru ayný zamanda bir conversion ctor yapar ve böyle dönüþümler mümkün kýlýnýyor.)

Sadece atama operatöründe deðil, tür dönüþümünün gerektiði durumlarda o dönüþtürme derleyici tarafýndan otomatik olarak yapýlýr. Geri dönüþ deðerinde, fonksiyon çaðrýlarýnda da geçerli.
Örnek olarak:
/////////////////////////////////////////////////////////////////////
void func(string s);
int main(){
	string s = "fethi";
	
	func("mustafa"); //geçerli çaðrý
	func(s);
}
/////////////////////////////////////////////////////////////////////
func fonksiyonuna yapýlan func("mustafa"); çaðrýsýnda da tür dönüþümü gerekir ve conversion constructor çalýþýr.
Conversion constructor'ýn kullanýlmasý ile yapýlan dönüþüm user-defined conversion.
Eðer ki böyle bir mekanizma olmasaydý ve func fonksiyonuna geçilecek string zaten belirli olmuþ olsaydý(örnek olarak "fethi" yazýsý), bu durumda "fethi" yazýsý string türünden bir deðiþkende
tutulup, bu deðiþken func fonksiyonuna geçilirdi. Ancak bu durum farklý nedenlerden dolayý kabul edilebilir bir kod olmazdý, gereksiz yere s isminin scope'u geniþletildi, s'in de bir kaynak
kullanýmý mevcut, bu nesne kullabýlabilir bir nesne olmasýna raðmen main'in sonuna kadar kullanýlma potansiyelinde.
func("mustafa") çaðrýsýnda ise yine bir string nesnesi var ancak bu string nesnesi isimlendirilmiþ deðil, böylece isim oluþturulmasýna gerek kalmadý ve ömrü sadece kullanýldýðý yer ile sýnýrlý.


/////////////////////////////////////////////////////////////////////
class Counter{
	int mx;
public:
	Counter(int val = 0) : mx{val} {}
	void printf()const;
	void get()const;
};
int main(){
	
	Counter c1;
	Counter c2 = 43;

	c1 = 7;
}
/////////////////////////////////////////////////////////////////////
Bir countera bir tamsayý atamak kadar doðal bir durum yok, ancak eðer bu atamayý legalize eden dilin bir kuralý olmasaydý bu atamalar sentaks hatasý olurdu.
Dikkat edilmesi gereken, dilin bunu legal kýlan birden fazla aracý var, bunlardan biri burada kullanýlan conversion constructor. Bir diðeri operatör atama
fonksiyonu. 

Conversion constructor bazen gerekli olabilir, C++'nýn standart kütüphanelerinden bazýlarý tek parametreli constructorlarýný bilerek isteyerek dönüþtürme iþleminde kullanýr.
Anak bu ayný zamanda çok ciddi de bir kodlama hatasýna sebep olabilir çünkü dilin kurallarý conversion ctorun devreye girmesi gereken yeri programcýnýn insiyatifine býrakmaz. 

/////////////////////////////////////////////////////////////////////
void func(char c)
{
}
int main(){
	Counter c1(134), c2(35);
	//////////////

	func(c1);
}
/////////////////////////////////////////////////////////////////////
Programcýnýn func fonksiyonuna yanlýþlýkla c1'i göndermiþ olduðu düþünülsün. Böyle bir durumda dilin kurallarý, counter'ý char'a dönüþtürmeye müsait ise problem oluþur.

Ayný þey conversion ctor için de geçerli
/////////////////////////////////////////////////////////////////////
void func(Counter c)
{
}
int main(){
	Counter c1(134), c2(35);
	char c = 's';
	//////////////

	func(c); //legal
}
/////////////////////////////////////////////////////////////////////
Programcý func fonksiyonuna argüman olarak c1'i gönderecekken yanlýþlýkla char türden olan c'yi göndermiþ olsun, bu durumda kod legal ancak bunun istenerek yapýlmýþ olmasý
çok düþük bir ihtimal. Legal olmasýnýn sebebi, dilin bu yönde kurallarý var; conversion constructor çaðýracak.

Normalde bir türden bir türe dönüþüm yok ancak bir fonksiyon tanýmlanýyor, derleyici bu fonksiyonu kullanarak dönüþümü gerçekleþtiriyorsa böyle dönüþümlere user defined
conversion denir. Conversion constructor'ýn kullanýlmasý ile yapýlan dönüþüm tipik bir user defined conversion. User defined conversion olup conversion constructor ile yapýlmayan
da var. Sýnýf türünden olmayan bir deðerin sýnýf türüne dönüþtürülmesi conversion ctor ile ancak bunun tersi de mümkün yani sýnýf türünden bir deðer var ve int'e dönüþtürülecek.
Bunu yapacak fonksiyonlar da tanýmlanabiliyor, bu fonksiyonlara baþka bir isim veriliyor.(tür dönüþtürme operatör fonksiyonu, type cast operator function). Aslýnda legal olmayan,
programcýnýn yazdýðý kod neticesinde legal hale gelen dönüþümler user defined conversion, bunun içerisinde ise 2 tane temel araç var bunlardan biri conversion constructor diðeri
ise type cast operator function. 

Dilin kurallarýna göre eðer bir conversion þu yol ile mümkünse; önce user defined conversion sonra standart conversion	
veya þu yol ile mümkünse; önce standart conversion sonra user defined conversion		; derleyici bunu otomatik olarak yapmak zorunda.
Ancak derleyici þunu yapmamak zorunda, eðer ki dönüþüm önce user defined conversion sonra bir user defined conversion daha, derleyici hiçbir zaman bu otomatik dönüþümü yapmaz.
Yani derleyici bir user defined conversion'ý dilin kurallarýna göre normal bir conversion izlediðinde bunu yapmak zorunda veya tam tersi normal conversion'ý user defined
conversion izlediðinde yapmak zorunda.
Yukarý func(c) kodu düþünüldüðünde, char'dan Counter'a dönüþüm yapýlmasý gerekiyor ama bu ancak þöyle bir sekansla mümkün ki buna conversion sequence denir, önce char'ý int'e 
dönüþtürecek, int'i de Counter'a. char'ýn int'e dönüþmesi standart conversion, int'in Counter'a dönüþtürülmesi user defined conversion.

Ancak örnek olarak A -----> B, A sýnýfý türünden  B sýnýfý türüne dönüþtüren bir fonksiyon mevcut ve B ----> C, B sýnýfý türünden de C sýnfý türüne dönüþtüren bir fonksiyon
var. cx = ax; gibi bir atama yapýldýðý düþünüldüðünde, bu þu þekilde mümkün: a türünden olan ax b'ye dönüþtürülsün, ikinci fonksiyon kullanýlarak da b türünden c türüne dönüþtürülsün.
Dilin kurallarýna göre bu da pek tabi geçerli olabilirdi ancak bu yasak. Bu dönüþüm ancak user defined conversion üstüne bir user defined conversion daha ile mümkün bu da dilin kurallarýna
göre geçerli deðil.


Bu dönüþümler derleyici tarafýndan otomatik olarak yapýlýr. Böyle bir constructor yazýldýðýnda ancak derleyicinin bu constructor'ý kullanarak otomatik conversion yapmasý istenmiyorsa
explicit anahtar sözcüðü kullanýlmalý. Yazýlan constructor bu amaç için yazýlmamýþ olabilir ve derleyicinin bu constructor'ý otomatik olarak dönüþüm iþlemlerinde kullanmasýnýn engellenmesi 
için "explicit constructor" kullanýlmalý. explicit constructor, explicit anahtar sözcüðü ile bildirilen constructor.
explicit anahtar sözcüðü tanýmda kullanýlmaz, bildirimde kullanýlýr.
Explicit'in anlamý explicit only. Bu fonksiyon tür dönüþümü yapar ancak tür dönüþtürme operatörünün kullanýlmasý gerekir, otomatik dönüþüm yapýlmaz.
Otomatik tür dönüþümü denilen, derleyicinin kendisinin yaptýðý tür dönüþümlerine implicit type conversion denir, tür dönüþtürme operatörü ile yapýlan dönüþümlere ise explicit type
conversion denir. Buradaki anlamý da explicit type conversion only.
/////////////////////////////////////////////////////////////////////
class Counter{
	int mx;
public:
	explicit Counter(int val = 0) : mx{val} {}
};
int main(){
	Counter mycounter{35};
	int ival = 45;
	mycounter = ival; // geçersiz, otomatik tür dönüþtürme yapýlmaz, eðer ctor explicit olmasaydý legal olacaktý
	mycounter = static_cast<Counter>(ival); //geçerli, gerçekten bilerek isteyerek böyle atama yapýlabilir
}

Çok özel bir durum yoksa conversion constructorlar explicit yapýlýr, yoksa bile en azýndan debug süresince böyle tutulup debugdan sonra normal haline alýnabilir.
Her ne kadar önerilmese de C tarzý tür dönüþtürme operatörleri de kullanýlabilir.
Conversion constructor varsa derleyici bunun kodunu otomatik olarak yazmaz, kodu yazan yazar. Conversion ctor bir special member function deðil. Dolayýsýyla sýnýfýn
hangi veri elemanýna ne yapacaðý, kodu yazanýn kendi tasarýmýyla ilgili.	

/////////////////////////////////////////////////////////////////////
class Counter{
	int mx;
public:
	explicit Counter(int val = 0) : mx{val} {} //conversion constructor explicit deðil
};
int main(){
	Counter x(10);
	Counter y{20};

	Counter z = 20; // geçerli olmasý için sýnýfýn conversion constructor'ýnýn explicit olmamasý gerekir
}
/////////////////////////////////////////////////////////////////////
Counter z = 20; ifadesinin teknik karþýlýðý; "derleyici atama operatörünün sað tarafýndaki ifadeyi Counter türüne dönüþtür, yani geçici bir Counter nesnesi oluþtur sonra da 
sýnýfýn copy constructor'ýný çaðýr, z'yi de bu þekilde construct et." Yani derleyici gerçekten tam da bu þekilde yapsaydý þu koda karþýlýk gelirdi;
/*
Counter temp(45);
Counter z(temp);
*/
Her ne kadar dilin kurallarýna göre olan durum buysa da, derleyici bu þekilde kod üretmez, çünkü bu kod hiç optimize deðil.
Bu þekilde  yapýlacaðýna Counter z = 20; ifadesi yerine sanki Counter z(20) þeklinde ele alýnsýn. Böylece bir constructor ve copy ctor yerine tek bir constructor ile iþ
halledilebilsin, gerçekten de tüm derleyiciler ikinci þekilde kod üretir.
Dilin kurallarýna göre Counter z = 20; ifadesinde operatörün sað tarafýnda da bir dönüþüm her ne kadar derleyici burada bir optimizasyon yapsa da .
Bu yüzden eðer conversion constructor explicit ise Counter z = 20; ifadesi sentaks hatasý. 

explicit anahtar sözcüðü, constructorlarýn hepsinde kullanýlabilir ama tek parametreli olmayan ctorlarýn explicit olmasý çok yaygýn deðil.

/////////////////////////////////////////////////////////////////////
int main()
{
	string s = "Poyraz"; // kod geçerli olduðuna göre string sýnýfýnýn const char * parametreli constructor'ý explicit deðil.
}
/////////////////////////////////////////////////////////////////////
explicit mi deðil mi testi için böyle bir ilk deðer verme yapýlýp, test edilebilir.



unique_ptr, en sýk kullanýlan smart pointer sýnýfý, varlýk nedeni exclusive ownership(tek sahiplik ilkesi)
Bir kaynaðýn tek bir sahibi olur, ayný zamanda iki sahibi olamaz, kaynaðýn sahibi olan nesne hayatýna veda ettiðinde kaynak da 
geri verilir.(en basit garbage mekanizmasý gibi düþünülebilir)
unique_ptr sýnýfýnýn da kullanýlma nedeni de dinamik nesnelerin kontrolü. Bir dinamik nesne normal bir pointera baðlama yerine 
bir unique_ptr nesnesine baðlanýrsa onu yönetmek de kullanýlacak unique_ptr nesnesinin hayatý bittiðinde dinamik nesnenin de 
hayatý bitmiþ olur.

/////////////////////////////////////////////////////////////////////
class Myclass{ //bir RAII sýnýfý
public:
	Myclass()
	{
		cout << "Myclass nesnesi hayata geldi, kaynaklar edindi\n";
	}
	~Myclass()
	{
		cout << "Myclass nesnesi hayata veda etti, kaynaklarý geri verildi\n";
	}
};
int main() {

	cout << "main basladi\n";
	if(1){
		Myclass *p = new Myclass;
	}
	cout << "main devam ediyor\n";
}	
/////////////////////////////////////////////////////////////////////
Myclass nesnesi hayata gelir ve kaynaklar edinir ancak kaynaklarý geri verilmemiþ olur çünkü delete edilmedi.
Eðer gerçekten o blok içinde hayata veda etmesi gerekiyorsa, destructor'ýnýn çaðýrýlmasý gerekir. 

/////////////////////////////////////////////////////////////////////
int main() {

	cout << "main basladi\n";
	if(1){
		unique_ptr<Myclass> p(new Myclass);
	}
	cout << "main devam ediyor\n";
}	
/////////////////////////////////////////////////////////////////////
Ayný Myclass sýnýfý için normal pointer yerine, dinamik nesne unique_ptr türünden bir nesneye baðlandý.
unique_ptr interface olarak pointer interface'ini tamamen içeriyor, sýnýfýn üye fonksiyonunu çaðýrmak için -> operatörü
veya * içerik operatörünün operandý olabilir.
Pointer gibi görev yapmasýna raðmen, scope'u bittiðinde kontrol ettiði dinamik nesnenin de hayatýný sonlandýrdý.
Delete edilmesine gerek yok.


/////////////////////////////////////////////////////////////////////
int main() {

	cout << "main basladi\n";
	if(1){
		unique_ptr<Myclass> up(new Myclass);
		unique_ptr<Myclass> up2 = up1; //sentaks hatasý
		unique_ptr<Myclass> up3 = move(up1); //geçerli	

	}
	cout << "main devam ediyor\n";
}	
/////////////////////////////////////////////////////////////////////
unique_ptr sýnýfýnýn özelliklerinden birisi de kopyalamaya tamamen kapalý olmasý çünkü zaten sýnýfýn varlýk nedeni bu.
Bu normal bir pointer olsa ve bu pointerýn deðeri baþka pointerlara kopyalansa, bütün pointerlar ayný nesneyi göstermiþ olurdu.
Bunlardan herhangi biri, kaynaðý delete ettiðindeyse diðerleri boþta kalmýþ olurdu. Bu tehlike de böylece tamamen ortadan
kalkmýþ oldu çünkü zaten bir unique_ptr'yi baþka bir unique_ptr'ye kopyalamak mümkün deðil.
unique_ptr<Myclass> up3 = move(up1); ifadesinin geçerli olma sebebi ise, up1 sað taraf referansýna dönüþtürüldü böylece sýnýfýn
copy deðil move ctor'ý çalýþtýrýldý. move ctor ise mülkiyeti birinden alýp diðerine býrakýyor, artýk mülkiyet up3'e geçti.
Böylece dinamik nesnenin iki tane sahibi olamýyor. Bazý sýnýflar böyle kopyalamaya kapatýlmýþ ancak taþýmaya açýk(ostream sýnýfý
da böyle)
C++11 öncesinde böyle bir pointer sýnýfa çok ihtiyaç olmasýna raðmen bu þekilde kullaným mümkün deðildi çünkü move semantic yoktu.
Bunun yerine ismi auto_ptr olan bir sýnýf kullanýlýyordu ancak move semantic olmadýðý için auto_ptr sýnýfýnýn kullanýmýnda sorunlar
olabiliyordu zaten C++11, move semantic ile, auto_ptr sýnýfý deprecate edildi.


/////////////////////////////////////////////////////////////////////
int main() {

	cout << "main basladi\n";

	unique_ptr<Myclass> up1 = new Myclass; //geçersiz çünkü unique_ptr sýnýfýnýn adres parametreli ctor'ý explicit!

	cout << "main devam ediyor\n";
}	
/////////////////////////////////////////////////////////////////////
unique_ptr sýnýfýnýn adres parametreli constructorý explicit olmasaydý kod legal olurdu. explicit olmasýna raðmen legal olmasý için ya küme 
parantezi sentaksý veya parantez kullanýlmalý.


/////////////////////////////////////////////////////////////////////
int main(){

	ostream ox(cout); //geçersiz
	move(cout); //cout nesnesi sað taraf referansýna dönüþtürülmüþ olur

}
/////////////////////////////////////////////////////////////////////
ox ve cout ayný sýnýf türünden, geçersiz olduðuana göre copy constructor'ý delete edilmiþ.
Eðer bir fonksiyonun parametresi sað taraf referansý ise, fonksiyona move(cout) ifadesi gönderildiðinde legal olacak.


/////////////////////////////////////////////////////////////////////
class Counter{
	int mx;
public:
	Counter(int val = 0) : mx{val} {}
	void printf()const;
	void get()const;
};

void func(Counter c)
{

}
void foo(Counter &c)
{

}
void g(const Counter &r)

int main(){
	
	func(10); //legal, derleyici int türden 10 deðerini Counter türüne dönülþtürür(sýnýfýn coversion ctorunu çaðýrýr)
	foo(20); //geçersiz, fonksiyonun parametresi referans ise burada dönüþüm yapýlmaz
	g(30); //geçerli, parametresi const &
}
/////////////////////////////////////////////////////////////////////
Eðer ki foo(20); geçerli olsaydý aslýnda foo'ya derleyicinin oluþturduðu geçici nesnenin adresi gönderilmiþ olurdu.
Legal olmamasýnýn sebebi, bu konseptteki geçici nesnenin const kabul edilmesi. Derleyicilerin bu amaçla oluþturduðu geçici
nesne const kabul ediliyor, problem const bir nesneyi const olmayan bir referansa baðlamakla ilgili.


/////////////////////////////////////////////////////////////////////
void display(const string &s)
{
	cout << "(" << s << ")" << endl; 
}

int main(){

	/////
	display("suleyman"); //geçerli
}
/////////////////////////////////////////////////////////////////////
yukarýdaki kural olmasaydý, önce string sýnýfý türünden bir nesne oluþturulup sonra ona "süleyman" yazýsý ile ilk deðer verilip
nesne fonksiyona gönderilmeliydi. fonksiyonun parametresi const & olduðundan, dönüþüm yapýlýr.


2_12_2017 CUMARTESÝ

/////////////////////////////////////////////////////////////////////
int main(){
	string s = "mustafa";
}
/////////////////////////////////////////////////////////////////////
Eðer string sýnýfýnýn bu(const char *) parametreli constructor'ý explicit olsaydý yukarýdaki ifade geçersiz olacaktý.
Aslýnda bu ifadede conversion ctor'ý, derleyici zaten kullanmýyor, optimizasyon yapýyor bir kerede s'i oluþturuyor ancak
dilin kurallarýna göre burada sanki bir tür dönüþtürme iþlemi varmýþ gibi constructor'a çaðrý yapýlmasý nedeniyle ctor'un explicit
olmasý durumunda bu sentaks hatasý.
	
/////////////////////////////////////////////////////////////////////
Myclass m1(10);
Myclass m2{12};
Myclass m3 = 30;
/////////////////////////////////////////////////////////////////////
Myclass bir sýnýf olmak üzere, üçüncü ifadenin geçerli olabilmesi için ilgili constructor'ýn explicit olmamasý gerekir.

Bir user defined conversion'ý, baþka bir user defined conversion izleyerek ilgili dönüþüm yapýlabiliyorsa derleyici bunu otomatik 
olarak yapmaz, tür dönüþtürme operatörü kullanýlarak bu dönüþüm yaptýrýlabilir.
Ancak derleyici conversion constructor explicit deðilse; standart conversion + user defined conversion veya user defined conversion
+ standart conversion dönüþümlerini otomatik olarak yapar.


/////////////////////////////////////////////////////////////////////
void func(const Myclass &r);
int main(){	
	func(flag); //flag boolean türden deðiþken
}
/////////////////////////////////////////////////////////////////////
Myclass bir sýnýf olmak üzere, func fonksiyonuna alakasýz bir þekilde boolean türden bir deðiþken geçildiði düþünülsün. Ancak bu bile
geçerli olabilir zira boolean int'e dönüþür, double'a dönüþür. Bu sýnýfýn double parametreli bir conversion ctor'ý bile olsa bu çaðrý
legal olacak, boolean'dan double'a., double'dan da Myclass türüne dönüþüm olmuþ olacak. 

/////////////////////////////////////////////////////////////////////
string h1(const string &s)
{
	return "<h1>" + s + "</h1>";
}
int main(){

	string sname = "Necati Ergin";

	cout << h1(sname) << endl;

	cout << h1(0) << endl;

}
/////////////////////////////////////////////////////////////////////
h1(0) çaðrýsý anlamsýz bir ifade ancak sentaks hatasý deðil. Sentaks hatasý olmamasýnýn sebebi, string sýnýfýnýn int parametreli bir constructorý
yok ama 0'dan null pointera dönüþüm var, string sýnýfýnýn da const char * parametreli bir ctor'ý olduðundan o zaman 0, nullptr'ye dönüþtürülür, bu 
standart conversion. null pointer ise const char *'a gönderilmiþ olur. constructor explicit olsaydý böyle bir hata ihtimali olmazdý.

Constructorlar en azýndan debug süresince explicit yapýlmalý, her zaman daha güvenli.
Önce güvenlik ardýndan client kodu yazan için kolaylýk düþünülmeli.

/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{
		cout << "Myclass::Myclass()" << endl;
	}
	~Myclass()
	{
		cout << "Myclass::~Myclass()" << endl;
	}

};
int main() {

	unique_ptr<Myclass> p{ new Myclass }; //geçerli
	unique_ptr<Myclass> ptr = new Myclass; //geçersiz, unique_ptr sýnýfýnýn ilgili constructor'ý explicit!
}
/////////////////////////////////////////////////////////////////////
 
C++'da geçici nesneler ayrý bir ömür statüsünde. Bir ifade yürütüldüðü sürece hayatta olup ifade ele alýndýktan sonra geçici nesnelerin ömürleri 
sona erer. 
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() = default;
	Myclass(int)
	{ 
		std::cout << "Myclass::Myclass(int)" << std::endl;
	}
	Myclass()
	{ 
		std::cout << "Myclass::~Myclass()" << std::endl;
	}
};
int main(){
	Myclass m;
	cout << "atama oncesi\n";
	m = 12;
	cout << "atama sonrasi\n";
}
/////////////////////////////////////////////////////////////////////
Not: C'de bir fonksiyon tanýmýnda parametre deðiþkenine isim vermemek sentaks hatasý ancak C++'da fonksiyonun sadece bildiriminde deðil tanýmýnda da 
parametreye isim vermemek legal.
m nesnesinin bildirilmesi ile default ctor çaðýrýlýr. m = 12; ifadesinde ise, int parametreli constructor çaðrýlýr, bunun sebebi derleyicinin hayata 
getirmiþ olduðu geçici nesne. 
m = 12; ifadesindeki ; bir sequence point bu noktadan sonra derleyicinin hayata getirmiþ olduðu geçici nesnenin hayatýnýn sonlanacaðý garanti altýnda
bu sebeple "atama sonrasi" yazýsý çýkmadan önce, geçici nesne için destructor çaðýrýlýr.


Bir geçici nesne, derleyicinin oluþturduðu gibi, programý yazan tarafýndan da oluþturulabilir.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass() = default;
	Myclass(int)
	{ 
		std::cout << "Myclass::Myclass(int)" << std::endl;
	}
	Myclass()
	{ 
		std::cout << "Myclass::~Myclass()" << std::endl;
	}
};
int main(){
	Myclass m;
	cout << "ifade oncesi\n";
	Myclass(12); //geçerli bir ifade
	cout << "ifade sonrasi\n";
}
/////////////////////////////////////////////////////////////////////
Derleyici Myclass(12) ifadesi için temporary object üretmek zorunda, yani aslýnda 12 argümaný derleyicinin oluþturuacaðý geçici nesne için çaðýrýlacak
ctor'a argüman olarak gönderilir. Yine "ifade sonrasi" yazýsýndan önce geçici sýnýf nesnesi için destructor çaðýrýlýr.

/////////////////////////////////////////////////////////////////////
string h1(const string &s)
{
	return "<h1>" + s + "</h1>";
}
int main(){
	h1("Poyraz");
	string name{"poyraz"}; 
	h1(name);

	h1(string("Poyraz"));
}
/////////////////////////////////////////////////////////////////////
h1("Poyraz"); ifadesinin legal olabilmesi için sýnýfýn ctorunun explicit olmamasý gerekir.
Eðer ctor explicit olsaydý bu durumda, bu yazý bir deðiþkende tutulup, fonksiyona da argüman olarak bu deðiþken gönderilebilirdi ancak bu iyi bir yöntem
deðil.(scope leakage durumu oluþur, gereksiz yere isim kullanýlýr)
Bu durumda h1(string("Poyraz")); ifadesi en iyi yöntem. Herhangi bir isim kullanýlmadý, kaynak bloke de edilmemiþ oldu. Bu ifade C++'da r-value expression.
Geçici nesnelerin r-value referans olmasý, taþýma semantiðinde de avantaj saðlar.

/////////////////////////////////////////////////////////////////////
string h1(const string &s)
{
	return "<h1>" + s + "</h1>";
}
int main(){
	char str[100];

	h1("ali" + str); //sentaks hatasý, iki adres toplanmýþ olur
	h1(string("ali") + str); //legal

}
/////////////////////////////////////////////////////////////////////
Bir string ile string literali toplandýðýnda operator overloading mekanizmasý devreye girer ancak ilk fonksiyon çaðrýsýnda böyle bir mekanizma yok
ikisi de zaten doðrudan default tür.
h1(string("ali") + str); ifadesinde constructor'ý explicit olmamasýna raðmen böyle bir kodu geçerli kýlmak için geçici nesne oluþturmak gerekir.

Yani nesne bir kere kullanýlacak bir daha kullanýlmayacaksa o türden bir nesne yaratýp kullanmak yerine, geçici nesne oluþturmak daha doðru.
C++11 ile geçici nesne sentaksýnda, uniform initializer da kullanýlabilir.
Myclass bir sýnýf olmak üzere, Myclass() ile Myclass{} ifadeleri birbirine eþ.(uniform initializer tercih edilmeli)
Uniform initializer istisnalar dýþýnda () yerine tercih edilmeli.

C++11 ile dile çok önemli bir sýnýf eklendi, bu sýnýf initializer list.(member initializer list deðil)
Initializer list, standart bir sýnýf.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass(int);//int parametreli ctor
	Myclass(std::initializer_list<int>);
};
/////////////////////////////////////////////////////////////////////
Myclass sýnýfýnýn, bir sýnýf türünden(initializer list sýnýfý türünden) parametreli constructorý var.
Açýsal parantez kullanýlma nedeni, bu sýnýfýn bir template olmasýndan dolayý.(vektördeki gibi)
C++'ýn stl kütüphanesinin container sýnýflarýnýn hemen hepsinin böyle bir constructor'ý var. 

Initializer list bir ifade içinde küme parantezi kullanarak birden fazla deðerin doðrudan bir fonksiyona argüman olarak gönderilmesi, bazý durumlarda
bir fonksiyondan geri dönüþ deðeri olarak almasý gibi konularda yardýmcý olur.
Bir fonksiyona örneðin {1, 4, 6, 7, 9, 77} gibi bir ifade argüman olarak geçilebilir. Böylece bu deðerlerin hepsi birden fonksiyona geçer.
Template olduðundan, virgüller ile birbirinden ayrýlarak yazýlmýþ ifadeler herhangi bir türden veya sýnýf türünden olabilir.

Vector sýnýfý stl'in en fazla kullanýlan container sýnýflarýndan. C++11 öncesinde initializer list sýnýfý olmadýðý için bir container nesnesinin
"doðrudan bu deðerleri tutarak hayata baþlasýn" þeklinde baþlatýlma þansý yoktu.
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<int> vec;
	vector<int> myvec{2, 3, 5, 7, 11};

}
/////////////////////////////////////////////////////////////////////
Örneðin vec nesnesinin hayata ilk 5 tane asal sayýyý tutarak gelmesi istenseydi bu mümkün deðildi. Bunun yerine vec nesnesi tanýmlanýr ardýndan baþka bir
takým iþlemlerle bu deðerleri tutacak hale getirilirdi.
C++11 ile sýnýfýn initializer list ctor'unun olmasý bu konuda büyük bir avantaj saðlar. Böylece herhangi bir container nesnesi belirli deðerlere hayata
getirilebilir. Container sýnýflarýn initializer list parametreli ctor overloadlarý mevcut.
myvec nesnesi ise hayata gelirken, initializer list parametreli ctoruna argüman olarak bu deðerler gönderilir, hayata gelirken bu deðerleri alýr.

Bu sadece constructorlar için deðil, mesela atama operatör fonksiyonu için de geçerli. Bir vektör nesnesine doðrudan assign fonksiyonu ile veya atama operatör
fonksiyonu kullanýlarak yeni deðerler almasý saðlanabilir. Bu durumda da atama operatör fonksiyonunun parametresi initializer list.

Burada uniform initializer kullanýmý ile ilgili bir istisna durumu var.
vector gibi sýnýflarýn, "n tane öðe ile baþlatacak" gibi de bir ctor'u mevcut.
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<int> vec1(12);

	cout << "vec1.size() = " << vec1.size() << endl;

	for (auto i : vec1)
		cout << i << " ";

	cout << "\n";

}
/////////////////////////////////////////////////////////////////////
vec1 düþünüldüðünde, vec1 12 tane 0 ile baþlatýlýr. vec1'in tuttuðu öðe sayýsý 12.

Normal parantez yerine, uniform initializer kullanýlmýþ olsaydý;
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<int> vec1{12};

	cout << "vec1.size() = " << vec1.size() << endl;

	for (auto i : vec1)
		cout << i << " ";

	cout << "\n";

}
/////////////////////////////////////////////////////////////////////
vec1'in size'ý 1 olurdu, içinde tuttuðu tek deðer de 12 olurdu.
Dilin kuralýna göre, eðer initializer list ile birlikte int gibi bir parametre sahip bir fonksiyon overload edilirse ve nesne oluþturulurken
küme parantezi sentaksý kullanýlýrsa, öncelik initializer list parametrenin dolayýsýyla burada küme parantezi kullanmakla normal parantez 
kullanmak arasýnda function overload açýsýndan fark var.
Initializer list ve int ayný fonksiyonun overloadlarý olduðunda küme parantezi kullanýldýðýnda int parametreli olan deðil, initializer list 
devreye girer.

 /////////////////////////////////////////////////////////////////////
class Myclass {

};
void func(Myclass &&) //1
{
	cout << "Myclass &&\n";
}
void func(const Myclass &) //2
{
	cout << "const Myclass &\n";
}

int main()
{
	Myclass m;
	func(m);  //2

	func(Myclass{}); //1 


}
/////////////////////////////////////////////////////////////////////
Eðer sadece 1 nolu fonksiyon olsaydý func(m); geçersiz olurdu çünkü sol taraf deðeri sað taraf referansa baðlanamaz.
Ýki fonksiyon birden olduðunda, 1 nolu olan viable olmaz, viable olan 2 nolu olduðundan, 2 nolu fonksiyon çaðýrýlýrdý.
Konu func(Myclass{}); ifadesi olduðunda, fonksiyona argüman olarak Myclass sýnýfý türünden bir geçici nesne gönderilir.
Eðer  yalnýzca 1 nolu fonksiyon var olmuþ olsaydý çaðrý legal olurdu, geçici nesneler r-value.
Yalnýzca 2 nolu fonksiyon var olmuþ olsaydý func(Myclass{}); ifadesi yine legal olurdu çünkü parametresi const Myclass &,
eðer ki const olmayýp Myclass & parametreli olsaydý çaðrý geçersiz olurdu. 
Her iki fonksiyonun birden bulunmasý durumunda ise && parametreli olan 1 nolu fonksiyon çaðýrýldý.
Taþýma yapýlýp yapýlmayacaðý kararý, bu iki fonksiyon arasýndaki seçime göre verilir. Eðer buradaki fonksiyon func gibi 
bir fonksiyon deðil de constructor olsaydý o zamanki seçimde copy constructor mý move constructor mý hangisi çaðrýlacak
seçimi olacaktý. 

Bir fonksiyona yapýlan çaðrý ifadesi, çaðrýlan fonksiyonun geri dönüþ deðeri referans ise l-value expression, tür ise
r-value expression.
/////////////////////////////////////////////////////////////////////
string h1(const string &s);

int main()
{
	string name{ "mustafa aksoy" };
	//h1(name);//r-value expression, fonksiyonun geri dönüþ deðeri string türünden

	vector<string> svec;

	svec.push_back(name);

}
/////////////////////////////////////////////////////////////////////
Copy constructor çaðýrýlýr, copy ctor'u çaðýran aslýnda push_back çünkü vektöre bunu koymuyor(name) bunun bir kopyasýný koyar.
stl containerlarýnýn hepsi kopyalama semantiði ile çalýþýr, ona bir string gönderildiðinde containera koyulan o string deðil, containerdan
kopyalama ile elde edilen string. Zaten kendisini koysa tehlikeli bir durum oluþurdu, nesnenin hayatý bittiðinde bizim ondaki nesnemizi 
kullanmanýn yolu olmazdý. 

/////////////////////////////////////////////////////////////////////
string h1(const string &s);

int main()
{
	string name{ "mustafa aksoy" };

	vector<string> svec;

	svec.push_back(h1(name));
}
/////////////////////////////////////////////////////////////////////
Bu durumda vektöre konulmak istenen h1 tagi içine alýnmýþ "mustafa aksoy" yazýsý.
Taþýma semantiði olmasaydý, h1 fonksiyonu yerel nesne döndürür, bu yerel nesnenin hayatý biter, destructor string sýnýfýnýn kullandýðý
kaynaklarý geri verecekti, containera koymak için tekrar bunun kopyasý çýkartýlýp oraya koyulurdu.
Ancak nesnenin hayatý zaten son bulacakken kaynaklarý geri verilip, vektöre yeni bir nesne koymak yerine doðrudan bu kaynaklar çalýnýp
kullanýlabilir. Derleyici compile time'da bu ifadeye bakar, ifade r-value expression çünkü fonksiyonun geri dönüþ deðeri referans deðil 
türden. push_back'e iki overload konmuþ, parametrelerinden biri const Myclass & diðeri ise Myclass &&. const Myclass & olan kopyalama 
yapar(ki bir önceki örnekte mecbur kopyalama yapýlýr, kaynaðý çalýnamaz) ancak bu örnekte ise programcýnýn kodu yukarýdaki þekilde 
yazmasýna raðmen(taþýma semantiðinin devreye girmesi için programcýnýn bunu ima etmesi de gerekebilirdi) taþýam semantiði devreye girer.
Fonksiyonun geri dönüþ deðeri string deðil de string & olsaydý, kopyalama yapýlýrdý. Zaten geri dönüþ deðeri referans olsa ve taþýma 
semantiði devreye girseydi ortada yine problemli bir durum olurdu çünkü referansa geri dönmesi demek hayatta olan bir nesneyi döndürmesi
demek, eðer ki taþýma yapýlsaydý hayatta olan bir nesnenin kaynaðý çalýnmýþ olacaktý. Kaldý ki hayatta olan bir nesnenin kaynaklarý gerçekten
çalýnmak isteniyorsa(bazý durumlarda gerekebilir) bu durumda l-value to r-value conversion yapýlýp, normalde copy ctor çaðýrýlacakken, move
ctorun çaðýrýlmasý saðlanabilir.(bir üstteki örnek için svec.push_back(name); yerine svec.push_back(move(name)))

/////////////////////////////////////////////////////////////////////
void func(string s);
string h1(const string &r);

int main()
{
	string name;
	//////
	func(h1(name));	
}
/////////////////////////////////////////////////////////////////////
void func(string s); yerine void func(const string &s); tercih edilmeli
Dilin kurallarýna normalde derleyici func fonksiyonuna yapýlan çaðrýda bir string yaratýr, bu yarattýðý string'e de h1 fonksiyonunun geri dönüþ
deðeri ile copy construct eder. Böylesi durumlarda derleyicinin optimizasyon mekanizmasý devreye girer, taþýma semantiðinin uygulamasý gibi
kod üretir. h1 fonksiyonunun geri dönüþ deðeri olan nesnenin normalde hayatýnýn sona ermesi gerekir, hayatýnýn bitmesi yerine func fonksiyonunun parametresi
olan nesneyi o nesne gibi kullanýr.(bu bir optimizasyon tekniði) C++17'ye kadar nu tür optimizasyonlar derleyicinin insiyatifindeydi, ancak 17 standartlarý 
ile bu tür optimizasyonlarýn önemli bir kýsmý mecburiyet haline getirildi. Standartlara göre burada s için gereksiz yere copy constructor çaðýrýlmayacak
derleyici bu kodu optimize edecek, bu optimizasyon ile hayata veda etmesi gereken nesnenin hayatý devam edecek(life extension).
Bu yüzden koda bakýp void func(string s); fonksiyonu için ilk bakýþta verimsiz denmemeli, fonksiyonun ne ile çaðrýldýðýna da bakýlmalý. Fonksiyon l-value 
expression ile çaðýrýldýðýnda mecburen kopyalama yapýlýr ancak bir r-value expression ile çaðrýlýrsa derleyici kodu optimize ettiði için kopyalama yapýlmaz.
 

STATÝK VERÝ ÖÐELERÝ ve STATÝK FONKSÝYONLAR

C'de olduðu gibi C++'da da static bir keyword. C++'da statik anahtar sözcüðünün kullanýmý daha geniþ.
Sýnýfýn normal(statik olmayan) veri öðeleri artýk non-statik data members. C'deki yapýlarýn bütün veri öðeleri non-static data member.
Sýnýfýn veri öðeleri sýnýf nesnesinin içinde, örnek olarak Myclass sýnýfýnýn int türden bir tane data memberi varsa beklenen sizeof'u 4, eðer 3 tane int türden
data memberi varsa ise beklenen sizeof'u 12 olurdu. Ne kadar çok non-statik data member varsa sýnýf nesnesinin sizeof'u o kadar artar. Non-statik data memberlar
instance ile ilgili bilgileri tutar. Sýnýf nesnesinden baþka bir sýnýf nesnesine deðiþiklik gösterebilir. Table sýnýfý türünden iki tane farklý masa olsun, iksi de 
ayný sýnýf türünden ancak biri mavi, biri kýrmýzý.  Fiziksel olarak bakýldýðýnda da bu veri sýnýf nesnesinin içinde tutulur.
Sýnýfýn kendisi ile ilgili, instance ile ilgili olmayan, sýnýflarýn ortak kullandýðý veri elemanlarý ise static data memberlar. Yani ortada ne kadar sýnýf nesnesi 
olursa olsun bu veri tek. Her sýnýf nesnesi için farklý olmayan veri elemanlarýdýr bu sebepten sýnýfýn içinde tutulmaz. C'deki global deðiþkenlere benzeyen veriler. 
Fakat sýnýfýn static veri elemanlarýnýn global deðiþkenlere tercih edilmesinin de nedenleri var. Bunlardan ilki scope, global deðiþkenlerin scope'u bütün dosyaya 
açýk, ancak sýnýfýn static veri elemanlarý class scope içinde. Baþka bir sonuç ise access control, C'deki global deðiþken modeli olsaydý access control ancak dosya 
bazýnda olabilirdi, iç baðlantý yada dýþ baðlantý þeklinde
 
C'de dosya bazýnda private yapmanýn karþýlýðý static global, böylece hem global olur hem de dýþarýya kapatýlýr. 
/////////////////////////////////////////////////////////////////////
///fethi.c
static int gx = 10; //Dýþarýya kapalý, sadece bu dosyada kullanabilir 
/////////////////////////////////////////////////////////////////////

C++da bu kullaným geçerli ancak bunun yerine geçen ve daha çok tercih edilen bir araç mevcut. Bu araca unnamed namespace denir(isimlendirilmemiþ isim alaný). 
unnamed namespaceler statik global deðiþkenlere yakýn bir anlam taþýr.
/////////////////////////////////////////////////////////////////////
namespace Neco {
	int gx = 10; //gx, Neco namespace'i içinde tanýtýlmýþ olur
}

namespace { // isim yazýlmadýðý zaman, unnamed namespace
	int gx = 10; 
}
/////////////////////////////////////////////////////////////////////
Bu namespace'in içine konulan ne varsa dýþarýya kapatýlmýþ ancak bu kaynak dosyaya açýk anlamýna gelir. C'deki statik globallere göre bir üstünlüðü ise, içerideki 
veri öðelerinin global deðiþken ya da fonksiyon olmasý gerekmiyor type da olabilir ne istenirse konulabilir. Bu þekilde bu dosyanýn kullanmasý istenilen ancak dýþarýya 
kapatýlan global varlýklar derli toplu hepsi beraber olacak þekilde namespace içinde tutulabiliyor.

Sýnýfýn statik veri elemanlarý, sýnýfý genel olarak ilgilendiren, instance ile doðrudan ilgisi olmayan, instance içinde de tutulmayan C'deki global deðiþkenlerin
karþýlýðý. Class member olduklarýndan access control'e tabi ve global deðiþkenlerden farklý olarak class scope içindeler.
Statik veri elemanlarý da diðer tüm sýnýf elemanlarý gibi access control'e tabi; public, private ya da protected yapýlabilir.
Global deðiþkenler özellikle nesne yönelimli programlamada çok fazla kullanýlmaz. C++'da da mecbur kalýnmadýkça kullanýlmaz. Global deðiþken kullanýmýnýn getireceði 
dezavantajlardan kaçýnmanýn ilk yolu global deðiþken olarak kullanýlacak elemanýn sýnýfýn static data memberi olarak kullanýlmasý. C'de global deðiþken kullandýðýmýz 
yerde bu deðiþkenleri bir sýnýfýn veri elemaný yapýyoruz. Bazý durumlarda ise bu durumun da getirmiþ olduðu sakýncalar mevcut bazen ise sýnýfýn static veri elemaný 
olarak deðiþtirilecek global deðiþkenin mantýksal olarak iliþkilendirilebileceði bir sýnýf implementasyonda yok. Bu durumda tek varlýk nedeni global deðiþkeni elimine 
etmek olan sýnýflar var olmuþ oluyor, bu amaca hizmet etmek adýna tek bir static veri elemaný olan sýnýflar oluþturulabilir. Stl'de dahi sýrf statik veri elemanlarý 
bulunan sýnýflar mevcut. Bunun dýþýnda özellikle C#, Java gibi dillerde popüler olan singleton tasarým kalýbý kullanýlýr(tek nesne), ortada bir tane sýnýf nesnesi olur 
ve herkes o sýnýf nesnesine eriþebilir. Bu aslýnda bir anlamda global deðiþken demek. Yani ikinci tipik teknik olarak global deðiþken ortadan kaldýrýlýr ve o global 
deðiþken bir singleton nesnesi haline getirilir. Global nesne kullanýmýndan mümkün olduðunca kaçýlýr.


/////////////////////////////////////////////////////////////////////
////myclass.h
class Myclass{
public:
	static int msx; //myclass sýnýfýnýn static data memberi
};
/////////////////////////////////////////////////////////////////////
Bu baþlýk dosyasýnda, eðer bu bir tanýmlama olsaydý derleyici bunu gördüðünde yer ayýrsaydý o zaman bu baþlýk dosyasýnýn include edildiði her durumda derleyici o nesne 
için tekrar tekrar yer ayýrýrdý. Dolayýsýyla derleyici bunun üstünden geçtiðinde msx için yer ayýrmayacak. Sýnýfýn diðer veri elemanlarýndan farklý olarak derlenebilir 
olmasýnýn dýþýnda çalýþtýrýlabilir, link edilebilir bir programýn oluþmasý için mutlaka kaynak dosyalarýn birinde bunun tanýmý olmalý. Ýþte bu taným derleyicinin msx için yer 
ayýrmasý sonucunu doðurur. Statik veri elemanlarý için yer ayrýlmasýnýn instance ile alakasý yok. Týpký global nesneler gibi sýnýflarýn static veri elemanlarý da main 
çaðrýlmadan önce hayata gelirler. Ancak ortada 5 tane farklý kaynak dosya varsa ve bu kaynak dosyalar farklý sýnýflar içeriyor ve sýnýflarýn da statik veri elemanlarý 
varsa buradaki statik veri elemanlarýnýn hayata gelme sýrasý dil tarafýndan belirlenmiþ bir kurala baðlý deðil. Eðer bu statik data memberlar sýnýf türünden ise
constructorlarý çaðýrýlacak ancak hangisinin constructor'ýnýn daha önce çaðýrýlacaðý konusunda önceden belirleyici bir kural yok.

/////////////////////////////////////////////////////////////////////
////myclass.h // include edilecek baþlýk dosyasý
class Myclass{
	int mx1, mx2;
public:
	static int msx;
};

////client.cpp
#include <iostream>
using namespace std;
#include "myclass.h"
int main(){
	cout << "sizeof(Myclass) = " << sizeof(Myclass) << endl; //Myclass'ýn sizeof'u 12 deðil 8.
}
/////////////////////////////////////////////////////////////////////
Henüz bu kaynak dosyayý derleyen derleyici msx'e yer ayrýlmasýndan sorumlu deðil. Çünkü burada msx'in bildirimi mevcut. msx'e yer ayýracak olan derleyici, myclass.cpp'yi derleyecek derleyici.
Myclass sýnýfýnda 5 tane daha statik veri elemaný olsaydý da sýnýfýn sizeof'u deðiþmezdi. Ortada kaç tane nesne olursa olsun statik veri elemanlarý sýnýf baþýna tek.


/////////////////////////////////////////////////////////////////////
int main(){
	msx = 12; //geçersiz, geçersiz olma sebebi ismin class scope'da aranmamasý
	Myclass::msx = 24; //geçerli, isim class scope'da arandý
}
/////////////////////////////////////////////////////////////////////
Myclass::msx = 24; isim arama baþarýlý ancak program çalýþtýrýldýðýnda linker bir hata verir. Sentaks hatasý yok, linker kodu birleþtirecek, ancak objeleri birleþtirirken baktýðý yerde
msx ismini de bulmasý gerekir ancak bulamaz çünkü msx için kimse yer ayýrmamýþtýr. Bu statik veri elemanýna yer ayýrma iþlemi de bir derleyici tarafýndan yapýlmalý. Instance oluþturmuþ
olmanýn yer ayýrma ile hiçbir alakasý yok. Öncesinde Myclass sýnýfý türünden bir nesne oluþturulmuþ olsa da linker ayný hatayý yine verirdi. Yer ayýrma iþlemini yaptýracak kod tipik olarak
myclass.cpp'de bulunur.


myclass.cpp öncelikle myclass.h yý include eder ardýndan msx'in tanýmý için öncelikle tür adý yazýlýr sonrasýnda ise isim class scope'da olduðundan class scope ile nitelenir.
/////////////////////////////////////////////////////////////////////
///myclass.cpp
//#include "myclass.h"
int Myclass::msx; // Legal ancak güzel bir kod deðil çünkü ilk deðer verilmedi. Týpký global deðiþkenler gibi bunlara da ilk deðer verilmeli.
/////////////////////////////////////////////////////////////////////


Ýlkdeðer verilirken eðer aritmetik türden öðelerse 0 ile ilk deðer verilir, pointer ise nullptr deðeri ile ilk deðer verilir. Eðer sýnýf türünden ise ve ilk deðer verilmemiþse default
constructorlarý çaðrýlýr.
/////////////////////////////////////////////////////////////////////
///myclass.cpp
//#include "myclass.h"
int Myclass::msx = 0; //þeklinde olmalý
/////////////////////////////////////////////////////////////////////

statik anahtar sözcüðü, tekrar edilemeyen anahtar sözcük, yani bildirimde olmalý ancak kesinlikle tanýmda olmamalý. Tanýmda olursa sentaks hatasý. 
sýnýfýn non-statik veri elemanlarý gibi sýnýfýn statik veri elemanlarý da int, double gibi aritmetik türlerden ve bunlarýn dizileri, çok boyutlu dizileri, pointerlarý, referanslarý olabilir.
diðer sýnýf türlerinden de olabilir. 
/////////////////////////////////////////////////////////////////////
class Myclass{
	int mx1, mx2;
public:
	Myclass mx; //sentaks hatasý
	static Myclass msx; //geçerli
};    
/////////////////////////////////////////////////////////////////////

C'de olduðu gibi C++'da da bir sýnýfýn non-statik data memberi kendi türünden olamaz. C'de de bir yapýnýn elemaný kendi türünden olamaz. Derleyici yukarýdan aþaðýya doðru derlerken class Myclass henüz 
incomplete type. Incomplete type türünden öðe oluþturulamaz. Incomplete type'larýn sizeof deðerleri derleyici tarafýndan compile time'da elde edilemez. Ancak Incomplete type'dan veri elemaný olabilir.
statik veri elemaný olmasý sentaks hatasý deðil. Sýnýfýn statik veri elemanýný bildirebilmek için o sýnýfýn complete olmasý gerekmez. Kendi türünden veri elemanýnýn statik olabilmesinin nedeni de budur.

Dilin kurallarýna göre bir non-statik memberin gösterilmesi için o türün complete olmasý gerekir. 
/////////////////////////////////////////////////////////////////////
////myclass.h
class Date; //forward declaration, derleyici türün varlýðýndan haberdar ancak, türün tanýmý derleyiciye gösterilmemiþ, derleyici türü incomplete type olarak görür.
class Myclass{
	int mx1, mx2;
	BigData x; //sentaks hatasý, BigData ismi bulunamadý
	Date x; //sentaks hatasý, Date ismi bulundu, ancak Date incomplete type
	static Date sx; // geçerli
};
/////////////////////////////////////////////////////////////////////
forward declaration: derleyici bir türün varlýðýndan haberdar edilir ancak o türün tanýmý gösterilmez. Böylece derleyici bu türü bir incomplete type olarak görür ve incomplete type kullanýmýnýn geçerli 
olduðu yerde kullanýr.
Dilin kurallarýna göre bir non-statik member'ý gösterebilmek için kodunun complete olmasý gerekir.
Bir sýnýf baþka bir sýnýf türünden veri elemanýna sahip olacaksa, bu örnekteki myclass sýnýfý içinde örnek olarak date sýnýfý türünden bir veri elemaný olacaksa, myclass.h, date baþlýk dosyasýný da include
edilmeli. Bu durumda derleyici önce date sýnýfýnýn tanýmýný görür, date sýnýfý complete type olur ardýndan eleman olarak kullanýlmasý geçerli olacak.
Veri elemaný statik veri elemaný olsaydý, baþlýk dosyasýnýn include edilmesine gerek kalmazdý.  
 
Bir baþlýk dosyasýnýn baþka bir baþlýk dosyasýný include etmesi gerekmiyorsa kesinlikle include edilmemeli. Gereksiz include'lar ortadan kaldýrýlmalý, gerekli gibi görünenler de bazý hileler ile ortadan 
kaldýrýlmalý. Örnek olarak myclass sýnýfý içinde Date türünden statik bir veri elemaný var, bu durumda Date sýnýfýný include etmek yerine, forward declatarion yapýlarak Date sýnýfý bildirilebilir.
Sýnýfýn static veri elemaný baþka sýnýf türündense baþlýk dosyasý include edilmez, sadece forward declaration yapýlýr.
/////////////////////////////////////////////////////////////////////
///myclass.h
class Date; //forward declaration
class Myclass{
	int mx1, mx2;
	static Date x;
public:
};
/////////////////////////////////////////////////////////////////////

Sýnýfýn veri elemaný pointer veya referans ise bunun için yine complete type olma zorunluluðu yok.
Bu durumda yine Date sýnýfýný include etmek yerine forward declaration yapýlýr. Incomplete type olmasýna raðmen geçerli.
/////////////////////////////////////////////////////////////////////
///myclass.h
class Date; //forward declaration, incomplete type
class Myclass{
	int mx1, mx2;
	Date *ptr; //complete type olma zorunluluðu yok
public:
};
/////////////////////////////////////////////////////////////////////
Sýnýfýn statik veri elemanlarý baþka sýnýf veya sýnýflar türünden ise o türlerin complete olmasý gerekmez, forward declaration ile statik veri elemanlarý alýnabilir. Böyle durumlarda kesinlikle sýnýf include
edilmez önbildirim(forward declaration) kullanýlmalý.

C'deki extern bildirimlerinde olduðu gibi array'in boyutu bildirimde yazýlmak zorunda deðil. Boyutun yazýlmasý da sentaks hatasý deðil.
Tanýmda ise dizi boyutu belirtilmeli.
/////////////////////////////////////////////////////////////////////
////myclass.h
class Myclass{
	int mx1, mx2;
public:
	static int a[]; //geçerli
};

////myclass.cpp
int Myclass::a[]; //sentaks hatasý, tanýmda dizi boyutu belirtilmeli
int Myclass::a[10]; //geçerli
int Myclass::a[] = {1, 2, 4, 7}; //geçerli
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//Myclass.h
class Myclass {
	int mx1, mx2;
	static int msx;
};

//Myclass.cpp
#define		PRIVATE //sildirme makrosu ile tanýmda da access kontrol ile ilgili bilgi verilebilir.
PRIVATE int Mylcass:: msx = 17;

int main()
{
	Myclass::msx = 7; // geçersiz, access kontrole takýlýr
}
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
////Myclass.h
class Myclass {
	int mx1, mx2;
public:
	static int msx;
};

////Myclass.cpp
int foo();
int Myclass::msx = foo();
int foo() {
	cout << "foo cagirildi\n";
	return 1; 
}
int main() {
	cout << "main basladi\n";
	Myclass::msx = 98;
}
/////////////////////////////////////////////////////////////////////
foo çaðýrýldý yazýsý main baþladý yazýsýndan önce çýkar. Týpký global deðiþkenler gibi static veri elemanlarý da main baþlamadan önce, 
main çaðrýlmadan hayata gelirler. Sýnýflarýn statik veri elemanlarýnýn varlýðý için ortada o sýnýf türünden bir object olmasý gerekmez.

/////////////////////////////////////////////////////////////////////
class Reza {
public:
	Reza() {
		std::cout << "Reza kurucu islevi\n";
	}
};

class Myclass {
	static Reza sx;
};

////myclass.cpp
Reza Myclass::sx;
int main() {
	cout << "main basladi\n";
}
/////////////////////////////////////////////////////////////////////
statik veri elemaný mainden önce hayata geldiðinden constructor mainden önce çaðrýlmýþ olur.


Ayný kaynak dosyada örneðin myclass.cpp de iki farklý sýnýf türünden statik veri elemaný bildirimi varsa;
static Date Myclass::mdx;
static Fighter Myclass:xyz;
bu durumda mdx'in xyz'den önce hayata geleceði kesin.

/////////////////////////////////////////////////////////////////////
///myclass.cpp
#include "huseyin.h"
int Myclass::smx = func(Huseyin::msdate); //smx, Myclass'ýn statik veri öðesi
/////////////////////////////////////////////////////////////////////
Örnek olarak myclass.cpp içinde huseyin.h baþlýk dosyasý include edilmiþ olsun. huseyin.h baþlýk dosyasýnda Date sýnýfýnýn implementasyonu olduðu düþünülsün ve 
msdate o sýnýf türünden bir static veri elemaný. smx ise Myclass sýnýfý türünden bir statik veri elemaný. int Myclass::smx = func(Huseyin::msdate); kodda smx statik 
veri elemanýnýn ilk deðerini huseyin.h'dan include edilen Date sýnýfý türünden bir statik veri elemanýný argüman olarak alan func fonksiyonunun geri dönüþ deðeri 
olarak almasý isteniliyor. Derleyici bu kodu çalýþtýrdýðýnda Huseyin::msdate'in hayata gelmiþ olmasý gerekir. Ancak dilin kuralllarýna göre Huseyin::msdate'in hayata 
gelmiþ olmasý garanti altýnda deðil. smx'in hayata gelmesi sýrasýnda diðer modüldeki statik veri elemanlarýnýn hayata gelmiþ olmasýnýn garantisi yok.
Ne global deðiþkenlerin ne sýnýfýn statik veri elemanlarýnýn farklý kaynak dosyalarda tanýmlanmalarý durumunda hayata gelme sýrasýna iliþkin dilin bir belirleyiciliði
yok. Dolayýsýyla global yada sýnýfýn statik veri elemanýný tanýmlarken, ona ilk deðer verirken veya onu construct ederken bir baþka modülün statik önürlü varlýðý
kullanýlýrsa, bunun doðru çalýþacaðýna dair dilin bir garantisi yok.

/////////////////////////////////////////////////////////////////////
////myclass.h
class Date;
class Myclass{
	static Date msx;
};
////myclass.cpp
#include "date.h"
Date Myclass::msx;
/////////////////////////////////////////////////////////////////////
Burada derleyicinin myclass.h'daki Myclass sýnýfý bildirimini legal kabul etmesi için class Date; önbildirimi yeterli. Ancak derleyicinin myclass.cpp'deki Date Myclass::msx;
tanýmlamasýný kabul etmesi için class Date; önbildirimi yeterli deðil. Bu yüzden myclass.cpp'de, date.h include edilmeli. date sýnýfýný include eden tek bir kaynak dosya olmuþ
olur ancak class Date; önbildirimi ise birçok dosyaya yayýlmýþ olur, myclass'ý include eden tüm dosyalar bu önbildirimi de include etmiþ olur. date sýnýfýnýn tanýmýna ihtiyaç duyan
ise sadece myclass.cpp. Date Myclass::msx; tanýmlamasýnýn legal olmasý için incomplete type yeterli deðil, tanýmlamanýn geçerli yapýlabilmesi için, ortada bir nesne tanýmlandýðýndan
complete type olmasý gerekir, bunun complete tpye olmasý içinse date.h, myclass.cpp içinde include edilmeli, derleyici sýnýfýn tanýmýný görmeli.


statik veri elemanlarý, sýnýfýn veri elemanlarý olduðu için, bunlara eriþim sýnýfýn üye fonksiyonlarýna serbest. private da olsalar sýnýfýn üye fonksiyonlarý sýnýfýn statik veri eleman-
larýný doðrudan kullanabilir. 
/////////////////////////////////////////////////////////////////////
////myclass.h
class Myclass{
	static int msx;
	void func();
};
////myclass.cpp
int Myclass::msx=0;
void Myclass::func()
{
	msx = 34;
}
/////////////////////////////////////////////////////////////////////
func fonksiyonu içinde msx ismi kullanýldýðýnda, isim arama kurallarý yine ayný þekilde devrede. msx ismi öncelikle block scope'da aranýr bulunamadýðýndan class scope'da aranýr ve bulunur.
Böylece msx'in sýnýfýn statik veri elemaný olduðunu anlaþýlýr ve ona göre kod üretilir. Ayný isimde global bir msx deðiþkeni olsa idi bu global msx, ::msx = 34; þeklinde kullanýlabilirdi.
sýnýfýn statik veri elemaný msx, fonksiyon içinde Myclass::msx = 34; þeklinde nitelenerek de kullanýlabilir.  


Sýnýfýn statik veri elemanlarýnýn MIL sentaksý ile alakasý yok. MIL sentaksý constructor'a yönelik. Constructor, sýnýfýn non-statik veri elemanlarýný set eder ve sýnýf türünden bir nesne 
yaratýldýðýnda çaðrýlýr. Sýnýfýn statik veri elemanýnýn, constructor ile ilk deðer verme iliþkisi yok. Ancak constructor içinde sýnýfýn statik veri elemaný kullanýlabilir fakat ilk deðer
verme durumu söz konusu deðil. Dolayýsýyla buna yönelik bir kod yazma giriþimi geçersiz.
/////////////////////////////////////////////////////////////////////
class Myclass{
	static int msx;
	void func();
public:
	Myclass() : msx{0} {} //geçersiz, sýnýfýn statik veri elemanlarý bu þekilde ilk deðer alamaz.
};
/////////////////////////////////////////////////////////////////////
Ancak constructor da sýnýfýn bir üye fonksiyonu olduðundan ve statik veri elemanlarýna eriþim ile ilgili bir sýnýrlamasý olmadýðýndan, constructor içinde de sýnýfýn statik veri elemanlarý
deðer alabilir, kullanýlabilir, atama yapýlabilir.


/////////////////////////////////////////////////////////////////////
class Myclass{
	static int msx;
public:
	void func()const{
		msx = 10;	//geçerli
	}
};
/////////////////////////////////////////////////////////////////////
sýnýfýn const üye fonksiyonu da sýnýfýn statik veri elemanýný kullanabilir. const üye fonksiyon, hangi nesne için çaðrýldýysa o nesneyi deðiþtirmez. sýnýfýn statik veri elemaný ile bunun
bir ilgisi yok.


C++'da isim arama ile sahiplik iliþkisi ile alakasý yok. msx Myclass scope'u içinde aranýr. msx isminin nerede arandýðýný belirleyen, m ve p nesnelerinin türü. msx aranýp bulunduðunda
msx'in sýnýfýn statik veri elemaný olduðu anlaþýlýr. Derleyicinin ürettiði kodun m ve p instancelarý ile bir ilgisi yok. Görüntü olarak bakýldýðýnda m.msx = 10; gibi bir ifade sanki 
yapýlan iþin instance ile bir ilgisi varmmýþ gibi gözüküyor veya p pointerýnýn gösterdiði nesne ile bir iliþkisi varmýþ gibi gözüküyor ancak nesneler sadece compile time'da isim arama 
amaçlý kullanýlmýþ. Sýnýfýn statik öðelerine client kodlar nokta ve ok operatörü ile de eriþebilir ancak böyle bir eriþim tavsiye edilen bir eriþim deðil, okunabilirlik açýsýndan yanlýþ
bir algý yaratýr.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	static int msx;
};
int main() {
	Myclass m;
	Myclass *p = new Myclass;
	m.msx = 10; //geçerli
	p->msx = 20; //geçerli
}
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	static int msx;
	int foo();
};
int foo();
int Myclass::msx = foo(); //sentaks hatasý
/////////////////////////////////////////////////////////////////////
sýnýfýn statik veri elemanýnýn tanýmýnda ona ilk deðer veren ifadenin kendisi de class scope'da kabul edilir. Yani foo ismi ilk önce class scope'da aranýr ve bulunur. Artýk sýnýfýn statik
veri elemanýna ilk deðerini veren ifadenin isminin ne ismi olduðu belirli, isim sýnýfýn non-statik üye fonksiyonunun ismi. Sentaks hatasý olmasýnýn sebebi, foo fonksiyonunun çaðrýlmasý için
bir this nesnesi gerekir. Ortada bir this nesnesi olmaksýzýn fonksiyona yapýlan çaðrý geçersiz, çünkü fonksiyon sýnýfýn non-statik üye fonksiyonu.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	static double msx;
	static int foo();
};
double foo();
double Myclass::msx = foo();
/////////////////////////////////////////////////////////////////////
msx statik veri elemanýnýn tanýmýnda yine ayný þekilde, ona ilk deðerini verecek olan ifade class scope'da kabul edilir. foo ismi class scope'da aranýr ve bulunur. Çaðrýlan foo fonksiyonu 
sýnýfýn statik üye fonksiyonu. Sýnýfýn statik veri elemanlarýna ilk deðer vermekte kullanýlan ifdelerin kendisi de class scope'da, sýnýfýn fonksiyonun içi gibi kullanacak ve isim arama 
kurallarý da buna göre devreye girecek, isim önce class scope'da aranacak. sýnýfýn üye fonksiyonu foo'nun geri dönüþ deðeri void olsaydý sentaks hatasý olurdu,  global foo fonksiyonuna yine
bakýlmazdý, çünkü isim arama bir kez yapýlýr ve isim bulunduðunda arama sonlanýr, bu durumda yine class scope'daki foo fonksiyonu bulunurdu ancak geri dönüþ deðeri türü void olduðu için
kod legal olmazdý.

/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	static int x;
	static iny y;
};
int y = 45;
int Myclass::x = y; // x'e class scope'da olan y ile ilk deðer verilir
int Myclass::y = y; // y'ye kendisi ile ilk deðer verilir.
int Myclass::y = ::y; // statik veri elemaný y'ye global y ile ilk deðer veriliyor.
/////////////////////////////////////////////////////////////////////
int Myclass::x = y; ifadesinde sýnýfýn statik veri elemaný olan y'de aslýnda çöp deðer var. Ancak statik ömürlü nesneler hiçbir zaman çöp deðeri ile hayata gelmezler. Onlarýn bellek 
alanlarý hayata gelmeden önce zero initialize denilen kurallar sýfýrlanýr. x her ne kadar 0 ile ilk deðerini almýþ olsa da, ifade lojik olarak doðru deðil.

STATIC MEMBER FUNCTIONS

Statik üye fonksiyonlar this pointeri olmayan dolayýsýyla bir sýnýf nesnesinin adresi ile çaðrýlmayan, bir instance ile ilgisi olmayan fonksiyonlar. Sýnýf ile genel olarak ilgili olan ancak
instance ile ilgili olmayan fonksiyonlar. C'deki en yakýn karþýlýðý global fonksiyonlar. C++'da global fonksiyonlar(free function) yerine geçmeye en büyük aday statik üye fonksiyonlar.
Sýnýfýn statik üye fonksiyonlarý class scope'da, isim arama kurallarý ona göre deðerlendirilir ancak global fonksiyonlar global scope'da.
Sýnýfýn statik fonksiyonlarý sýnýfýn memberlarý olduðu için, this pointerýna sahip deðil ancak sýnýfýn private bölümüne eriþebilirler. GLobal fonksiyonlar ise sýnýfýn private bölümüne eriþemez.
Sýnýfýn statik fonksiyonlarý access control'e sahip, global bir fonksiyon public, private yada protected yapýlamaz, ancak dosya bazýna private yapýlabilir.
Çaðrýlmalarý için bir instance'ýn hayatta olmasý gerekmez, herhangi bir sýnýf nesnesi hayatta deðilken sýnýfýn statik fonksiyonlarý çaðrýlabilir.

/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	static void func(int); //func myclass sýnýfýnýn public static üye fonksiyonu
	{

	}
};
/////////////////////////////////////////////////////////////////////
Sýnýfýn statik üye fonksiyonlarý da diðer fonksiyonlar gibi sýnýfýn içinde inline olarak tanýmlanabilir.

Eðer inline olarak tanýmlanmayacak, cpp dosyasýnda tanýmlanacaksa tanýmýn non-statik üye fonksiyonlardan bir farký yok;
/////////////////////////////////////////////////////////////////////
void Myclass::func(int x)
{
} 
/////////////////////////////////////////////////////////////////////
þeklinde tanýmlanýr. 
statik veri elemanlarýnda olduðu gibi tanýmda statik anahtar sözcüðünün kullanýlmasý sentaks hatasý.
 

isim arama kurallarý ayný, isim öncelikle fonksiyonun bloðunda aranýr, bulunamazsa class scope'da bulunamazsa global alanda aranýr.
/////////////////////////////////////////////////////////////////////
class Myclass{
	int mval;
public:
	static void func(int);
};
void Myclass::func(int x){ 
	mval = 45;	//geçersiz, kimin mval'i ?
}
/////////////////////////////////////////////////////////////////////
isim blockda arandý bulunamadý, ardýndan class scope'da arandý ve bulundu, sentaks hatasýnýn nedeni isim arama deðil.
Derleyici mval'i aradý ve buldu, bulduðunda mval'in non-statik veri elemaný olduðunu anladý ancak ortada bir this nesnesi olmadýðýndan
mval = 45; ifadesinde mval'i bir nesneye baðlayamaz.
Sýnýfýn statik üye iþlevleri, sýnýfýn non-statik veri öðelerini isimleriyle kullanamazlar.


/////////////////////////////////////////////////////////////////////
void Myclass::func(int x){
	Myclass m;
	m.mval = 12; // geçerli, isim aramada, kullanýmda ve access control'de bir problem yok.
}
/////////////////////////////////////////////////////////////////////
Global fonksiyon olsa access control'e takýlýr sýnýfýn private bölümündeki veri elemanýna eriþemezdi.


Sýnýfýn constructor'ý private iken client'lar nesne oluþturamaz.
/////////////////////////////////////////////////////////////////////
class Myclass{
	Myclass();
public:
};

int main() {

	Myclass m; //sentaks hatasý, ctor private
	Myclass *p = new Myclass; //sentaks hatasý, ctor private
} 
/////////////////////////////////////////////////////////////////////


Ancak sýnýfýn kendi üye fonksiyonlarý bu sýnýf türünden nesne oluþturabilirler. 
/////////////////////////////////////////////////////////////////////
class Myclass{
	Myclass();
public:
	static Myclass *createObject(){
		return new Myclass;
	}
};
/////////////////////////////////////////////////////////////////////
Böyle bir sýnýf için clientlar nesne oluþturumaz, çünkü sýnýfýn constructor'ý private bölümde ancak sýnýfýn statik üye fonksiyonlarýnýn sýnýfýn private
bölüme eriþmelerinde bir engel olmadýðýndan kod geçerli. Client kodlarýn, Myclass sýnýfý türünden statik ömürlü veya otomatik ömürlü nesne oluþturma 
þansý yok. Myclass sýnýfý türünden nesne oluþturmanýn tek yolu, sýnýfýn createObject fonksiyonunu çaðýrmak bu da dinamik ömürlü nesne oluþturduðuna
göre, clientlar tüm Myclass nesnelerini dinamik olarak kullanmak zorunda. 


/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	static void func()const; //geçersiz
};
/////////////////////////////////////////////////////////////////////
buradaki const'un anlamý buradaki this pointerýnýn low level const olmasý. statik üye fonksiyonlarýn this pointeri olmadýðýndan const da olamaz.
statik üye fonksiyonlar için const anahtar sözcüðü bu þekilde kullanýlamaz.

/////////////////////////////////////////////////////////////////////
class Myclass{
	void f1();
	static void f2(){
		f1(); //geçersiz

		Myclass m;
		m.f1(); //geçerli
	}	
};
/////////////////////////////////////////////////////////////////////
f1 sýnýfýn non-statik üye fonksiyonu olduðundan *this olarak kullanýlacak bir nesneye ihtiyacý var.
Sýnýfýn statik üye fonksiyonu, doðrudan ismi ile sýnýfýn non-statik üye fonksiyonunu çaðýramaz.

/////////////////////////////////////////////////////////////////////
class Myclass{
	static void f1();
	static void f2(){
		f1(); //geçerli
	}	
}; 
/////////////////////////////////////////////////////////////////////
statik bir fonksiyon sýnýfýn baþka bir statik fonksiyonunu doðrudan çaðýrabilir.


3_12_2017 PAZAR

Statik fonksiyonlarýn this pointerlarý yok. Statik üye fonksiyon const olamaz.
Private olabilir, sýnýfýn statik üye fonksiyonu içerisinde sýnýfýn private bölümüne de eriþilebilir.
Statik üye fonksiyon, sýnýfýn non-statik veri elemanlarýný doðrudan isimleri ile kullanamaz çünkü ortada bir this pointerý yok.
Statik üye fonksiyon içerisinde sýnýfýn non-statik üye fonksiyonu da doðrudan çaðýrýlamaz ancak statik üye fonksiyon içerisinde sýnýfýn diðer 
statik üye fonksiyonlarý çaðýrýlabilir. 
Statik üye fonksiyon, non-statik veri elemanlarýný doðrudan ismi ile kullanamaz ancak sýnýfýn statik veri elemanýný doðrudan ismi ile kullanabilir.

/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	static int smx;
	static void func();
	//static void Myclass::func(); //bildirim bu þekilde de yapýlabilir ancak gereksiz, zaten ayný scope içerisinde 
	void foo();
};
//cpp
#define	STATIC
STATIC void Myclass:func()
{
	smx = 7;
}

void Myclass::foo()
{
	smx = 91;
}
/////////////////////////////////////////////////////////////////////
Statik üye fonksiyon sýnýf içerisinde inline olarak da tanýmlanabillir. Inline olarak tanýmlanmasaydý cpp dosyasýnda diðer fonksiyonlar gibi
tanýmlanacaktý ancak tanýmda kesinlikle static anahtar sözcüðü kullanýlmayacak.
Ýmplementasyon dosyasýna bakýldýðýnda hangi fonksiyonlarýn static member function hangisinin non-statik member function olduðu doðrudan görülemez.
cpp dosyasýa bakýldýðýda foo'nun ve func'ýn sýnýfýn statik veya non-statik üye fonksiyonu olduðu anlaþýlamaz.(bu iki fonksiyon da sýnýfýn statik
 veri elemanýný doðrudan ismi ile kullanabilir.) Ýmplementasyon dosyasýnda bunu kolayca görebilmek için STATIC anahtar sözcüðüne karþýlýk boþ
bir makro tanýmlanýr ve statik üye fonksiyon.

C'de oluþturduðumuz Date kütüphanesi düþünüldüðünde orada bazý iþlemleri yapmak için aylarýn isimlerini tutan, haftanýn günlerinin isimlerini tutan
pointer dizileri ve aylarýn kaç çektiðini tutan 2 boyutlu dizi kullanmýþtýk, bu dizileri date kütüphanesi kullanýyordu ve dýþarýya açmamýþtýk.
Cpp düþünüldüðünde Date bir sýnýfsa, bunlarý global yapmak yerine sýnýfýn statik veri elemaný yapacaðýz. Bütün nesneler eriþebilecek, nesneler
olmadan da kullanýlabilecek, sýnýfýn genelini ilgilendiren bilgileri tutuyorlar.
Debug amaçlý sýnýfýn üye fonksiyonlarýnýn toplamda kaç kez çaðýrýldýðý bilgisini tutan bir deðiþkene ihtiyaç olduðu düþünülürse bu da statik bir 
deðiþken olmalý, bütün fonksiyonlar çaðrýldýðýnda bu sayacý arttýrmasý gerekir. Çünkü bu counter instance ile ilgili deðil sýnýfýn geneli ile ilgili.

Örnek olarak tarih kütüphanesinin artýk yýl testi yapan bir fonksiyonu olsun, konsept olarak tarih ile ilgili. Ancak instance ile ilgili deðil
herhangi bir tarih nesnesi artýk yýl mý deðil mi kontrolü yapýyor. Statik bir member function olabilir.
Account örneðinde hesabýn faiz oraný; eðer ki faiz oraný hesaptan hesaba deðiþmiyor ise bunu get edecek fonksiyon statik üye fonksiyon olmalý.
Date kütüphanesinde, rastgele tarih oluþturan bir fonksiyon vardý, Date'in bir class olduðu düþünülürse, bu fonksiyon statik üye fonksiyon olmalý
çünkü instance ile bir ilgisi yok.
Instance ile ilgili mi yoksa genel olarak sýnýf ile ilgili bir hizmet mi veriliyor diye düþünülüp bunun cevabýna göre, data member veya member function
statik veya non-statik olmalý.

Data memberýn statik mi non-statik mi olmasý bir soru, const olup olmamasý baþka bir soru. const olup olmama durumu statik ve non-statik data member için
geçerli. Sýnýfýn statik veri elemaný da non-statik veri elemanlarý gibi const olabilir. Sýnýfýn non-statik veri elemanýnýn const yapýlmasý çok fazla tercih
edilmez, bazen model bunu gerektirse de sýnýfýn veri elemaný const yapýlmaz.
Yine bu faiz oraný düþünüldüðünde, her hesabýn faizi farklýysa non-statik data member olmalý. Banka hesabýn faizini deðiþtirebiliyor ise böyle bir durumda
zaten const olma ihtimali bulunmuyor. Her hesabýn faizi deðiþik olabiliyor ancak ilgili hesabýn faiz oraný hep aynýysa bu durumda bu data member const olabilir.
Böylece yanlýþlýkla bunu deðiþtirmeye yönelik kodlar geçersiz olur.
Non-statik veri elemanlarýnýn constluðu daha az karþýmýza çýksa da, statik veri elemanlarýnýn constluðu önemli bir konu. Herkese ayný faiz oranýnýn uygulandýðý
ve faiz oranýnýn da hiç deðiþmediði düþünülürse, bu durumda hiç düþünmeden const yapýlmalý.
Date sýnýfýnda, aylarýn kaç çektiði bilgisi, statik olmasýnýn yanýnda ayný zamanda da const olmalý.(bu bilginin deðiþtirilemiyor olmasý gerek)

/////////////////////////////////////////////////////////////////////
class Myclass{
	int mx = 10; //in class initialization, C++11
	//int mx{10}; // bu þekilde de kullanýlabilir
public:

};
/////////////////////////////////////////////////////////////////////
int mx = 10; ifadesi düþünüldüðünde, tüm ctorlar eðer mx'e mil sentaksý ile mx'e bir ilk deðer vermezlerse derleyici kendi yazdýðý veya programcýnýn yazdýðý bütün 
ctorlara, mx'i mil sentaksý ile bu deðerle initialize edecek bir kodu ekler. Ayný anlamda () kullanýlamaz ancak {} kullanýlabilir. In class initializer'da normal
parantez kullanýlamaz ancak küme parantezi(uniform initializer) kullanýlabilir.


/////////////////////////////////////////////////////////////////////
class Myclass{
	static int x = 0; //sentaks hatasý
	static int x{0} // bu da ayný þekilde geçersiz
public:

};
/////////////////////////////////////////////////////////////////////
Sýnýfýn statik veri elemanlarýna sýnýf içinde bu þekilde ilk deðer verilemez.
C++11 öncesinde de geçerli deðildi, C++11'de de geçerli deðil.

  
/////////////////////////////////////////////////////////////////////
class Myclass{
	const static int x = 10; //geçerli
	const int double y = 10; //geçersiz, gerçek sayý türü olmamalý
	static int z = 10; //geçersiz, integral type ancak const deðil!

public:

};
/////////////////////////////////////////////////////////////////////
Üsttekiler ile ilgili olarak, eskiden beri bir istisna mevcut.
Eðer ki data member, statik olmakla birlikte const ise ve integral type ise(gerçek sayý türlerinden olamaz) ilk deðer verilebilir.
Data member, const statik ve integral type ise ve sýnýf içerisinde ilk deðerini almýþ ise, sýnýfýn dýþýnda tekrar tanýmlanmasa da geçerli. Bu þekilde
ilk deðer verilmiþse ne compile time'da ne de run time'da herhangi bir hata ile karþýlaþýlmaz.


/////////////////////////////////////////////////////////////////////
class Myclass{	
public:
	const static int x = 10;
};
//myclass.cpp
const int Myclass::x;
//const int Myclass::x = 45; //geçersiz
/////////////////////////////////////////////////////////////////////
Tanýmýnýn yapýlmasý sentaks hatasý deðil, yapýlabilir. Ancak tanýmda tekrar ilk deðer verilemez.		
Cpp dosyasýnda tanýmýnýn yapýlmamasý her ne kadar bir hata getirmese de yine de tanýmý cpp dosyasýnda yapýlmalý.(uygulama pratiðinde daha doðru)


Bazý sýnýflar, sýnýf nesnelerinin ancak dinamik olma zorunluluðu ile clientlara kullandýrýlýr. Client kodlarýn bu sýnýf türünden otomatik veya statik ömürlü
nesneler oluþturmasý, sýnýfý tasarlayan programcý tarafýndan engellenir. Týpký Java ve C#'daki gibi bütün class type objelerin dinamik olmasý zorunluluðu.
Buradaki tipik kodlama patterni: Genel olarak constructor olmamasýna raðmen constructormýþ gibi kullanýlan isimlendirilmiþ fonksiyonlara named ctor denir.
(isimlendirilmiþ constructor). Bu tema ayný zamanda bir named constructor temasý. Herhangi bir sýnýf bu hale getirilebilir.

/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
public:
	explicit Counter(int val = 0) : mx{val} {}
	Counter operator++(int)
	{
		Counter temp{ *this };
		++*this;
		return temp;
	}
	Counter &operator++()
	{
		++mx;
		return *this;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	int getValue()const
	{
		return mx;
	}
	Counter &set(int val)
	{
		mx = val;
		return *this;
	}
};
//set fonksiyonunun Counter & döndürmesinin nedeni, iç içe kullanýmý saðlamak için. Bu tür fonksiyonlarda,
//set fonksiyonlarýnýn genel kovensiyonu olarak, set fonksiyonu *this döndürür. Böylece bir nesneyi set
//ettikten sonra onu set eden ifade ayný zamanda nesnenin kendisi olarak kullanýlabilir. 

int main() {

	Counter c1{ 12 }, c2{ 20 };

	Counter c3;

	c3 = ++c1;

	cout << c3 << " " << c1 << " " << c2++ << endl;
} 
/////////////////////////////////////////////////////////////////////

Counter sýnýfý için, yukarýda bahsedilen named constructor temasýnýn uygulamasý: sadece dinamik ömürlü nesne 
kullanýmýna izin verilecek;

/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
	explicit Counter(int val = 0) : mx{ val } {}
public:
	Counter(const Counter &c) = delete;
	static Counter *createObject(int val = 0)
	{
		return new Counter{ val };
	}
	Counter &operator++()
	{
		++mx;
		return *this;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	int getValue()const
	{
		return mx;
	}
	Counter &set(int val)
	{
		mx = val;
		return *this;
	}
};

int main() {
	
//	Counter c1; //geçersiz
//	auto p = new Counter{ 20 }; //geçersiz
	
	auto pd = Counter::createObject(12);

	cout << pd->getValue() << endl;

	cout << pd->set(25) << endl;

	Counter c{ *pd }; // geçersiz, copy ctor delete edildi.


} 
/////////////////////////////////////////////////////////////////////
Otomatik, statik veya dinamik ömürlü nesne oluþturulamaz, constructor sýnýfýn private bölümünde.
Dinamik ömürlü nesne kullanýmýný mümkün kýlmak için, isimlendirilmiþ public bir constructor yazýlýr, bu fonksiyon sýnýfýn statik üye fonksiyonu olacak çünkü zaten statik olmazsa
bunu çaðýrmak için bir nesne gerekir, zaten o nesne yaratýlamýyor.
Sýnýfýn kendi kodlarý otomatik ömürlü nesne oluþturabilir, amaç client kodlara yasaklamak.
Copy constructor'ýn delete edilmesinin sebebi, copy constructor delete edilmeseydi, kopyalama yolu ile otomatik ömürlü nesne hayata getirmek mümkün olurdu.
Copy ctor delete edilmeseydi Counter c{ *pd }; ifadesinde, c; pd'den kopyalama yolu ile oluþturulan otomatik ömürlü nesne olurdu, bu þekilde de otomatik ömürlü nesne
oluþturulabileceðinden, konvensiyon gereði copy ctor delete edildi.


Singleton Patterni(Tek bir nesne): Sýnýf türünden tek bir nesne olacak yani sýnýf türünden ikinci bir nesne oluþturulmasýna izin verilmeyecek. Ancak bütün dosyalarýn, bütün kodlarýn bu
nesneye eriþimi olacak, herkese eriþim hakký verilecek, global bir access olmuþ olur.
Ýstenen, herhangi bir noktada tek olan Counter nesnesine eriþilebilecek ve ikinci bir Counter nesnesi oluþturmak mümkün olmayacak.
/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
	static Counter *ps;
	explicit Counter(int val = 0) : mx{val} {}
public:
	Counter(const Counter &) = delete;
	static Counter *getInstance()
	{
		if (ps == nullptr)
			ps = new Counter{0};

		return ps;
	}
	Counter &operator++()
	{
		++mx;
		return *this;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	int getValue()const
	{
		return mx;
	}
	Counter &set(int val)
	{
		mx = val;
		return *this;
	}
};
//counter.cpp
Counter * Counter::ps = nullptr;
int main() {
	
	auto p = Counter::getInstance();

	cout << *p << endl;
	p->set(124);
}
/////////////////////////////////////////////////////////////////////
ps, nullptr ile initialize edildiðinde, getInstance fonksiyonu ilk kez çaðrýldýðýnda if'in doðru kýsmýna girilir ve ps adresine orada yaratýlan dinamik ömürlü nesnesnin
adresi atanýr ve o adres ile geri dönülür. Fonksiyon ikinci kez çaðrýldýðýnda ps'nin deðeri artýk nullptr olmadýðýndan varolan ps adresi ile geri dönülür, ps sanki bir
bayrak deðiþkenmiþ gibi görevini yapar. 
Pointer semantiði yerine referans semantiði de kullanýlabilirdi. Bu durumda getInstance fonksiyonu Counter * deðil Counter & döndürürdü ve *ps ile return ederdi.
Client kodda ise Counter türünden bir referans yaratýlýp ona getInstance'in geri dönüþ deðeri atanýrdý.
/////////////////////////////////////////////////////////////////////
static Counter &getInstance()
{
	if(ps == nullptr)
	ps = new Counter{0};

	return *ps;
}
////////////
int main()
{
	Counter &c = Counter::getInstance();
}
/////////////////////////////////////////////////////////////////////
Copy constructor'ýn delete edilmesinin sebebi yine kopyalama yoluyla ikinci bir nesnenin yaratýlmasýný engellemek, eðer copy constructor delete edilmeseydi;
Counter c = Counter::getInstance(); ifadesinde kopyalama yapýlýrdý, c copy constructor ile hayata gelmiþ olurdu. 
Pointer semantiði yerine referans semantiðine geçildiðinde nesnenin c isminin tanýmý da Counter &c þeklinde olmalý. Counter c olursa o fonksiyonun geri 
döndürdüðü nesnenin kendisi olmaz, onun deðerini kopyalama yolu ile alýr, nesnenin kendisi olmasý için c'nin de bir referans olmasý gerekir.

Herhangi bir referans isim yaratmadan, Counter::getInstance() zaten bir fonksiyon çaðrýsý olduðundan ve fonksiyon çaðrýsýnýn geri dönüþ deðeri referans 
olduðundan bu ifade doðrudan l-value yani singleton nesnesinin kendisi olarakl kullanýlabilir.
/////////////////////////////////////////////////////////////////////
int main(){
	Counter::getInstance().set(13);
	int x = Counter::getInstance().getValue();
}
/////////////////////////////////////////////////////////////////////
Burada bir referans isim kullanmanýn buna göre avantajý yazým kolaylýðý, eðer birden fazla yerde kullanýlacaksa, referans isim kullanarak yazým kolaylýðý
elde edilir. Referans isim kullanýldýðýnda fonksiyon çaðrýsý her defasýnda yapýlmaz ancak burada bu bir avantaj deðil çünkü derleyicinin yaptýðý optimizasyonlar
neticesinde, bunu inline olarak açtýðýndan her fonksiyon çaðrýsý fiilen o fonksiyonun çaðýrýlacaðý anlamýna gelmez.


Date isimli bir sýnýf var, bu sýnýfýn genel olarak kullanacaðý, fakat instance ile ilgisi olmayan, look-up table olarak kullanýlacak bir dizisi var.
pmons statik bir data member, array. Bildirim olduðundan köþeli parantez içine boyut yazýlmasý zorunlu deðil. pmons dizisinin öðeleri const char *. 
/////////////////////////////////////////////////////////////////////
class Date{
public:
	static const char * const pmons[];
};
int main()
{
	Date::pmons[3];
}
/////////////////////////////////////////////////////////////////////
Böyle bir dizi olduðunda(sadece bu dizi için deðil, herhangi bir statik veri elemaný için), public yapýp, client kodlara ismi ile kullanma hakký verilebilir.
Böyle olsaydý client kodu yazan programcý bu look-up table dizisini ismi ile kullanabilir.

Ýkinci bir yol olarak, dýþarýdan gizlenip, sýnýfa statik bir get fonksiyonu yazýlýp client kodun bu fonksiyon vasýtasý ile statik date member'a eriþebilir.
/////////////////////////////////////////////////////////////////////
class Date{
	static const char * const pmons[];
public:
	static GetTableElement();
};
/////////////////////////////////////////////////////////////////////
Burada dizi doðrudan kullanýlmýyor, fonksiyon kullanýlarak diziye eriþiliyor.

Bu durumda hangi konvensiyonun seçileceði duruma göre deðiþebilir. Bazý karar verme kriterlerine göre seçim yapýlýr.
Eðer dizi veya nesne, herhangi bir statik veri elemaný public yapýlýrsa bunun artýk deðiþmeyeceði güvencesi verilmiþ olur çünkü bu deðiþtiði zaman client
kodlarýn da deðiþmesi gerekir. Deðiþtirmeye yönelik bir kaygý varsa bu durumda doðrudan kullanýlmasýna izin vermek doðru bir karar olmaz bu durumda her
deðiþiklik yapýldýðýnda client kodlarýn da yeniden derlenmesi gerekir böyle bir senaryoda private static yapýlýp, interface'deki bir fonksiyon ile eriþim
saðlanmalý.
Dizi doðrudan verilirse, diziye yanlýþ index geçilebilir ancak diziye doðrudan eriþim vermek yerine, index alan bir fonksiyon yazýlýrsa bu fonksiyon geçerli
index olup olmama durumuna iliþkin kontroller yapýp, gerektiðinde exception throw edebilir.
Senaryolarýn hepsinde olmasa çok daha büyük çoðunluðunda doðrudan eriþim vermek yerine, bir interface ile bu eriþim saðlanýr.
Kontrollü eriþim vermek daha fazla tercih edilir. Ancak doðrudan eriþim verilmesi senaryosu da az deðil, örnek olarak string sýnýfý.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str; //str, string sýnýfý türünden bir nesne, str için default ctor çaðýrýlýr

	cout << "Bir yazi giriniz : ";
	getline(cin, str); //global bir fonksiyon, nokta operatörü ile çaðrýlmamýþ, C'deki gets'in yakýn bir karþýlýðý
	cout << str << endl;

	auto idx = str.find('a');	
}
/////////////////////////////////////////////////////////////////////
auto yazýlmasaydý, string::size_type idx = str.find('A'); þeklinde yazýlýrdý. string::size_type bir member type, yine bir tür ancak C'deki türlerden farklý olarak string sýnýfýnýn
scope'unda. Yazýnýn içinde 'a' karakteri olabilir, olmayabilir de. C'de baþarýsýzlýk durumunda null pointer deðeri geri döndürülür. C++'da string sýnýfýnýn arama fonksiyonlarý adres
döndürmez, index geri döndürür, karakterin bulunduðu yerin indeksini döndürür. String sýnýfýnýn const statik bir veri elemaný var, adý: npos. 

String sýnýfýnýn kodu görünseydi npos, þu þekilde olurdu;
String aslýnda böyle bir sýnýf deðil, string de bir template. Derleyici compile time'da string sýnýfýnýn kodunu yazacak.
Aþaðýda basitleþtirilmiþ þekilde yazýldý.
/////////////////////////////////////////////////////////////////////
class String{
	typedef size_t size_type; //typedef bildirimi global düzeyde deðil, class scope'da yapýldýðýndan bu artýk bir nested type
	size_type find(char c);
	const static size_type npos = numeric_limits<unsigned int>::max;
};
/////////////////////////////////////////////////////////////////////
sýnýfýn const statik veri elemaný olan npos'a sistemdeki size_t türünün alabileceði en büyük deðer ile ilk deðer verilmiþ.
Arama baþarýsýzlýk ile sonuçlandýðýnda deðerin geçerli bir index olamamasý gerekir.String sýnýfý türünden bir nesnenin tutabileceði en büyük yazýnýn uzunluðunun unsigned int sýnýr deðeri olduðu düþünülsün 
bu durumda bu deðer 4 milyar 290 milyon küsür. En büyük uzunluk bu olduðuna göre bu deðerin geçerli bir index olabilme ihtimali yok, geçerli bir index ancak bu deðerin bir eksiði olabilir. Bir yazýnýn
olabileceði maksimum uzunluk deðeri baþarýsýz arama deðeri olarak kullanýlmýþ, npos aslýnda bu demek.
Burada verilen örnek için, npos string sýnýfýnýn statik const data memberi.


/////////////////////////////////////////////////////////////////////
int main(){
	cout.setf(ios::boolalpha);
}
/////////////////////////////////////////////////////////////////////
cout, bir nesnenin ismi. setf, sýnýfýn üye fonksiyonu, görünüþe göre de sýnýfýn non-statik üye fonksiyonu.
ios::boolaplha ise fonksiyona gönderilen bir argüman, arügman olmasý için ifade olmasý gerekir bir typename olamaz.
Ýfade olduðundan ve çözünürlük operatörü ile buna eriþildiðinden tek ihtimal bu statik data-member. non-statik data member olsa this object gerekir.
Bu gönderilen deðer gerçekten iosbase isimli sýnýfýn const statik data memberi.

Genel uygulama pratiðinde statik veri elemanlarýnýn doðrudan ismi ile client kodlara eriþim hakký vermek yerine, çoðunlukla statik member functionlar ile manipule ederek
eriþtirmek çok daha yaygýn. Ancak bazý durumlarda bazý sýnýflar bu statik veri elemanýný doðrudan vermeyi de tercih edebiliyor. Statik veri elemanýnýn const olmasý durumunda ve primitif türlerden olmasý 
durumunda doðrudan verme ihtimali çok daha yüksek, çünkü bu durumda fazla sakýnca oluþturacak bir durum yok.

Ýster member function olsun, ister free function, ister statik member function olsun, fonksiyon fonksiyondur. Yani alt seviyede bakýldýðýnda fonksiyonlarýn arasýnda fark yok. Fonksiyonun makina kodu 
programýn çalýþma zamanýnda bellekte olmak zorunda. Bunun fonksiyonun kaç kez çaðrýldýðý ile ilgisi yok. Fonksiyonlar run-time açýsýndan bakýldýðýnda statik ömürlü varlýklar. Makina kodlarý belleðe yerleþir.
Fonksiyonlarýn belleðe yükleme iþleme run time'da fonksiyon çaðýrýldýðýnda yapýlmaz. exe  yerleþtiðinde, çalýþýr haline geldiðinde bir proces haline geldiðinde fonksiyon kodlarý zaten bellekte.
Fonksiyonlarýn kodu tek, instance ile fonksiyon kodu deðiþmez buna constructor da dahil, sonuçta o da bir fonksiyon, kodu var. 

/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	static int msx;
	////
};
int main(){
	Myclass m;
	m.msx = 23; //geçerli
}
/////////////////////////////////////////////////////////////////////
Bazý programlama dillerinde sýnýfýn statik öðelerine member yolu ile eriþim olanaðý yok, dilin sentaksý bunu desteklemiyor.
m.msx = 23; ifadesinde, msx sýnýfýn statik veri elemaný olduðuna göre m instance'ý ile bir alakasý yok. msx'in varlýðý instance'a baðlý deðil.
Böyle bir kod bilerek yazýlmamalý. Yanlýþlýkla bu þekilde eriþilirse sentaks hatasý deðil.
Yukarýdaki string örneðinde str.find('a'); ifadesi düþünüldüðünde, sýnýf görülmüyorsa dilin kurallarýna göre find statik member function da 
olabilir, statik üye fonksiyon dahi olsa bu çaðrý geçerli. 
Nesne yolu ile fonksiyon çaðýrýrken dilin kurallarý statik üye fonksiyonun nokta operatörü ile veya ok operatörü ile çaðýrýlmasýný yasaklamýyor dolayýsýyla yanlýþlýkla böyle bir çaðrý yapýlabilir.


Global deðiþkenlerin bazý sakýncalarý mevcut, bu sakýncalar yüzünden global bir sýnýf nesnesi doðrudan kullanmak yerine onu bir singleton olarak kullanmak yaygýn.
Global nesne olsaydý, main'den önce hayata gelirdi ancak zamaný tam olarak belirli deðil. Farklý kaynak dosyalardaki global varlýklarýn hayata gelme sýrasý dil tarafýndan belirli deðil. Bunlarýn tümü singleton
olsa, fonksiyon ne zaman çaðýrýlýrsa o zaman hayata gelirler. O sýralamanýn artýk programcý tarafýndan yapýlma olanaðý var. GLobal nesnelerin en az iki tane dezavantajý var bunlardan ilki ne zaman hayata gelecekleri
konusunda bir belirleyicilik yok. Diðeri ise exception handling, global nesnenin constructor'ý exception throw ederse bunun yakalanma þansý yok, exception ancak main'in içinde yakalanabilir. GLobal nesne yerine singletion
yapýlýp kullanýlýrsa, singleton'ý ilk kullanan yer bir fonksiyonun kodu olduðundan onun içinde throw edilen exception yakalanabilir.

Meyer's Singleton:
/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
	explicit Counter(int val = 0) : mx{val} {}
public:
	Counter(const Counter &c) = delete;
	
	static Counter &getInstance()
	{
		static Counter c;
		return c;
	}

	Counter &operator++()
	{
		++mx;
		return *this;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	int getValue()const
	{
		return mx;
	}
	Counter &set(int val)
	{
		mx = val;
		return *this;
	}
};
/////////////////////////////////////////////////////////////////////
getInstance fonksiyonunun tanýmýndaki static, C'den bildiðimiz statik, statik yerel deðiþken. Böyle bir deðiþken oluþturmakta herhangi bir illegalite yok, çünkü sýnýfýn statik üye fonksiyonu, constructor private da olsa
onu çaðýrabilir. Fonksiyon bu yerel nesnenin kendisi ile geri dönüyor, otomatik ömürlü olsaydý run-time hatasý olurdu ancak yerel nesne statik ömürlü olduðundan run-time hatasý deðil.
C++'da statik yerel sýnýf nesneleri, ilk çaðýrýldýklarýnda hayata gelirler, yani bu fonksiyon ilk çaðýrýldýðýnda c nesnesi hayata gelir ondan sonraki çaðrýlarda tekrar tekrar hayata gelmez.
Bu fonksiyon ilk kez çaðýrýldýðýnda Counter deðiþken hayata gelir onunla geri dönülür, bir daha çaðýrýldýðýnda ise zaten hayatta olan nesne referans semantiði ile geri döndürülür.
Copy constructor delete edildi böylece kopyalama yolu ile de nesne hayata getirmek engellendi.


Herhangi bir client kod, interface'deki bir fonksiyona çaðrý yaparak, hayatta olan, hayatý devam etmekte olan Myclass nesnelerinin sayýsýný get edebilecek. 
/////////////////////////////////////////////////////////////////////
class Myclass {
	int mx;
	static size_t ms_instance_count;
public:
	Myclass(int val = 0) : mx{val} 
	{
		++Myclass::ms_instance_count;
	}
	Myclass(const Myclass &r) : mx{r.mx}
	{
		++Myclass::ms_instance_count;
	}
	~Myclass()
	{
		--Myclass::ms_instance_count;
	}
	int get()const { return mx; }
	Myclass &set(int val) { mx = val; return *this; }
	void display()const
	{
		std::cout << "(" << mx << ")";
	}
	static size_t getInstanceCount() 
	{ 
		return ms_instance_count;
	}
};

//Myclass.cpp
size_t Myclass::ms_instance_count = 0;

int main() {
	
	srand(static_cast<unsigned>(time(nullptr)));

	auto n = rand() % 20 + 10;

	for (int k = 0; k < n; ++k) {
		auto *p = new Myclass;
		////
	}

	cout << "hayattaki nesne sayisi : " << Myclass::getInstanceCount() << endl;

	Myclass m1{ 45 };
	Myclass m2{ m1 };

	cout << "hayattaki nesne sayisi : " << Myclass::getInstanceCount() << endl;

	auto ptr = new Myclass;

	cout << "hayattaki nesne sayisi : " << Myclass::getInstanceCount() << endl;

	delete ptr;

	cout << "hayattaki nesne sayisi : " << Myclass::getInstanceCount() << endl;

} 
/////////////////////////////////////////////////////////////////////
Sayý, adet söz konusu olduðunda fonksiyon int deðil size_t döndürse daha doðru. size_t bir typedef ismi, keyword deðil dolayýsýyla size_t'yi kullanabilmek için size_t'nin bildirimini içeren bir baþlýk dosyasý include
edilmeli. Standart baþlýk dosyalarýnýn hemen hepsi zaten bunu dahil eder. 
Class memberlara isim verirken verilen isim doðrudan en azýndan statik data member mý yoksa non-statik data member mý bunu göstermeli, global bir isimse global olduðunu göstermeli ve const olup olmadýðýný da göstermeli.
Sýnýfýn ctorlarý, ms_instance_count'u arttýracak, nesne hayata geldiði zaman ctor çaðýrýlacak ancak copy ctor'da ihmal edilmemeli, kopyalama yoluyla nesne hayata geldiðinde de counter artmalý. Her ne kadar bu örnekte
ele alýnmasa da, taþýma semantiði de göz önünde bulundurmalý, bu örnekte sýnýf moveable deðil. Sýnýfa destructor da yazýlmalý, hayata veda eden nesneler için destructor çaðýrýldýðýnda da sayacýn deðerinin bir azaltýlmasý
gerekir.
Bazý programcýlar, sýnýfýn statik veri elemanlarýný, sýnýf içinde kullanýrken sýnýfýn ismi ile nitelerler. Bu konvensiyonu kullanmanýn faydasý, bakar bakmaz bu data memberin statik olduðu anlaþýlabilir.
Çok sýk yapýlan kodlama hatalarýndan biri, normalde sýnýfa copy ctor yazýlmaz ise, derleyici copy ctor yazar. Derleyicinin yazdýðý copy ctor, *this'in bütün non-statik data memberlarýný parametreye referans olarak aktarýlan
nesnenin yani kaynak olarak kullanýlacan nesnenin ilgili memberlarý ile copy construct eder. Copy ctor'u biz yazýyorsak kaç tane member olursa olsun tüm memberlarý bu iþleme sokmak istiyorsak bu artýk bizim sorumluluðumuzda.
Sýnýfýn 5 tane veri elemaný olsun, programcýnýn copy ctor'u kendisinin yazmak istemesinin nedeni, deep copy yapmak(handle'ý yani sadece pointeri kopyalamak yerine pointerýn gösterdiði kaynaklarý birbirine kopyalamak). 
Copy ctor'u yazarken, programcýnýn birinci amacý bu olduðu için bunu yazýyor ancak diðerlerinden birini veya birden fazlasýný unutuyor, Sanki diðerlerini halen derleyici copy construct edecek gibi bir kural varmýþ gibi.
Dilin bu konudaki kuralý beklentilerin dýþýnda, eðer primitif öðelere dokunulmazsa onlar çöp deðeri ile baþlar. mx copy construct edilmezse, hayata copy construct edilerek gelen nesnenin mx'i çöp deðerde kalýr.
Data memberlar, baþka sýnýflar türünden de olabilir. Bu durumda eðer copy ctor programcý tarafýndan yazýlýyorsa sýnýf nesnelerinin de birbirine construct etmesinden programcý sorumlu. Eðer mil sentaksý ile bunlar copy 
construct edilmezse sentaks hatasý alýnmaz ancak bunlar default construct edilir. Sýnýf türünden elemanlar otomatik olarak copy construct edilmez, construct ediliyorlar ancak default construct ile.

/////////////////////////////////////////////////////////////////////
class Employee{
	std::string mname;
	int m_id;
	Date mbdate;
	////
public:
	Employee(const Employee &r) : mname{r.mname}, m_id{r.m_id}
	{
		///
	}
	Employee &operator=(const Employee &r)
	{
		////
		mname = r.mname;
		m_id = r.m_id;
		////

		return *this;
	}
};
/////////////////////////////////////////////////////////////////////
Copy ctor yazýlýrken, mbdate'in copy construct edilmesi unutuldu, bu durum sentaks hatasý deðil.
Bir Employee nesnesi copy ctor yolu ile hayata geldiðinde, mbdate default construct edilir zaten default constructor'ý olmasa sentaks hatasý.
Date sýnýfýnýn default constructor'ýnýn bugünün tarihi ile hayata getirdiði düþünülsün. Bu durumda kopyalama yolu ile Employee nesnesi elde edilmek istendiðinde, doðum tarihleri ayný olmalý ancak mbdate'in copy construct
edilmesi unutulduðundan yaratýlacak olan Employee nesnesinin doðum tarihi bugünün tarihi olmuþ olur.
Ayný tehlike atama operatör fonksiyonun için de geçerli. Kopyalayan atama operatör fonksiyonu derleyiciye býrakýlýrsa derleyici *this'in her bir öðesine atama opeatörünün sað tarafýndaki nesnenin ilgili öðesine atar.
Employee için atama operatör fonksiyonu programcý tarafýndan yazýldýðýnda yine mbdate'in unutulmasý sentaks hatasý deðil, bu durumda mbdate deðeri atanmamýþ olarak eski deðerinde kalýr.
Bu her zaman hata olmak zorunda deðil, bilerek de yapýlmýþ olabilir, bazý öðelerin deðerinin deðiþmemesi gerektiði zaman bilerek yapýlabilir.


9_12_2017 CUMARTESÝ

Sýnýf Çalýþmasý: Hayattaki Fighter sýnýf nesnelerinin birbirleri ile iliþki kurabilecekleri implementasyon; yardým isteme fonksiyonu olsun,bu fonksiyon bir nesne için çaðrýldýðý zaman hayattaki 
bütün savaþçýlardan ismi  ile onlarý çaðýrýp yardým istenecek.    
Ýlk olarak Fighter baþlýk dosyasý oluþturulur.
Bir sýnýfý tasarlarken dýþarýdan içeriye tasarým yapýlmalý, implementasyon düþünülmemeli, elemanlar yok.
Sýnýf tasarlarken birincil öncelik interface tasarlamak.
Fighter sýnýfýnda, her savaþçýnýn bir ismi ve yaþý var. Client'i ilgilendiren savaþçýnýn adý ve yaþý.
Baþlýk dosyasýnda C++'nýn bütün standart öðeleri std namespace'i içinde. String bir sýnýfýn ismi string ismi de std namespace'in içinde. Örnek olarak constructor yazýlýrken:
Fighter(string name); þeklinde yazýlýrsa derleyici string ismini arar ve bulamaz. Ýsmin std namespace'i içinde olduðunu derleyici bu þekildeki yazým ile bilemez. Baþlýk dosyasý deðil, kod dosyasý
olsa idi, using namespace bildirimi ile bu sorun çözülebilirdi. Ancak baþlýk dosyasýnda bir namespace'e ait bir isim kullanýldýðýnda, kullanýlan isim, namespace'in ismi ile nitelendirilir.
Fighter(std::string name); þeklinde yapýlmalý bu durumda derleyici ismi std namespace'i içinde arar, derleyicinin namespace'i görmesi için string sýnýfýnýn tanýmýnýn yapýldýðý baþlýk dosyasý
include edilmeli. String sýnýfý include edildiðinde, fighter.h'yý include eden herkes string baþlýk dosyasýný da include etmiþ olur. Ancak C++'da string'i include etme zorunluluðu da ortadan 
kaldýrýlabilir(pimple idiomu). Pimple idiom'u kullanýldýðýnda, fighter.h ya eklenen baþlýk dosyalarýnýn, fighter.h'yý kullanan clientlar ile iliþkisi kesilebilir.
Fighter(std::string name); þeklinde yazým, call by value. Bu þekildeki yazýmda her Fighter nesnesi yaratýldýðýnda string nesnesi kopyalanýr, bu sebepten constructor:
Fighter(const std::string &name, int age); þeklinde olur. Amaç sadece dýþarýdan ismi almak.
Sýnýf eðer yalnýzca bu ctor yazýlarak býrakýlýrsa, bu durumda client'lar default constructor yolu ile nesne oluþturamaz. Bu yüzden default ctor yazýlmasý derleyiciye býrakýlacak þekilde default
constructor da sýnýfa eklenir.(default edilir)

getName()const; isimli fonksiyon, ismi get eder. C++ öncesi olsaydý std::string getName()const; þeklinde fonksiyon yazmak eleþtirilebilirdi. Çünkü türe geri dönme, copy ctor çaðrýsýný dolayýsýyla 
da kopyalamayý gerektirecekti. C++ ile ise string sýnýfýnýn move constructor'ý olduðu için string'e yada container bir sýnýfa geri dönen bir fonksiyon yazmanýn bir sakýncasý yok. C++11 öncesinde
ise özellikle, verim kritik bir uygulama olsaydý getName(std::string &r); þeklinde bir fonksiyon yazýlýrdý. Bu durumda çaðýran kodun bir string nesnesi göndermesi gerekirdi.
Modern C++'da türe geri dönen fonksiyonlarýn hiçbir ilave maliyeti yok.
 
Bir sýnýf nesnesi yardým istediðinde örnek olarak;
Fighter f2{"Murat", 34}; nesnesi için f2.askHelp(); fonksiyonu çaðrýldýðýnda hayatta olan diðer sýnýf nesnelerine(savaþçýlar) çaðrý yapýlacak.

Sýnýfa veri elemaný olarak, sýnýf nesnelerinin ismini tutacak bir string türünden bir veri elemaný ve yaþ tutacak int türden bir veri elemaný tanýmlanýr.

using bildirimi yapýldýðý için .cpp dosyasýnda std ile niteleme yapýlmasý zorunlu deðil.
Fighter nesnelerinin adreslerini tutacak static veri elemaný olan bir container kullanýlýr.
vector'de hangi türden öðe tutulacaksa açýsal parantez içine o tür yazýlýr. Örnekte vector'de Fighter nesnelerinin adresleri tutulacaðýndan, <> içine Fighter * yazýlýr.
static anahtar sözcüðü, bildirimde kullanýldý, tanýmda yani .cpp dosyasýnda kullanýlmayacak.   

vector<Fighter *> Fighter::smvec; bir sýnýf nesnesi sýnýfýn türü vector<Fighter *>, bu sýnýf nesnesi için default constructor çaðrýlýr. eðer vector sýnýfýnýn default ctoru
olmasaydý zaten sentaks hatasý olurdu.
vector<Fighter *> Fighter::smvec(); þeklinde yazým geçersiz, vexing parse! Nesne tanýmlamasý anlamýna gelmez.
vector<Fighter *> Fighter::smvec{}; þeklindeki yazým ise geçerli. 

Constructor hayata gelen nesnenin adresini bu container'a ekleyecek.
Bunun için vector sýnýfýnýn interface'inde olan push_back() fonksiyonu çaðrýlýr. vector sýnýfý için sondan ekleme yapan fonksiyon puch_back(); fonksiyonu
sm_vec.push_back(this); ifadesi ile her nesne hayata geldiðinde, hayata gelen nesnenin adresi containera eklenir.

Not: cout, cin gibi	global giriþ çýkýþ sýnýflarýný kontrol eden nesneler kullanýlmayacaksa iostream include edilmemeli. Sadece sýnýf kullanýlacaksa ostream baþlýk dosyasý
include edilmeli. bu nesneler kullanýlmayacak sadece sýnýfýn interface'i kullanýlacaksa iosteram yerine, ostream veya istream yeterli olurdu.

cout << "ben savasci" << m_name << "\n"; yerine 
cout << "ben savasci" << getName() << "\n"; þeklinde yazýlmasýnýn sebebi sýnýfýn interface'inde bir deðiþiklik olduðunda kodlarýn tekrardan deðiþtirilmesine gerek kalmamasý.
Optimizasyon açýsýndan ikisi arasýnda bir fark yok.

Not: endl, newline ile eþ deðil. endl != '\n'. endl bir manipülatör, akýma newline veriyor ayný zamanda standart çýkýþ akýmýnýn bufferini flash ediyor.
Akýmýn flash edilmesi istenmiyor sadece newline isteniyorsa o zaman doðrudan newline verilmeli.

Destructor ise hayata veda eden nesnenin adresini container'dan siler.
Destructor için this adresi container'dan silinecek.
Bir container'da belirli bir deðere sahip ilk öðeyi silmek, bir container'da belirli bir deðere sahip öðelerin tamamýný silmek birbirinden farklý iki konsept.
Bir sequence container'da belirli deðere sahip öðelerin tamamýný silmek için remove-erase idiomu kullanýlýr. 
O deðere sahip ilk öðeyi silmek içinse, arama yapýlýr, o deðere sahip ilki bulunur böylece varsa o deðerin konumu elde edilir. Her container sýnýfýn konum bilgisi ile silme
yapan erase adlý fonksiyonu vardýr. Bu fonksiyon çaðrýlarak o öðe silinir.
Sequence containerlarda arama iþlemleri stl'in find algoritmasý ile yapýlýr.
find() fonksiyonunun geri dönüþ deðeri adres deðil, konum bilgisi. Konum bilgisi tutan türlere iterator denir.
bu fonksiyonun geri dönüþ deðerini bir iteratörde tutmak gerekir, C++11 ile auto keywordu kullanýlýp, bildirilen bir deðiþkende tutulur.
Eðer auto olmasaydý vector<Fighter *>::iterator iter = find(sm_vec.begin(), sm_vec.end(), this); yazýlýrdý.
stl'de arama fonksiyonlarý baþarýsýz arama durumunda range'in end iteratörünü döndürür.
Bütün container sýnýflarýnýn iterator parametreli silme fonksiyonlarý var. sm_vec.erase(iterator);
askHelp sýnýfýn non-statik üye fonkiyonu, sýnýfýn statik veri elemanýna eriþebillir.

/////////////////////////////////////////////////////////////////////
//fighter.h
#ifndef FIGHTER_INCLUDED
#define FIGHTER_INCLUDED
#include <string>
#include <vector>

class Fighter(){
	std::string m_name;
	int m_age;
	static std::vector<Fighter *> sm_vec;
public:
	Fighter() = default;
	Fighter(const std::string &name, int age);
	~Fighter();

	std::string getName()const{
		return m_name;
	}

	int getAge()const{
		return m_age;
	}

	void display()const;
	void askHelp();
};
#endif
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
//fighter.cpp
#include "fighter.h"
#include <iostream>

using namespace std;

vector<Fighter *> Fighter::sm_vec;

Fighter::Fighter(const string &name, int age) : m_name{name}, m_age(age) 
{
	sm_vec.push_back(this);
}

Fighter::~Fighter(){

	auto iter = find(sm_vec.begin(), sm_vec.end(), this); // container içinde aranacak deðer this
	if(iter == sm_vec.end()){
		cerr << "hata.." << endl;
		exit(EXIT_FAILURE);
	}
	sm_vec.erase(iter);
}

void Fighter::display()const{
	cout << "ben savasci" << getName() << "\n"; 
	cout << getAge() << "yasindayým" << endl;
}

void Fighter::askHelp(){

	
	for(auto p : sm_vec){	// p, Fighter * türünden
		if(p != this)
			cout << p->getName() << " ";
	}
}

/////////////////////////////////////////////////////////////////////
askHelp fonksiyonundaki range based for loop'da, p döngünün her turunda container'daki öðe türünden. containerda da Fighter *
tutulduðundan p'nin türü de Fighter *

/////////////////////////////////////////////////////////////////////
//main.c
using namespace std;

int main(){
	
	Fighter f1{ "Fethi", 21};
	Fighter f2{ "Murat", 34};

	Fighter *p1 = new Fighter { "Aykut", 16};
	Fighter *p2 = new Fighter { "Necati",70};
	Fighter *p3 = new Fighter { "Arman", 30};

	delete p1;

	f2.askHelp(); //Hayatta olan sýnýf nesnelerine çaðrý yapýldý..

	delete p2;
	delete p3;
}
/////////////////////////////////////////////////////////////////////

RANGE BASED FOR LOOP

for anahtar sözcüðü içerisinde : üstüste atomunun sað tarafýna dolaþmak istenilen container olan nesnenin ifadesi yazýlýr.
Diziler için de geçerli. Döngünün gövesinde i kullanýldýðýnda dizideki öðe kullanýlmýþ olur.
Derleyici "int i = container'daki öðe" þeklinde bir kod üretir. Dolayýsýyla i burda container'daki öðenin kendisi deðil, referansý deðil, referans 
semantiði yok.

/////////////////////////////////////////////////////////////////////
int main(){

	int a[] = {7, 13, 81, 47, 19, 53 , 62, 3, 18, 41};
	
	for(int i : a)
		cout << i << " ";
	cout << endl;

	for(int i : a)
		++i;	// i, container'da tutulan nesnenin kendisi olsaydý, dizinin tüm elemanlarý birer artmýþ olurdu.
	
	for(int i : a)
		cout << i << " ";
	cout << endl;
 }
 /////////////////////////////////////////////////////////////////////

Range based for loop'da döngü deðiþkeninin öðenin kopyalama yoluyla öðeyi alan bir deðiþken olmak yerine kendisi yapmak istenirse referans 
semantiði kullanýlmalý.
/////////////////////////////////////////////////////////////////////
int main(){

	int a[] = {7, 13, 81, 47, 19, 53 , 62, 3, 18, 41};
	
	for(int i : a)
		cout << i << " ";
	cout << endl;

	for(int &i : a)
		++i;	// i, container'daki öðenin kendisi
	
	for(int i : a)
		cout << i << " ";	//dizinin tüm elemanlarý bir artmýþ olur.
	cout << endl;
}
/////////////////////////////////////////////////////////////////////

Range based for loop'da : üstüste atomunun sol tarafýndaki deðer const anahtar sözcüðü ile nitelendirilirse i yine container'daki öðenin kendisi
ancak yalnýzca read-only olarak kullanýlabilir. Container salt okuma amaçlý dolaþýlacaksa const anahtar sözcüðü kullanýlýr.
Bu durumda yanlýþlýkla bir set iþlemi yapýlýrsa error olur.
/////////////////////////////////////////////////////////////////////
int main(){

	int a[] = {7, 13, 81, 47, 19, 53 , 62, 3, 18, 41};
	
	for(int i : a)
		cout << i << " ";
	cout << endl;

	for(const int &i : a)
		;
	
	for(int i : a)
		cout << i << " ";	//dizinin tüm elemanlarý bir artmýþ olur.
	cout << endl;
 }
 /////////////////////////////////////////////////////////////////////

: üstüste atomunun sol tarafýndaki deðer için auto keywordu kullanýlýr. Compile time'da derleyici auto i'yi ilgili containerýn elemanlarý türünden alýr.
Bu durumda 3 farklý idiomatik yapý kurulabilir.

1) for(auto x : c)
		x;		//kopyalama semantiði, döngünün her turunda x'e container'daki öðe kopyalanýr.

2) for(auto &x : c)
		x;		//x, container'daki öðenin yerine geçen referans isim ve set amaçlý dolaþýlacaðý belirtilir.

3) for(const auto &x : c)
		x;		// container yalnýzca okuma amaçlý dönülecekse kullanýlýr.

4) for(auto &&x : c) //container'daki öðelerin kaynaðý çalýnýr(taþýma semantiði)

/////////////////////////////////////////////////////////////////////
int main()
{
	vector<string> svec{ "sinan", "poyraz", "aykut", "arman", "fethi",
						 "huseyin", "murat" };

	for (const auto &i : svec)
		cout << i << " ";
	
	cout << endl;

	
	for (auto &i : svec)
		i += "can";
	

	for (const auto &i : svec)
		cout << i << " ";

	cout << endl;
}
/////////////////////////////////////////////////////////////////////
Bir containerýn tamamý dolaþýlmayacaksa, bunun baþka yollarý mevcut. Range based for loop, containerin tamamýný navigete etmek için
kullanýlýr. Range based for loop, taþýma semantiðini de izin verir. for(auto &&r : svec) gibi bir döngü görüldüðünde, taþýma semantiðinin
devreye girilmesi istenmiþtir. 

Derleyicinin range based for loop için üretmiþ olduðu kod, compile time'da üretilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<string> svec{ "sinan", "poyraz", "aykut", "arman", "fethi",
						 "huseyin", "murat" };

	for (const auto &i : svec)
		cout << i << " ";
	
	// Derleyicinin yukarýdaki range based for loop için compile time'da yazdýðý kod:
	/*
		for(auto iter = svec.begin(); iter != svec.end(); ++iter)
		{
			auto &i = *iter;
			/////
		}
	*/
}
/////////////////////////////////////////////////////////////////////

Döngü kullanmadan 1'den 100'e kadar sayýlarý ekrana yazdýran C++ kodu
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{
		static int x = 1;
		cout << x << " ";
		++x;
	}
};

int main()
{
	Myclass a[100];
}
/////////////////////////////////////////////////////////////////////
Bir dizi oluþturulduðunda, dizinin elemanlarý sýnýf türünden ise derleyici dizinin her elemaný için constructor çaðýrýr.
Derleyici 100 kere constructor'ý çaðýrýr.


ARKADAÞLIK BÝLDÝRÝMLERÝ (FRIEND BÝLDÝRÝMÝ)

Sýnýflarýn private bölümleri, sýnýfýn kendi kodlarý hariç bütün kodlara kapalý. Ancak bazý durumlarda, sýnýfýn kodunu yazan programcý olarak, seçilmiþ bazý kodlara private
bölüme eriþim hakký yetkisi verilmek istenebilir. Bu durumda derleyici bu belirli kodlarýn, sýnýfýn private bölümüne eriþimini compile time'da geçersiz olarak görmez.
Bunu gerçekleþtiren bildirimlere friend bildirimleri denir.
Ortada bu bildirimi gerektirecek bir durum yoksa friend bildirimi yapýlmaz. 
Bu yöntem kullanýldýðýnda, sýnýfýn private bölümünde yapýlan deðiþiklikler, arkadaþlýk verilen kodlarýn da deðiþmesine neden olur.
Belirli durumlarda arkadaþlýk bildirimleri en iyi çözüm olabiliyor. Sýnýfýn private bölümüne eriþim yetkisi olmayan bir koda bu hak tanýnmasý.

C++'da arkadaþlýk bildirimi 3 farklý kategoriye ayrýlýr.
1) Global bir fonksiyona arkadaþlýk vermek. Böylece global fonksiyon içinde o sýnýf türünden öðeler yoluyla sýnýfýn private bölümüne eriþim serbest.
2) Bir baþka sýnýfýn belirli bir üye fonksiyonuna arkadaþlýk vermek. Daha az kullanýlan bir yapý.
3) Bir baþka sýnýfa komple arkadaþlýk vermek. 

Bu kategorilerden hangisine iliþkin olduðuna göre arkadaþllýk bildiriminin sentaksý da deðiþiyor.

/////////////////////////////////////////////////////////////////////
class Myclass{
	void pfunc(); //sýnýfýn private fonksiyonu
public:
	friend void foo(); //global foo() fonksiyonuna arkadaþlýk verilmiþ, derleyicinin foo iþlevinin bildirimini görmesi gerekmez.
};
/////////////////////////////////////////////////////////////////////
Derleyici friend void foo(); ifadesinden global bir fonksiyona arkadaþlýk verildiðini nasýl anlar ?
Sýnýfýn kendine arkadaþlýk vermesi gibi bir durum yok, baþka bir sýnýfa arkadaþlýk verilmiþ olsa idi de sýnýf ismi ile niteldirilmesi gerekir.
Bu yüzden tek seçenek global bir fonksiyona arkadaþlýk verilmiþ olmasý.
Derleyici foo() fonksiyonunun bildirimi ile daha önce karþýlaþmýþ olmak zorunda deðil. Bildirim ayný zamanda böyle bir fonksiyonun varlýðýndan derleyiciyi haberdar eder.
Böyle bir arkadaþlýk bildirimi için derleyicinin arkadaþlýk verilen noktada isim aramasý yapmasý gerekmez.
Bildirimin kendisi fonksiyon ile ilgili derleyiciye verilen ilk bilgi olarak düþünülür.


/////////////////////////////////////////////////////////////////////
class Myclass{
	void pfunc();
public:
	friend void foo(); //global foo() fonksiyonuna arkadaþlýk verilmiþ
};

void foo(){
	Myclass m;
	m.pfunc();	//geçerli, arkadaþlýk verilmemiþ olsa, private bölüme eriþim geçersiz olurdu
}
/////////////////////////////////////////////////////////////////////
arkadaþlýk bildirimi olmamýþ olsaydý, global foo fonksiyonu içerisinde, m nesnesi yoluyla pfunc fonksiyonuna eriþim, pfunc fonksiyonu sýnýfýn private bölümünde olduðundan
geçersiz olurdu.


friend'lik bildirimi verilen global fonksiyonlarýn tanýmý, sýnýfýn içinde inline olarak yapýlabilir.
non-statik member functionlar ve statik member functionlar'a ek olarak friendlik verilen global fonksiyonlar da
sýnýf içerisinde inline olarak tanýmlanabilir.
Bir sýnýfýn public interface'i incelendiðinde, friendlik verilmiþ bir fonksiyon olduðu düþünülsün ancak fonksiyonun tanýmýnda sýnýfýn private bölümüne hiçbir þekilde 
eriþilmemiþ. Her ne kadar arkadaþlýk bildirimlerinin birincil amacý private bölüme eriþim olsa da bazen programcýlar bazý iþlemleri daha da kolaylaþtýrmak için sýrf
bir global fonksiyonu sýnýf içinde tanýmlamak adýna ona arkadaþlýk verirler. Yani friendlik bildirimi sadece private bölüme eriþim hakký vermek için yapýlmýþ olmak
zorunda deðil, friendlik verilen global bir fonksiyonun tanýmý sýnýfýn içinde de yapýlabilir.(tanýmlanabilir ancak tanýmlanmak zorunda deðil.)
/////////////////////////////////////////////////////////////////////
class Myclass{
	void pfunc();
public:
	friend void foo(int x){
		std::cout << x << std::endl;
	}
};
void foo(int); //main'deki çaðrýda ismin aranýp, bulunmasý için.
int main(){
	foo(10);
}
/////////////////////////////////////////////////////////////////////
friend'lik bildiriminin sýnýfýn public veya private bölümünde yapýlmasý arasýnda bir fark yok. Bildirim sýnýfýn private bölümünde de yapýlabilir
public bölümünde de veya protected bölümünde. Bir bildirimin public veya private bölümde yapýlmasý arasýnda fark olmayan ender durumlardan biri.


Bir sýnýfýn baþka bir sýnýfýn üye fonksiyonuna arkadaþlýk verebilmesi için derleyicinin daha önce arkadaþlýk verilen üye fonksiyonun olduðu
sýnýfýn tanýmýný görmesi gerekir. Derleyici Myclass sýnýfý içinde, A sýnýfýnýn fonksiyonuna friendlik verilen bildirimi gördüðünde, A sýnýfýnýn 
tanýmýnýn üstünden geçmiþ olmasý gerekir.
Incomplete type için böyle bir friendlik verme imkaný yok.
/////////////////////////////////////////////////////////////////////
class A{
public:
	void afunc();
};

class Myclass{
	void foo();
public:
	friend void A::afunc(); //A sýnýfýnýn afunc() fonksiyonuna arkadaþlýk verildi.
};

void A::afunc(){
	Myclass m;
	m.foo(); //friendlik bildirimi nedeniyle geçerli
}
/////////////////////////////////////////////////////////////////////


Bir sýnýfýn baþka bir sýnýfa arkadaþlýk vermesinin geçerli olmasý için complete type olmasý gerekmez. 
Derleyicinin, arkadaþlýk verilen sýnýfý görmemesi de geçerli.
Yani derleyici Myclass sýnýfý içinde, A sýnýfýna verilen friendlik bildirimini gördüðünde, A sýnýfýnýn tanýmýný görmemiþ olmasý
geçerli. Burada A sýnýfýnýn tüm üye fonksiyonlarý, Myclass sýnýfýnýn private bölümüne eriþebilir, çünkü arkadaþlýk sýnýfa verildi.
/////////////////////////////////////////////////////////////////////
class Myclass{
	void foo();
public:
	friend class A;
}

class A{
public:
	void f1(){
		Myclass m;
		m.foo();
	}
	
	void f2(){
		Myclass m;
		m.foo();
	}
};
/////////////////////////////////////////////////////////////////////
A sýnýfýnýn B sýnýfýna arkadaþlýk vermesi, A'nýn de B'den arkadaþlýk almasý anlamýna gelmez.
A, B'ye arkadaþlýk vermiþ, B'de C'ye arkadaþlýk vermiþ ise; A, C'ye arkadaþlýk vermiþ sayýlmaz.
A sýnýfýndan B sýnýfý türetilirse, A sýnýfý birtakým sýnýflara arkadaþlýk vermiþse, ondan türetilmiþ olan B sýnýfý bu, sýnýflara
arkadaþlýk vermiþ olmaz. Yani parent class olan A'nýn arkadaþlý verdiði sýnýflar, parent class'ýn private bölümüne eriþebilir
ancak A'dan türemiþ child class'larýn private bölümlerine eriþemezler.


OPERATOR OVERLOADING (ÝÞLEÇ YÜKLEMESÝ)

C'de yapý nesneleri, sadece 4 tane operatörün operandý olabilir.
mydata yapý nesnesi olmak üzere;
&mydata
mydata.
sizeof(mydata)
mydata =		operatörlerinin, opearandlarý olabilir.

C++'da ise operator overloading mekanizmasý ile bir sýnýf nesnesi normalde operandý olamayacaðý operatörlerin operandý olabilir.
Derleyici compile time'da sýnýf nesnelerinin normalde operandý olmadýðý operatörlerin operandlarý olmasý durumunda derleyici bunu compile time'da 
fonksiyon çaðrýsýna dönüþtürür.
Bu dönüþtürme iþlemleri compile time'da yapýldýðýndan bir run time maliyeti yok. Programýn çalýþma verimi, hýzý ile operator overloading'in ilgisi yok.
C++'nýn standart kütüphanesi özellikle þablon kütüphanesi çok büyük ölçüde operator overloading'e dayanýr.

Date1 = Date2++; gibi bir ifadede Date1 ve Date2'nin int türler olduðu düþünülürse, Date2'nin artmamýþ deðeri Date1'e atanýr ve Date2'nin deðeri bir artar.
Date1 ve Date2'nin Date sýnýfý türünden nesneler olduðu düþünüldüðünde artýk ayný durum burada geçerli olacak. Ýki farklý tarih deðerleri birbirine atanýrken
operatörün sað operandýndaki tarih artýk bir sonraki günü gösterir.

String sýnýfý da operator overloadingi çok fazla kullanan sýnýflardan, örnek olarak karþýlaþtýrma operatörleri. C'de yapý nesneleri karþýlaþtýrma operatörlerinin
operandý olamaz, ancak C++'de bir sýnýfýn nesneleri karþýlaþtýrma iþlemine konu olacak nesnelerse karþýlaþtýrma operatörleri overload edilerek client kodun iþi
kolaylaþtýrýlabilir.


/////////////////////////////////////////////////////////////////////
#include <string>
#include <iostream>
using namespace std;
int main(){
	string s1{"alican"}, s2{"velican"};

	if(s2 > s1){	  // > operatörü overload edilmiþ, operandlarý sýnýf nesnesi
		s2[2] = 'x';  // [] operatörü bir sýnýf nesnesini operand almýþ
		s1 += ".txt"; // sýnýf nesnesi += operatörünün operandý olmuþ
	}
}
/////////////////////////////////////////////////////////////////////

C++'da operator overloading aracý kendi içinde iki kategoriye ayrýlýr:
1) Bir operatörün operandý olma ifadesinin derleyicinin global bir fonksiyona yapýlan çaðrýya dönüþtürmesi.
2) Sýnýf nesnesinin bir operatörün bir operandý olmasý ifadesinin, derleyicinin bir üye fonksiyona yapýlan çaðrýya dönüþtürmesi.

Operatörün operandý olmasý durumunda global bir fonksiyona yapýlan çaðrýya dönüþtürme varsa çaðrýlan bu global fonksiyonlara, global operatör
fonksiyonlarý denir.(global operator function)
Bir sýnýfýn üye fonksiyonuna yapýlan çaðrýya dönüþtürme varsa çaðrýlan böyle fonksiyonlara üye operator fonksiyonlarý denir(member operator function)

Bir operatör yüklemesi olabilmesi için, bir operatörün en az bir operandýnýn sýnýf türünden olmasý gerekir.
Unary bir operatörün tek operandý primitif türdense veya binary bir operatörün her iki operandý da primit türdense, derleyicinin böyle bir ifadeyi fonksiyon
çaðrýsýna dönüþtürme olanaðý yok.

Dilin kurallarýna göre her operatör overload edilemez. Bazý operatörler için fonksiyon yazmak tanýmlý deðil. Overload edilemeyen operatörler de mevcut:
koþul opereatörü(ternary op.)
nokta operatörü
çözünürlük operatörü
.* operatörü
sizeof operatörü
new operatörü
delete operatörü	  
typeid			overload edilemez.
 
Bazý operatörler yalnýzca üye operatör fonksiyonu olarak overload edilebilirler.(Global operatör fonksiyonu olamazlar)
iþlev çaðrý operatörü
ok operatörü
köþeli parantez operatörü,		global operatör fonksiyonu olamazlar.

Operatör overloading mekanizmasýnda operatörlerin arity'si deðiþtirilemez yani Operatörlerin binary mi unary mi olduklarý deðiþtirilemez.

x + y;
Global operatör fonksiyonlarý söz konusu olduðunda, x ve y sýnýf nesneleri ve toplama operatörü global bir operatör fonksiyonu olarak 
yazýlmýþ ise bu durumda derleyici her iki operandý da ilgili fonksiyona argüman olarak gönderir.
Bu durumda binary operatörler, global operatör fonksiyonlarý olarak overload edildiklerinde fonksiyonun 2 tane parametre deðiþkeni olur.
Compile time'da kontrol edilir. Yani x ve y'nin Myclass sýnýfý türünden olduðu düþünülürse, Myclass sýnfýnýn toplama operatör fonksiyonu
global operatör fonksiyonu olarak yazýlacaksa 2 parametreli olmasý gerekir. Bunun dýþýndaki parametrik yapý sentaks hatasý.
x Myclass sýnýf nesnesinin, !(lojik deðil) operatörünün operandý olmasý durumunda derleyicinin bunu global bir fonksiyona çaðrýya dönüþtürmesi
durumunda, fonksiyonun tek bir parametresi olur.
Operatörün operandý olan ifade söz konusu fonksiyona doðrudan argüman olarak geçilir.
operator>(x,y);  //x>y 
operator!(x);	 //!x

Binary bir operatör member operatör fonksiyonu olarak overload edildiðinde fonksiyon her zaman sol operand olan sýnýf nesnesi için çaðrýlýr.
*this binary operatörün sol operandý olur. Fonksiyon bu nesne için çaðrýlýr, binary operatörün sað operandý da söz konusu fonksiyonun parametre
deðiþkenine gönderilen argüman olur.
x.operator>(y);	 //x>y
x.operator!();	 //!x

Binary operatörler global operatör fonksiyonu olarak overload edildiðinde iki parametreli bir fonksiyon yazýlýr.
Üye operatör fonksiyonu olarak yüklendiklerinde ise tek parametreli  bir fonksiyon yazýlýr.

Unary operatörler global operatör fonksiyonu olarak yüklendiðinde tek parametreli bir fonksiyon yazýlýr.
Üye operatör fonksiyonu olarak yüklendiklerinde ise parametre deðiþkeni olmayan fonksiyon yazýlýr.

+ (iþaret operatörü + unary, toplama operatörü + binary)
- (iþaret operatörü - unary, çýkartma operatörü - binary)
& (unary operatör & adres operatörü, binary operatör & bitsel ve operatörü)
* (unary * operatörü dereference, binary * operatörü çarpma operatörü)	
operatörleri iki ayrý operatör görevinde olduklarýndan bu operatörler binary olarak da unary olarak da overload edilebilirler.
Ýki parametreli operator& fonksiyonu global olarak tanýmlanýrsa, bitsel ve operatörü overload edilmiþ olur. Tek parametreli olsa idi adres operatörü
overload edilmiþ olurdu. Buna uyulmayan durumlar sentaks hatasý.
 
 /////////////////////////////////////////////////////////////////////

	bool operator>(const A &, const A &); //geçerli
	bool operator>(const A &); //geçersiz
	bool operator!(const A &); //geçerli
	bool operator!() //geçersiz

class A{
	bool operator!(const A &); //geçersiz
	bool operator!(); //geçerli
	bool operator>(); //geçersiz,
	bool operator>(A,A); //geçersiz
	bool operator>(A); //geçerli
};
/////////////////////////////////////////////////////////////////////


10_12_2017 PAZAR

1) Bir operatörün tüm operandlarýnýn doðal türlerden olmasý durumunda operatör overloading olamaz.
2) Olmayan operatör yüklenmez.
3) Bazý operatörler overload edilemez. koþul, sizeof, nokta, nokta yýldýz, çözünürlük, new, delete, typeid
4) Fonksiyon çaðrý operatörü, ok operatörü ve köþeli parantez operatörü, global operatör fonksiyon olamaz.
5) Bu fonksiyonlara keyfi olarak isim verilemez. Kullanýlack fonksiyonlarýn isimleri dilin kurallarýna uymak zorunda.
   operator anahtar sözcüðünü içermek zorunda.
/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	RT operator+()const; //iþaret + opeatörü
	RT opeator+(const Myclass &r)const; //toplama operatörü + 
	RT operator()(); //fonksiyon çaðrý operatörü
}; //RT : return type (geri dönüþ deðeri)
/////////////////////////////////////////////////////////////////////
Fonksiyon çaðrý operatörünü overload eden sýnýflara C++'da functor sýnýf denir.

6)Operatörlerin unary mi, binary mi olduklarý deðiþtirilemez, operatörlerin artiysine uyulmak zorunda.
x ve y sýnýf nesneleri olmak üzere, > operatörü düþünüldüðünde söz konusu sýnýf için global düzeyde overload edilmiþse aslýnda
derleyici x > y gibi bir ifadeyi operator>(x,y) fonksiyonuna çaðrýya dönüþtürür, bu durumda fonksiyonun iki tane parametre
deðiþkeni olmalý. Ancak söz konusu operatör sýnýfýn üye operatör fonksiyonu olarak overload edilmiþse, üye operatör fonksiyonlarý
binary operatörler için her zaman sol operand olan nesneyi *this olarak alýp fonksion çaðrýsý yapar. Bu durumda derleyici x > y 
ifadesini x.operator>(y) fonksiyon çaðrýsýna dönüþtürür.
Unary operatörler düþünüldüðünde, eðer global operatör fonksiyonu olacaksa zaten unary operatörün operandý bu global fonksiyona
argüman olarak gönderilir. Üye operatör fonksiyonu olarak overload edilecekse, örneðin !x ibi bir ifade düþünüldüðünde derleyici
bunu x.operator!() fonksiyonuna yapýlan çaðrýya dönüþtürür. Global operatör fonksiyonu !x ifadesi için overload edildiðinde ise
derleyici bunu operator!(x) ifadesine dönüþtürür.
Binary operatörleri yükleyen global fonksiyonlar iki parametreli, unary operatörleri yükleyenglobal fonksiyonlar tek parametreli
olmak zorunda buna uyulmamasý sentaks hatasý.
Binary operatörleri yükleyen üye fonksiyonlar bir parametreli, unary operatörleri yükleyen üye fonksiyonlar parametresiz olmak
durumunda yine buna uyulmamasý durumu sentaks hatasý.

Not: Ýstisnasýz bütün operatör fonksiyonlarý isimleri ile çaðrýlabilir, bunun ile ilgili bir engel yok ancak çok özel durumlar dýþýnda 
isimleri ile çaðýrýlmalarý tercih edilmez. Zaten mekanizmanýn ana faydalarýndan biri bu.
/////////////////////////////////////////////////////////////////////
int main(){

	string s1{"jale"}, s2{"tacettin"};

	s1 += s2;		//s1.operator+=(s2)

	if(s1 > s2)		//operator>(s1,s2); global fonksiyon
		cout << s1 << endl;		//operator<<(cout,s1).operator<<(endl); global fonksiyon, member fonksiyon
}								//önce global leftshift ardýndan, member leftshift fonksiyonu çaðrýlýr, << left associative
/////////////////////////////////////////////////////////////////////


7) Bir operatör overloading global fonksiyonla ve member fonksiyonla yapýlabilir ancak statik member function ile operator overloading yok.
Ýsmi operator keywordunu içeren statik üye fonksiyon yazýlamaz.(sadece iki istisnasý var):
operator new ve operator delete fonksiyonlarý dýþýndaki tüm fonksiyonlar non-statik olmalý.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	bool operator<(const Myclass &, const Myclass &);  //geçersiz
}
/////////////////////////////////////////////////////////////////////
Bu haliyle geçersiz çünkü binary bir operator overload edildiðinden ve üye operatör fonksiyonu yazýldýðýndan tek parametreli olmasý gerekir.
Bu ifadeyi geçerli kýlmak için 2 farklý yol mevcut, ilki ikinci parametreyi silmek ikincisi ise;
friend bool operator<(const Myclass &, const Myclass &); //geçerli
þeklinde bildirilmeli bu durumda fonksiyon sýnýfýn member function'ý deðil.
Kendi member function'ýna arkadaþlýk vermeyeceði için, bu fonksiyon global bir fonksiyondur. Global fonksiyon olduðundan iki parametreli olmasý geçerli.
static bool operator<(const Myclass &, const Myclass &);  //geçersiz, statik üye fonksiyon operator fonksiyonu olamaz
Yanlýzca operator new ve operator delete fonksiyonlarý statik olmak zorunda.

Fonksiyon çaðrý operatör fonksiyonu dýþýndaki operatör fonksiyonlarý varsayýlan argüman alamaz.
/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	int operator()(int x = 10); //geçerli
}
/////////////////////////////////////////////////////////////////////

Operatör önceliði ve öncelik yönü deðiþtirilemez.
Operatör öncelik kurallarý, operator overloading mekanizmasý için de geçerli;
bool f = m1 * m2 + m3 > m4;
bool f = operator>(operator+(operator*(m1, m2), m3), m4); //tüm operatör fonksiyonlarýn global olmasý durumunda 
bool f = m1.operator*(m2).operator+(m3).operator>(m4);	  //tüm operatör fonskyionlarýn member function olmasý durumunda
Karþýlaþtýrma üye fonksiyon, çarpma ve toplama global operatör fonksiyon ise:
bool f = operator+(operator*(m1, m2), m3).operator>(m4);


Neden hem global hem de member operatör fonksiyonlarý var?
x ve y sýnýf nesnesi ise x+y; member operatör fonksiyonu olduðunda x.operator+(y); þeklinde çaðrýlýr.
Binary operatörlerin her iki operandý da her zaman sýnýf türünden olmak zorunda deðil. 
x sýnýfý için x+5; ifadesi de anlamlý ve o sýnýf için kullanýlan bir ifade olabilir. Örnek olarak x big integer sýnýfý türünden bir
nesne olabilir. Bu durumda bu big integer nesnesi ile normal integer da toplanabilir. Bu da operatör fonksiyonu ile yapýlabiliyor olsun.
Member operatör fonksiyoný olmasý durumunda x.operator+(5) çaðrýsý yapýlýr, fonksiyonun parametresinin türü int türden olur. 
Big integer bir nesne ile bir integer toplanabildiðine göre, bir integer ile bir big integer nesne de toplanabilmeli, yani 5+x;
ifadesi de geçerli olmalý. Ancak bunun member operator function ile yapýlma imkaný yok. Çünkü binary operatörleri overload eden
member operatör fonksiyonlarý her zaman sol operand olan nesne için çaðrýlmalý. 5 ise bir class object olmadýðýndan bunun 5.operator+()'ya
dönüþtürülmesi mümkün deðil. Bu durumda x+5; þeklindeki bir kullaným member operator function ile yapýlabilmesine karþýn 5+x;
gibi bir ifadenin member operator function kullanýlarak yapýlabilmesinin yolu yok. Binary bir operatörün sol operandý bir sýnýf 
türünden deðil ancak sað operandý bir sýnýf türünden olmasý durumunda bunun bir fonksiyon çaðrýsýna dönüþtürülmesi isteniyorsa
bunun tek yolu global operatör fonksiyonu kullanmak. 


/////////////////////////////////////////////////////////////////////
class Date{};
int main(){
	Date mydate;
	cout << mydate << endl;
}
/////////////////////////////////////////////////////////////////////
Date sýnýfý türünden bir nesne olduðunda cout << mydate << endl; ifadesinin geçerli olmasý isteniyor. 
Burada operator overloading kullanýlmak zorunda. Birinci ihtimal bu iþi yaptýracak fonksiyon cout'un ait olduðu sýnýfýn member
operator fonksiyonu olacak ancak o sýnýf programcýnýn yazdýðý bir sýnýf olmadýðýndan bu mümkün deðil. O sýnýfa böyle bir 
fonksiyon eklemenin yolu yok. Ancak bu durumda global operatör fonksiyonu yazýlabilir. Global operatör fonksiyonu olmasaydý
daha önceden yazýlmýþ sýnýflarýn daha sonradan yazýlmýþ, yazýlacak sýnýflarla ilgili operatörlerin karþýlýklý operandý olmasý
mümkün olmazdý. Bunu legal kýlan global opeatör fonksiyonlarýnýn olmasý.


Operatör fonksiyonlarýnýn geri dönüþ türleri için sentaks açýsýndan bir kýsýtlama yok, lojik açýdan bir kýsýtlama mevcut.
Operatör fonksiyonlarýnýn geri dönüþ deðerlerinin türü, dilin kurallarýna göre mantýksal bir þekilde seçilmeli. Operatör fonksiyonlarýnýn
geri dönüþ deðerlerinin türü, fonksiyonun iþlevine göre primitif türlerden veya sýnýf türünden olabilir. Operatörün ürettiði deðer l-value 
expression olacaksa o zaman fonksiyonun geri dönüþ deðerinin de referans olmasý gerekir. Operatörün ürettiði deðer l-value deðil de r-value 
expression ise o zaman kesinlikle referans döndürmemesi veya const referans döndürmesi gerekiyor. Fonksiyonun geri dönüþ deðerinin hangi türden 
olmasý, l-value yani referansa geri dönecek olmasý veya r-value expression olmasý yani türe geri dönecek olmasý, programýn lojik yapýsýyla ilgili.
C++11 öncesi türe geri dönen operatör fonksiyonlarý kopyalamaya neden olmaktaydý. Taþýma semantiðinin dile eklenmesi ile beraber geri
dönüþ deðerinin sýnýf türünden olmasý maliyeti olan bir iþlem olmaktan çýktý.
Operatör fonksiyonlarýnýn referans geri dönmesi sentaks açýsýndan legal ancak semantik açýdan doðru deðil.
Örnek olarak C++11 öncesinde matris sýnýfý için kopyalama yapmamak adýna referansa geri dönmesi istenen bir operator+() fonksiyonu
yazýlmak istense bile referansa geri dönecek þekilde yazýlamazdý. Her ne kadar referans semantiði ile geri dönmek kopyalama maliyetini
düþürecek olsa dahi referansa geri dönen operatör fonksiyonu yazýlmazdý. Referans bir nesnenin yerine geçmesi demek, bu durumda referans 
hangi nesnenin yerine geçecekti?

1)Otomatik ömürlü bir nesne ile geri dönülmesi durumu
/////////////////////////////////////////////////////////////////////
class Matrix{
public:
	Matrix &operator+(const Matrix &r1){
		Matrix retval;

		return retval;
	}
};
/////////////////////////////////////////////////////////////////////
Referansa geri dönen bir fonksiyonun, otomatik ömürlü bir nesne ile geri dönmesi; adrese geri dönen bir fonksiyonun otomatik ömürlü bir nesnenin
adresiyle geri dönmesinin referans karþýlýðý. Ýkisi de run time error.

2)Dinamik ömürlü nesne ile geri dönülmesi durumu
/////////////////////////////////////////////////////////////////////
class Matrix{
public:
	Matrix &operator+(const Matrix &r1){
		Matrix *p = new Matrix;

		return *p;
	}
};
/////////////////////////////////////////////////////////////////////
Bu yapý da olamaz çünkü bu durumda geri dönülen nesne delete edilmemiþ olur. Her operatör çaðrýsýnda dinamik nesne hayata gelir ancak bu hayata
gelen dinamik nesnelerin delete edilmemesi de bu yapýyý yalnýþ kýlar.

3)Statik ömürlü nesne ile geri dönülmesi durumu
/////////////////////////////////////////////////////////////////////
class Matrix{
public:
	Matrix &operator+(const Matrix &r1){
		static Matrix retv;

		return retval;
	}
};
/////////////////////////////////////////////////////////////////////
Statik ömürlü nesne ile geri dönen fonksiyon ayný nesneyi döndürür. m1 + m2; iþlemi yapýlacak olursa bu ifadenin deðeri fonksiyon içindeki statik
yerel nesne. Bu deðere m3 eklenirse yani m1 + m2 + m3 yapýlýrsa tekrar üstüne yazýlýr.

Bu 3 yapý da geçersiz olduðundan C++11 öncesi referansa geri dönen operatör fonksiyonlarý yoktu. Kopyalama yapýldýðýndan dolayý türe geri dönen
operatör fonksiyonlarý programýn aðýr çalýþmasýna neden oluyordu. C++11 ile birlikte dile eklenen taþýma semantiði ile birlikte türe geri dönen 
operatör fonksiyonlarýnda kopyalama deðil taþýma yapýldýðýndan verim açýsýndan varolan problem ortadan kalkmýþ oldu.

*ptr; ifadesinde içerik operatörünün doðal çaðrýþýmý verilen adresteki nesneye eriþmek. ptr'nin unique ptr sýnýfý türünden bir nesne olduðu, gerçek 
bir pointer olmadýðý düþünülürse, bu ifadede operator overloading olmak zorunda. içerik operatörü aldýðý adresteki nesneye eriþtiðine göre ayný
semantik yapýnýn korunmasý için bunun da bir l-value expression olmasý gerekir. Bu durumda operator* fonksiyonunun geri dönüþ deðerinin türü mecbur
referans olmak zorunda. Yani fonksiyonun geri dönüþ deðerinin hangi türden olacaðý, l-value expression yani referansa mý geri döneceði yoksa türe mi 
geri döneceði yani r-value expression mý olacaðý tamamen programýn lojik yapýsý ile ilgili.

Örnek olarak Date sýnýfý düþünüldüðünde, Date sýnýfý için karþýlaþtýrma operatör fonksiyonlarý yazýlýrken, bu fonksiyonlarýn geri dönüþ deðerlerinin
türü bool olmalý. Sýnýf için arkadaþlýk bildirimi de verilmiþ olan;
friend operator-(const Date &r1, const Date &r2); gibi bildirimi yapýlmýþ olan bir çýkartma operatör fonksiyonu olduðu düþünüldüðünde(iþlevin amacý
iki tarihin birbirinden çýkartýlmasý sonucunda elde edilen aradaki gün farký), ifadenin deðeri aradaki gün farký olduðundan, fonksiyonun geri dönüþ
deðerinin türü lojik açýdan int olmalý.
Bir tarih ile bir tamsayýnýn toplandýðý düþünüldüðünde, sonucunda yine bir Date nesnesi elde edilir;
Date operator+(int day); sonucunda yine bir tarih elde edileceðinden fonksiyonun geri dönüþ deðerinin türü yine Date türünden olmalý.


Operatör fonksiyonlarýnýn parametrik yapýsý yazýlýrken, fonksiyon çaðrýlarýnda gereksiz kopyalamadan kaçýnýlmalý.
C++11 öncesinde de sonrasýnda da fonksiyonun parametresi özel durumlar dýþýnda sýnýf türünden yapýlmamalý.
Özellikle kaynak kullanan sýnýflar söz konusu olduðunda kopyalamaya sebep olacaðýndan, fonksiyon parametresi sýnýf türünden yapýlmaz.
Parametrik yapýda referans semantiði kullanýlýr. T bir sýnýf türü ise fonksiyonlarýn parametreleri T & veya const T & olmalý.
T & mý const T & mý olacaðý referansa çekilen nesnenin okuma amaçlý mý yoksa yazma amaçlý mý kullanýlacaðýna baðlý. 
a + b; ifadesi için a ve b sýnýf nesneleri, toplama operatörü operandlarýný deðiþtirmez, bu bir global operatör fonksiyonu olsaydý; a ve b
matris sýnýfý türünden nesneler olsaydý, parametreler const Matrix & türünden olmalýydý.(çünkü a ve b deðiþmez)
a ve b yine matris nesneleri, fakat bir nedenden dolayý bu operatör fonksiyonu sýnýfýn üye operatör fonksiyonu yapýlmýþ. Bu iþlemde yine a ve
b deðiþmez, bu durumda parametreye çekilen b için const Matrix & parametrik yapýsý kullanýlmalý. a nesnesi ise *this olduðundan a'nýn deðiþmemesini
gösterip, bunu garantiye alan ise bu operatör fonksiyonunun const üye fonksiyon olmasý.
/////////////////////////////////////////////////////////////////////
class Matrix{
public:
	friend operator+()(const Matrix &r1, const Matrix &r2);
	Matrix operator+(const Matrix &r)const;
};
/////////////////////////////////////////////////////////////////////
Ýki matris sýnýfý nesnesinin toplanacaðý operator+() fonksiyonu için, sýnýf nesneleri salt okuma amaçlý kullanýlacaðýndan parametrik yapýda sýnýf nesneleri için
const anahtar sözcüðü kullanýlýr. Eðer global bir fonksiyon ise iki sýnýf nesnesinin de deðiþtirilmeyeceðinin garantisi olarak her iki parametre de const olarak 
nitelendirilir. Ancak böyle bir fonksiyon member operator function olarak yazýlýrsa, tek parametre alacaðýndan dolayý, operatörün saðýndaki operandýn deðiþmeyecek
olmasý parametrik yapýda o sýnýf nesnesi için const olarak nitelendirilmesi ile saðlanýr. Operatörün sol operandý olan yani fonksiyonu çaðýran nesne, *this nesnesinin
deðiþmeyeceði garantisini vermek için ise operatör fonksiyonu, const olarak nitelendirilir.

Global Operatör Fonksiyonu mu ? Üye Operaöt Fonksiyon mu ?
Önceki Big Integer sýnýfýn örneði düþünüldüðünde, bu sýnýfa dair x + 5; gibi bir iþlem üye operatör fonksiyonu ile yapýlabiliyor ancak 5 + x; gibi bir iþlem yapýlamaz.
Her ikisi de yapýlmak isteniyorsa birinin üye operatör fonksiyon diðerinin ise global operatör fonksiyon yapýlmasý iyi bir fikir deðil. Bu durumda her ikisinin de 
çaðrýlmasý söz konusu olabilir, bu da ambiguity hatalarýna yol açar. Birbirlerine karþý bir seçicilikleri yok o yüzden bu yol tercih edilmemeli. Bu durumda bu fonksiyon
global operatör fonksiyonu olarak yazýlmalý.
Binary simetrik operatörleri her zaman global operatör fonksiyonu olarak overload edilmeli. 
Simetrik olmayan binary operatörler sýnýfýn üye operatör fonksiyonlarý yapýlýr. Mesela += operatör fonksiyonu için, binary ancak simetrik deðil.
*this'i deðiþtiren, nesneyi deðiþtiren bütün fonksiyonlar member operatör fonksiyon yapýlýr. Yan etki yaratan operatörlere karþýlýk gelen operatör fonksiyonlarý dilin
kurallarý müsaade etse de global operatör fonksiyon yapýlmaz.(++, --, ...)


/////////////////////////////////////////////////////////////////////
/////integer.h/////
#pragma once
#include <iosfwd>

class Integer{
	int mval;
public:
	explicit Integer(int val = 0) : mval{val} {} //bir integer kesinlikle otomatik olarak bir int'e, double'a dönüþmeyecek(explicit)
	
	friend bool operator<(const Integer &r1, const Integer &r2){
		
		return r1.mval < r2.mval;
	}
	  
	friend bool operator<=(const Integer &r1, const Integer &r2){
	
		return !(r2 < r1);
	}  
	friend bool operator>(const Integer &r1, const Integer &r2){
	
		return r2 < r1;
	}  
	friend bool operator>=(const Integer &r1, const Integer &r2){
	
		return !(r1 < r2);
	}  
	friend bool operator==(const Integer &r1, const Integer &r2){
	
		return !(r1 < r2) && !(r2 < r1);
	}  
	friend bool operator!= (const Integer &r1, const Integer &r2){
	
		return (r1 < r2) || (r2 < r1);
	}  

	Integer &operator+=(const Integer &r)
	{
		mval += r.mval;

		return *this;
	}

	friend Integer operator+(const Integer &r1, const Integer &r2)
	{
		Integer temp{ r1 };

		temp += r2;

		return temp;
	}
	friend Integer operator-(const Integer &, const Integer &);
	friend Integer operator*(const Integer &, const Integer &);
	friend Integer operator/(const Integer &, const Integer &);
	friend Integer operator%(const Integer &, const Integer &);

	Integer operator+()const; //iþaret operatörü
	Integer operator-()const; //iþaret operatörü 
	Integer &operator+=(const Integer &r){  //*this'i deðiþtirdiðinden global olamaz, atama operatör old. geri dönüþ deðeri l-value expr, geri dönüþ deðeri referans
	
		mval += r.mval;
		return *this;
	}
	Integer &operator-=(const Integer &);
	Integer &operator*=(const Integer &);
	Integer &operator/=(const Integer &r){
	
		if(r.mval == 0){
			throw DivideByZeroError{};
		}	

		return mval /= r.mval;
	} 
	Integer &operator%=(const Integer &);

	Integer &operator++(); //prefix
	Integer operator++(int); //postfix
	Integer &operator--(); //prefix
	Integer operator--(int); //postfix

};
/////////////////////////////////////////////////////////////////////
myint, Integer türünden bir nesne olduðunda, cout << myint; ifadesini geçerli kýlabilmek için bir operatör fonksiyonuna ihtiyaç var. Bunun üye operatör fonksiyonu olma 
þansý yok çünkü cout'un dahil olduðu sýnýfýn kodu bizim tarafýmýzdan yazýlmadý.
User defined türlerin nesnelerinin deðerlerini çýkýþ akýmlarýna yazdýrmak amacýyla overload edilen operator<< fonksiyonlarýna C++'da inserter denir. 
Bu tip kütüphanelerde tipik beklenen fonksiyonlardan biri inserter fonksiyonlar.
Eðer ostream, istream, ifstream, ofstream gibi formatlý giriþ-çýkýþ sýnýflarý kullanýlacaksa(baþlýk dosyasýnda), bu durumda bu sýnýflarýn(sýnýf þablonlarý) normalde
baþlýk dosyasý ostream, istream fakat bunlar template sýnýf kodlarý olduðundan bu baþlýk dosyalarý heavy yani çok fazla kod var. Dolayýsýyla compile time'da derleyicinin
daha fazla çalýþtýrmasýný gerektirir. Bunu engellemek için ismi iosfwd olan bir header oluþturulmuþ, bu baþlýk dosyasý içinde giriþ-çýkýþ sýnýflarýnýn forward declarationlarý
var. Böylece eðer ostream, istream gibi sýnýflar sadece incomplete type olarak, Integer örneðinde olduðu gibi sadece fonksiyonlarýn bildirimlerinde kullanýlacaksa boþ
yere kodu büyük olan baþlýk dosyalarý dahil edilmemeli. 
leftshift operatörünün ve rightshift operatörününü overload edilmesi ile oluþan interface, sadece standart output ve input için deðil hangi akýma yazma yapýlýrsa yapýlsýn kul-
lanýlýr(bu dosya veya bellek olabilir)

Not: C'de öðrenilenlere dair not(aþaðýdaki C kodu)
/////////////////////////////////////////////////////////////////////
struct Data;

struct Data *foo(struct Data *);
inline struct Data *func(struct Data *p)
{
	return foo(p);
}
/////////////////////////////////////////////////////////////////////
func fonksiyonunun bildiriminin legal olmasý için struct Data'nýn complete type olmasý gerekmiyor.
struct Data incomplete type, func fonksiyonunun tanýmý inline ve bir sentaks hatasý yok. Eðer fiilen bir nesne kullanýlmýyorsa bu örneltei gibi, incomplete type ile 
kod yazýlabilir. Ancak bu fonksiyonun iþini yapabilmesi için struct Data türünden bir nesne oluþturmasý gerekseydi olmazdý o zaman type'in complete olmasý gerekirdi. 

stl, user defined türler söz konusu olduðunda en önemli karþýlaþtýrma operatörleri < ve == operatörü. Bu ikisinin stl'de özel anlamý var, birçok þablon þablonda kullanýlacak
türün bu operasyonlarý desteklediði varsayýmý ile yazýlýr. Bir sýnýf türünden nesne bir sette tutulmak isteinyorsa set'in mecbur küçüktür operatörü olacak. find algoritmasý
ile arama yapýlacaksa aramaya konu nesneye iliþkin türün =='i desteklemesi gerekir.	

C'de de C++'da da iþaret operatörleri ile oluþturulmuþ ifadeler l-value expression deðildir, bu semantik yapýyý korumak için iþaret + ve iþaret - operatörleri
overload edilirken geri dönüþ deðeri türü referans olmaz.

Ýþlemli atama operatörleri bildirilirkeni fonksiyonlarýn geri dönüþ deðerlerinin türü Integer & olmalý. Bu da bir atama operatör olduðundan(C'deki gibi) geri dönüþ deðerinin
l-value olmasý gerekiyor, bunun için de fonksiyonun geri dönüþ deðerinin türü Integer & olmalý.

++ ve -- operatörlerinin ön ek ve son ek olmasý durumunda ayrýmý yapmak için operatörler ön ek durumunda ise fonksiyon parametresiz þekilde yazýlýr.
Son ek olmasý durumunda ise, fonksiyon dummy int türden parametre alýr.
C++'da ön ek konumundaki ++ ve -- operatörleri l-value expression oluþturur. Bunu semantiðe aktarmak için ön ek ++ ve -- operatörlerinin geri dönüþ deðeri o türden
referans yapýlýr. Son ek ++ ve -- operatörlerinin geri dönüþ deðeri türü , o türden yapýlýr. 
(C++'da ++x l- value expression, x++ ise r-value expression)

operator<() fonksiyonu düþünüldüðünde, fonksiyon friend olarak bildirilmeseydi sentaks hatasý olurdu. operator<() global bir fonksiyon eðer ki friend bildirimi olmasaydý
fonksiyon içinde mval'e eriþim, mval sýnýfýn private veri öðesi olduðundan geçersiz olurdu.(global fonksiyonlar sýnýflarýn private bölümlerine eriþemez, ancak arkadaþlýk
bildirimi sayesinde mümkün, C++'da arkadaþlýk bildirimlerinin kullanýldýðý en sýk yerlerden biri) 
Bu fonksiyon friend olmasa zaten sýnýfýn içinde tanýmlanamazdý, sýnýfýn dýþýnda integer.h'da tanýmlanabilirdi. Ancak o durumda da mval'in kullanýmý geçersiz çünkü private
data member.

Tipik bir kodlama idiomu, stl de bunu kullanýr:
Karþýlaþtýrma operatörlerinin implementasyonu yapýlýrken küçüktür operatör fonksiyonu yazýldý, diðer operatör fonksiyonlarý yazýlýrken, operatör küçüktür fonksiyonu
kullanýldý. Operatör küçüktür fonksiyonu return r1.mval < r2.mval; þeklinde yazýldý. Operatör büyüktür fonksiyonu ise return r1.mval > r2.mval; þeklinde yazýlmak yerine
return r2 < r1; þeklinde operatör küçüktür fonksiyonu baz alýnarak yazýldý. Bu þekilde yapýlmasýnýn sebeplerinden biri, sýnýfýn implementasyonunda bir deðiþiklik yapýlmasý
durumunda, deðiþikliðin tüm fonksiyonlarda yapýlmasý yerine yalnýzca küçüktür fonksiyonunda yapýlmasý. Baþka bir sebebi ise:
/////////////////////////////////////////////////////////////////////
class Myclass{
public:
	friend bool operator<(const Myclass &, const Myclass &); 
};

class NS{
	Myclass m1;
public:
	friend bool operator<(const NS &r1, const NS &r2){
	
		return r1.m1 < r2.m1;
	} 
	friend bool operator>(const NS &r1, const NS &r2){
	
		return r1.m1 > r2.m1; //GEÇERSÝZ 
		// return r2 < r1;
};
/////////////////////////////////////////////////////////////////////
Myclass varolan, implementasyonu baþkasý tarafýndan yazýlmýþ bir sýnýf, bizim yazdýðýmýz sýnýf ise NS sýnýfý.
NS sýnýfýnýn data memberi Myclass sýnýfý türünden. NS sýnýfý için karþýlaþtýrma operatör fonksiyonlarý yazýlýyor.
Büyüktür operatör fonksiyonu yazýlýrken  return r1.m1 > r2.m1; ifadesi geçersiz bir ifade çünkü Myclass sýnýfýnýn büyüktür iþlevi yok. 
Sýnýfý da programcý yazmadý, sýnýfýn interface'i böyle, bu sebeple bu þekilde yazým sentaks hatasý. Ancak return r2 < r1; geçerli bir ifade. 
Varolan küçüktür operatör fonksiyonu kullanýlarak büyüktür operatör fonksiyonu yazýldý.

Toplama operatör fonksiyonu yazýlýrken, öncelikle += operatör fonksiyonu yazýldý ve toplama fonksiyonu, += fonksiyonunu kullanarak yazýldý. Bu þekilde yazým 
derleyicinin verimi açýsýndan daha iyi olduðu için tercih edildi.


16_12_2017_CUMARTESÝ

Integer &operator++(); //prefix
Integer operator++(int); //postfix
Integer &operator--(); //prefix
Integer operator--(int); //postfix

++ ve -- operatörleri söz konusu olduðunda, bu operatörlerin dildeki primitif türler için verdiði doðal çaðrýþýma uygun olarak ön ek veya son ek olacak þekilde
overload edilebilirler. Unary operatörler ve member function olduklarýndan, parametreli olmayacak bu durumda ön ek ve son ek durumundaki fonksiyonlarý birbirinden
ayýrmak adýna son ek durumundaki operatör ++ ve -- fonksiyonlarý dummy parametre alacak þekilde tasarlanmýþlardýr.
C'den farklý olarak ++ ve -- operatörlerinin ön ek ve son ek olmasý durumunda l-value ve r-value expression olma durumlarý da farklý. Ön ek konumlarý l-value expression
son ek konumlarý ise r-value expression. x primitif bir int olduðunda ++x; ifadesi l-value; x++ ise r-value. 
Operatör ++'nýn ön ek konumunda olmasý durumunda referansa geri dönülür, son ek ++ yazýlýrken ise nesnenin kendi deðeri geri dönülür.

ön ek ++ operatör fonksiyonu yazýlýrken, ürettiði deðer fonksiyonun geri dönüþ deðeri olduðundan, *this ile geri döner. Ön ek olduðundan dolayý ise, geri döndüðünde
artýk deðerinin deðiþmiþ olmasý gerekir. 
Son ek ++ operatörünün int türden dummy parametresi var. Derleyici bu parametreden, bunun son ek ++ operatör fonksiyonu olduðunu anlar ve ayný çaðrýþýmý yapmasý
için referansa deðil türe geri döner. Kodunu yazarken ise eski deðeri bir nesnede saklanýr böylece artmadan önceki deðeri bir nesnede tutulmuþ olur. Nesneyi bir 
arttýrmak için kullanýlan patern ise, ön ek ++ operatör fonksiyonunu kullanmak. ++*this; ifadesinde ön ek ++ operatörü çaðrýlmýþ olur.(*this'in türü de Integer
olduðundan operator overloading devreye girer.)
/////////////////////////////////////////////////////////////////////
Integer &operator++(){ //ön ek ++
	++mval;
	return *this;
}

Integer operator++(int){ //son ek ++
	Integer retval{*this};
	++*this;
	return retval;
}
/////////////////////////////////////////////////////////////////////


inserter çýkýþ akýmýna veren formatlý yazým fonksiyonu, extractor ise giriþ akýmýndan aldýðý bytlelar ile ile nesneyi set eden operatör fonksiyon.
inserter operator<<'i extractor ise operator>>'i overload eder. Bu fonksiyonlar global operatör fonksiyonlar, çünkü sol operand baþka bir sýnýf türünden.
Çoðunlukla friend yapýlýrlar. Çýkýþ akýmýný kontrol eden sýnýflarýn taban sýnýf ostream, standart outputa yazýlacaksa ostream sýnýfý türünden nesne kullanýlýr.
Ancak dosyaya yazýlacaksa ostream'den türeyen fstream türünden nesneye ihtiyaç var. Belleðe yazmak için yine ostringstream sýnýfý türünden nesne kullanýlýr.
Fonksiyonun parametresi ostream & yapýlýrsa, bu 3 sýnýf türünden de nesne gönderilebilir böylece tek bir fonksiyon dosyaya da belleðe de standart çýkýþa da yazar.
Bu yüzden ideali bu fonksiyonlarýn geri dönüþ deðeri türlerinin ostream & olmasý ve birinci parametrelerinin ostream & olmasý. Yani cout << myInteger gibi bir
ifadede cout bu fonksiyonun birinci parametresine myInteger ise ikinci parametresine çekilir.
Arka arkaya fonksiyon çaðrýlarý yapýlabilmesi adýna fonksiyonun geri dönüþ deðeri birinci parametreye geçilen akým nesnesinin kendisi olabilmesi için fonksiyonun geri 
dönüþ deðeri referans yapýlýr. Çýkýþ fonksiyonu ostream referansa giriþ fonksiyonu ise istream referansa geri döner. 
Sýnýf türünden bir öðenin yazýdýrýlmasý durumunda, öðe deðiþmediðinden ikinci parametre const & seçilir.
Extractor fonksiyonunda ise, amaç nesneyi deðiþtirmek olduðundan const'luk deðil sadece & olur. 
friend olmasýnýn önemli bir nedeni de var böyle bir operasyon friend olmasaydý implementasyonda bu sýnýf nesnesinin artýk bir artmasý ne anlama geliyorsa 
çok büyük çoðunlukla private elemanlara eriþmesi gerekecek bu durumda friend olmak zorunda zaten.

/////////////////////////////////////////////////////////////////////
friend std::ostream &operator<<(std::ostream &os, const Integer &i){

	os << "(" << i.mval << ")";
	return os;
}
/////////////////////////////////////////////////////////////////////
Örnek olarak fonksiyonun birinci parametresine cout gelirse, os; cout nesnesinin kendisi.
os << "(" << i.mval << ")"; þeklinde yazýldýðýnda os yerine cout yazýlmasýndan bir fark yok, os, cout'un yerine geçiyor. 
cout'un ait olduðu sýnýfýn opeator<< fonksiyonlarý primitif türler için zaten *this döndürdüðünden direk return os << "(" << i.mval << ")"; ifadesi ile geri 
dönüldüðünde ostream sýnýfýnýn kendi operator<< fonksiyonunun geri dönüþ deðeri ile geri dönülmüþ olur. Yani os'nin kendi deðeri geri döndürülmüþ olur.
cout'u alýp, onu kullanýp geri veriyor.

/////////////////////////////////////////////////////////////////////
int main(){

	Integer c1{345}, c2{13} c3{97};

	cout << c1++ << "  " << ++c2 << endl;
	//operator<<(operator<<(cout, c1.operator++(0)).operator<<(" "), c2.operator++()).operator<<(endl); //derleyicinin yazdýðý kod

	ofstream ofs{aykut.txt};
	ofs << ++c1 << "  " << c2++ << endl; //ofs'de cout gibi bir nesne, dosyaya yazdýrýldý.
}
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
#include <fstream>
#include <iostream>
#include "Integer.h"
using namespace std;
int main()
{
	Integer c1{ 345 }, c2{ 13 }, c3{ 97 };

	ofstream ofs{ "aykut.txt" };
	////

	ofs << ++c1 << " " << c2++ << endl;

	ofs << c1 << " " << c2 << endl;

	ofs << c1 + c2 + c3 << endl;

}
/////////////////////////////////////////////////////////////////////
cout nasýl bir nesneyse ofs'de yine öyle bir nesne. cout standart çýkýþ akýmýný kontrol eder, ofs ise aykut.txt ile ilgili yapýlacak iþlemleri
kontrol eden bir akým nesnesi. Ekrana yazmak yerine dosyaya yazýldý.

/////////////////////////////////////////////////////////////////////
#include <iostream>
#include <sstream>
#include "integer.h"
using namespace std;
int main()
{
	Integer c1{ 345 }, c2{ 13 }, c3{ 97 };

	ostringstream oss{ "aykuy.txt" };
	////

	oss << c1 << " + " << c2 << " + " << c3 << " = " << c1 + c2 + c3;

	cout << oss.str() << endl;
		
}
/////////////////////////////////////////////////////////////////////
Burada da ostringstream sýnýfý türünden nesne ile belleðe yazdýrma yapýlýyor.


Giriþ fonksiyonunda ise, giriþ iþlemini kontrol eden sýnýf nesnesi fonksiyonun birinci parametresine gelir. Ýkinci parametresine ise set edilecek nesne gelir.
Bu fonksiyon cin << myInteger þeklinde çaðrýlýrsa, is referansý cin nesnesi yerine geçer. istream sýnýfýnýn bu fonksiyonu istream nesnesinin kendisini döndürür.
Fonksiyon yine friend yapýlmamýþ olsa r.mval ifadesinde sentaks hatasý olurdu.(mval sýnýfýn private veri öðesi)
/////////////////////////////////////////////////////////////////////
friend std::istream &operator >> (std::istream &is, Integer &r){
	
	return is >> r.mval;
}

int main()
{
	Integer ival1, ival2, ival3;

	cout << "uc sayi giriniz: ";
	cin >> ival1 >> ival2 >> ival3;
	//operator>>(operator>>(operator>>(cin, ival1),ival2),ival3);
	
	cout << ival1 << sl << ival2 << sl << ival3 << endl;
}
/////////////////////////////////////////////////////////////////////


[] Operatörünün Overload Edilmesi:

Genelde array-like (dizi benzeri) sýnýf türünden nesneler için kullanýlýr. Örnek olarak stl'in dinamik dizi olan vector sýnýfý.
Dinamik dizide tutulan öðeye týpký normal dizi gibi köþeli parantez operatörü ile eriþilir.
String sýnýfý da köþeli parantez operatörünü overload eder. C'de char türden dizide tutulduðunda öðeye köþeli parantez operatörü ile 
eriþildiðinde burada string sýnýfý da köþeli parantez operatörünü kullanýr.
Ýteratör sýnýflarý ve smart pointer sýnýflarýnýn bir kýsmý da [] operatörünü overload eder.
Köþeli parantez operatörü member function olmak zorunda, global fonksiyon olamaz.
p[n] þeklindeki ifadeyi derleyici, ifadeyi p.operator[](n) ifadesine dönüþtürür. Böylelikle aslýnda p nesnesinin bir üye fonksiyonu 
çaðrýlmýþ olur ve fonksiyona argüman olarak n gönderilir.
Parametre çoðunlukla tam sayý türünden olur, size_t türünde.(n'nin tamsayý türünden olmasý gerekir)
[] operatörü ile bir nesneye eriþildiðinden, ifade l-value ifadedir.(C'de de C++'da da köþeli parantez operatörü düþünüldüðünde ifade zaten l-value, çünkü
bir nesneye eriþilir). 
p.operator[](n) ifadesi bir fonksiyon çaðrýsý olduðundan, fonksiyon çaðrýsýnýn l-value expression olmasý için çaðrýlan fonksiyonun geri dönüþ deðerinin
türü referansdýr. Köþeli parantez operatör fonksiyonu, l-value ifade olduðundan referans döndürmeli.
p[n] = 23; ifadesi ile aslýnda p.operator[](n) ifadesinden geri dönüþ deðeri ile elde edilen nesneye bu atama yapýlmýþ olur.
p'nin türünün ne olduðunun bilinmediði düþünüldüðünde p[n] = 23 ifadesi ancak þu durumlarda geçerli olabilir:
1)zaten eriþilen nesnenin kendisi int'tir, primitiftir bu durumda int'e int atanmýþtýr.
2)geri dönüþ deðeri olan nesne bir sýnýf nesnesidir, o sýnýf nesnesinin de böyle bir atama operatör fonksiyonuveya bu iþi yapacak bir conversion constructor'ý vardýr.


/////////////////////////////////////////////////////////////////////
int main()
{	
	string s{ "necati ergin" };


	s[1] = 'o'; // const string s{" necati ergin "} olsaydý geçersiz olurdu.

	for (auto idx = 0; idx < s.size(); ++idx)
		cout << s[idx] << " ";

	cout << "\n";

}
/////////////////////////////////////////////////////////////////////
s[1] = 'o' ifadeesinde s[] yazma amaçlý, for döngüsü içerisinde ise s[] okuma amaçlý kullanýldý.
string sýnýfý türünden olan s, const yapýlsaydý, s[1] = 'o' ifadesi geçersiz olurdu.


/////////////////////////////////////////////////////////////////////
class Name{
public:
	Name(const char *p);
	char &operator[](size_t idx);
};
int main()
{	
	const Name myname("necati");

	myname[1] = 'o'; //geçersiz, const bir nesne için sýnýfýn const olmayan üye fonksiyonu çaðrýlamaz

	char c = myname[0]; //geçersiz
}
/////////////////////////////////////////////////////////////////////
Köþeli parantez operatör fonksiyonu const üye fonksiyon olmadýðý için iki ifade de geçersiz.
Dilin kurallarýna göre const bir nesne için, bu operator[] fonksiyonu çaðýrýlamaz çünkü fonksiyon const
üye fonksiyon deðil.
Bu durumda öyle bir hile yapýlmalý ki, 
char c = myname[0]; ifadesinde myname[0] okuma amaçlý kullanýldýðýnda legal olmalý, yazma amaçlý kullanýldýðýnda
illegal olmalý.
Ancak sýnýf türünden nesne const deðilse, okuma amaçlý da yazma amaçlý da legal olmalý.
Bu problemin çözümü const overloading


/////////////////////////////////////////////////////////////////////
class Name{
public:
	Name(const char *p);
	char &operator[](size_t idx);
	char &operator[](size_t idx)const;
};

/////////////////////////////////////////////////////////////////////
Bir sýnýfýn constluk dýþýnda ayný imzaya sahip iki tane fonksiyonu olabilir bu function overloading.
Kurala göre eðer sýnýf nesnesi const ise, const olmayan fonksiyon zaten viable deðil, const olan üye
fonksiyon çaðýrýlýr. 
Sýnýf nesnesi const deðil ise, const olmayan üye fonksiyonun const olan üye fonksiyona göre seçiliði var.
const sýnýf nesneleri için yukarýdaki operator[] fonksiyonu, const olmayan sýnýf nesneleri için ise const olan
aþaðýdaki operator[] fonksiyonu çaðýrýlýr.,
Ýkinci bir hile olarak ise, const olan üye operatör fonksiyonun geri dönüþ deðeri T bir tür olmak üzere T & 
yerine const T & yapýlýr. Böylece burdan elde edilen deðer const muamelesi görür. Bu nedenle köþeli parantez 
operatör fonksiyonlarý hemen her zaman const overloadinge tabi tutulurlar. Const nesneler için fonksiyonun geri
dönüþ deðeri const & yapýlýr, böylece bu fonksiyondan elde edilen nesne salt okuma amaçlý kullanýlabilir.
Const olmayan nesneler için normal referans yapýlýr.


/////////////////////////////////////////////////////////////////////
class Name {
	size_t mlen;
	char *mpd;
public:
	Name(const char *p) : mlen{ strlen(p) }, mpd{ new char[mlen + 1] }
	{
		strcpy(mpd, p);
	}
	Name(const Name &r) : mlen{ r.mlen }, mpd{ new char[mlen + 1] }
	{
		strcpy(mpd, r.mpd);
	}
	Name(Name &&r) : mlen{ r.mlen }, mpd{ r.mpd }
	{
		r.mpd = nullptr;
	}
	Name &operator=(const Name &r)
	{
		if (this == &r)
			return *this;

		delete[]mpd;
		mlen = r.mlen;
		mpd = new char[mlen + 1];
		strcpy(mpd, r.mpd);

		return *this;
	}
	Name &operator=(Name &&r)
	{
		if (this == &r)
			return *this;

		delete[]mpd;
		mlen = r.mlen;
		mpd = r.mpd;

		r.mpd = nullptr;
		return *this;
	}
	~Name()
	{
		if (mpd != NULL)
			delete[]mpd;
	}
	char &operator[](size_t idx)
	{
		return mpd[idx];
	}
	const char &operator[](size_t idx)const
	{
		return mpd[idx];
	}

	size_t length()const
	{
		return mlen;
	}
	friend std::ostream &operator<<(std::ostream &os, const Name &name)
	{
		return os << "(" << name.mpd << ")";
	}
	friend std::istream &operator >> (std::istream &is, Name &name)
	{
		 is >> name.mpd;
		 name.mlen = strlen(name.mpd);
		 return is;
	}
};
int main()
{	
	Name x{ "enes cakiroglu" };

	for (size_t idx = 0; idx < x.length(); ++idx)
		cout << x[idx] << "  ";

	cout << "\n";
	
	x[3] = 'x';
	x[8] = 'o';

	cout << x << endl;

	cout << "degisecek isim ne olsun : ";
	cin >> x;

	cout << x << endl;

	for (size_t idx = 0; idx < x.length(); ++idx)
			++x[idx];

	cout << x << endl;

}
/////////////////////////////////////////////////////////////////////
Sýnýf kaynak kullandýðý için tipik olarak büyük 5'liye sahip olmasý gerekir.
Sýrasýyla constructor, copy constructor, move constructor, copy assignment, move assignment 
ve destructor yazýldý.
x nesnesi, const yapýlsaydý, x[3] ve x[8] e atama yapmak, nesne const olduðu için geçersiz olurdu 
ancak for döngüsü içindeki x[idx]; ifadesi okuma amaçlý olduðundan yine de geçerli.


/////////////////////////////////////////////////////////////////////
int main()
{	
	vector<string> svec{ "sinan", "huseyin", "necati", "aykut" };

	for (auto idx = 0; idx < svec.size(); ++idx)
		svec[idx] += "can";

	for (auto idx = 0; idx < svec.size(); ++idx)
		cout << svec[idx] << "\n";

}
/////////////////////////////////////////////////////////////////////
vector sýnýfý için de ayný operator overload edilmiþ.


/////////////////////////////////////////////////////////////////////
int main()
{	
	map<string, int> telmap{
		{ "huseyin",  532532},
		{ "aykut",	  534897 },
		{ "necati",   541564 },
		{ "tarik",    512712 },
		{ "arman",    717181 },
		{ "polat",    756742 },
	};

	cout << telmap["necati"] << "\n\n";

	telmap["polat"] = 333345;

	for (const auto &p : telmap)
		cout << p.first << " " << p.second << endl;
}
/////////////////////////////////////////////////////////////////////
map sýnýfýnýn da köþeli parantez operatör fonksiyonu overloadu mevcut.
telmap sýnýf nesnesi, köþeli parantez operatörünün operandý.
köþeli parantez içine anahtar yazýlýp o anahtara karþýlýk gelen deðere eriþilir.


Ýçerik Operatörü ve Ok Operatörünün Yüklenmesi (Smart Pointer Kavramý)

Yine çaðrýþýmsal yapýnýn korunmasý için, içerik operatörünün overload edilmesi pointerlarýn dereference edilmesine yakýn bir 
çaðrýþým vermek. Derleyici *ptr ifadesini ptr.operator*() fonksiyonuna çaðrýya dönüþtürür.
Native türler söz konusu olduðunda *ptr ifadesi bir l-value expressiondýr, içerik operatörü her zaman o adresteki nesneye 
eriþtirir. Yine ayný þekilde ptr.operator*() fonksiyonunun bir l-value expression olmasý için, tipik olarak sýnýflarýn 
operator içerik fonksiyonlarýnýn geri dönüþ deðeri & (referans) olur. 
*ptr, ptr'nin gösterdiði nesnedir bu durumda *ptr sözde ptr hangi nesneyi gösteriyorsa o nesnenin kendisi olmasý gerekir.
Member function olarak yazýlýr çünkü sýnýf nesnesine eriþtirir. 
*ptr ifadesi bir sol taraf deðeri, sözde bu pointerýn gösterdiði nesne ama ptr'nin kendisi bir pointer deðilse, böyle sýnýflara 
smart pointer sýnýfý denir. Smart pointer sýnýflarý dinamik nesnelerin kontrolünde kullanýlýr. Normal pointerlarýn yapamadýðý
bazý iþlemleri yapabildiði için.


/////////////////////////////////////////////////////////////////////
class Myclass {
	int mx;
public:
	void set(int val)
	{
		mx = val;
	}
	int get()const
	{
		return mx;
	}
	Myclass(int val) : mx{ val } 
	{
		cout << "Myclass nesnesi icin kaynaklar edinildi" << endl;
	}
	~Myclass()
	{
		cout << "Myclass nesnesinin kaynaklari iade edildi" << endl;
	}
	friend std::ostream &operator<<(std::ostream &os, const Myclass &m)
	{
		return os << "(" << m.mx << ")";
	}
};
int main()
{	
	auto *pm = new Myclass{ 13 };

	cout << *pm << endl;

	pm->set(365);
	cout << pm->get() << endl;

	delete pm;
}
/////////////////////////////////////////////////////////////////////
Myclass sýnýfý sözde kaynak kullanan bir sýnýf. Öyle bir sýnýf oluþturmak istiyoruz
ki örnekteki native pm pointerýnýn yaptýðý her þeyi yapacak. Ýçerik operatörü ve ok operatörünü
saðlayacak esktra olarak ise dinamik bir nesneyi bu sýnýfa baðladýðýmýzda pointerin ömrü
bittiðinde dinamik nesnenin de ömrü bitecek(garbage collector gibi çalýþacak). dinamik nesne 
oluþturulacak, iþi bittiðinde otomatik olarak delete edilecek.


/////////////////////////////////////////////////////////////////////
class Myclass {
	int mx;
public:
	void set(int val)
	{
		mx = val;
	}
	int get()const
	{
		return mx;
	}
	Myclass(int val) : mx{ val }
	{
		cout << "Myclass nesnesi icin kaynaklar edinildi" << endl;
	}
	~Myclass()
	{
		cout << "Myclass nesnesinin kaynaklari iade edildi" << endl;
	}
	friend std::ostream &operator<<(std::ostream &os, const Myclass &m)
	{
		return os << "(" << m.mx << ")";
	}
};

class MyclassPtr {
	Myclass *mp;
public:
	MyclassPtr(Myclass *pd) : mp{pd} {}
	~MyclassPtr()
	{
		delete mp;
	}
	Myclass &operator*()
	{
		return *mp;
	}
	Myclass *operator->()
	{
		return mp;
	}

};

int main()
{
	MyclassPtr pm = new Myclass{ 13 };
	

	cout << *pm << endl;

	pm->set(365);
	//pm.operator->()->set(365);

	cout << pm->get() << endl;


}
/////////////////////////////////////////////////////////////////////
Ok operatöründe yine enteresan bir hile var.pm bir sýnýf nesnesiyse, normalde ok operatörü binary bir operatör.
p, bir sýnýf nesnesi, a'da ok operatörünün sað operandý olsun. Derleyici sýnýfýn ok operatörü varsa p->a'yý;
p.operator->() ifadesine dönüþtürür.Ok operatörü binary operator olmasýna raðmen unary operatörmüþ gibi overload edilir.
Ok operatör fonksiyonunun kesinlikle parametresi yok.Böylece bu fonksiyondan bir geri dönüþ deðeri elde edilir bu yine
ok'un soluna koyulur: p.operator->()->a haline gelir. Derleyicinin bu iþlemi yapmasýndan sonra ifadenin legal olmasý için,
p.operator->() ifadesinin bir adres olmasý gerekir, doðal olarak ok operatörü geri dönüþ deðeri olarak adres üretmeli.

->operatör fonksiyonu sýnýf türünden bir adres döndürür böylece o operatörün sol operandý olur, o adresteki nesnenin
öðesine eriþilmiþ olur.
Ortada aslýnda gerçekte pointer olmayan bir sýnýf nesnesi var, MyclassPtr sýnýfý için içerik operatörü ve ok operatörü
overload edildiðinden, normal bir pointer gibi bu operatörlerin operandý olduðunda yapmasý gerekeni yapýyor. Normal bir
pointerdan farký ise, MyclassPtr sýnýfý türünden nesnenin scope'u bittiðinde bu bir sýnýf nesnesi olduðu için destructor'ý
çaðýrýlýyor bunun destructor'ý da kontrol ettiði dinamik nesneyi destroy ediyor, adeta garbage collector gibi çalýþan
basit bir sýnýf olmuþ oldu.

Bu durumda Myclass sýnýfýnýn ne yaptýðýndan baðýmsýz olarak her sýnýfa böyle bir özellik eklenebilir. O zaman her bir sýnýf
için MyclassPtr gibi bir sýnýfýn da kodunun yazýlmasý gerekir, burada da þablonlar(templates) devreye girer.
Þablon aracý olmasaydý baþkasýnýn yazdýðý bir sýnýfa bölye bir akýllý pointer sýnýf yazmak için kod yazýlmasý gerekirdi.
Þablonlar sayesinde, bu kod bir þablon haline getirilir, gerçek sýnýf kodunu yazma görevi derleyiciye verilir.
/////////////////////////////////////////////////////////////////////
class Myclass {
	int mx;
public:
	void set(int val)
	{
		mx = val;
	}
	int get()const 
	{
		return mx;
	}
	Myclass(int val) : mx{ val }
	{
		cout << "Myclass nesnesi icin kaynaklar edinildi" << endl;
	}
	~Myclass()
	{
		cout << "Myclass nesnesinin kaynaklari iade edildi" << endl;
	}
	friend std::ostream &operator<<(std::ostream &os, const Myclass &m)
	{
		return os << "(" << m.mx << ")";
	}
};

template<typename T>
class SmartPtr {
	T *mp;
public:
	SmartPtr(T *pd) : mp{pd} {}
	~SmartPtr()
	{
		delete mp;
	}
	T &operator*()
	{
		return *mp;
	}
	T *operator->()
	{
		return mp;
	}

};

int main()
{
	SmartPtr<Myclass> pm = new Myclass{ 13 };
	
	cout << *pm << endl;

	pm->set(365);
	
	cout << pm->get() << endl;

	/*--------------------------------------------------*/
	
	SmartPtr<string> pd = new string{"Necati"};

	pd->back() = 's';

	

}
/////////////////////////////////////////////////////////////////////
Derleyici compile time'da kod yazarken T geçen yerlerde Myclass türünü kullanýp kod yazar.



/////////////////////////////////////////////////////////////////////
template <typename T, typename U>
struct Pair {
	T first;
	U second;
};

Pair<int, string> foo();

int main()
{
	Pair<int, double> mypair; //sýnýf türünden nesne oluþturuldu.

	auto x = foo();
	// x.first ve x.second geri döndürülen deðerlerden birincisi ve ikincisi
}
/////////////////////////////////////////////////////////////////////
Pair olabilecek en basit template, basitleþtirilmiþ hali. struct, default eriþim bölümü public olan class.
Pair<int, double> mypair; ifadesinde derleyici birinci tür parametresi T yerine int'i, U yerine de 
double'ý alýr.
Birçok zaman bir fonksiyonun bir deðil, iki deðer birden döndürmesi istenir. Bu mekanizma bir þablon haline 
getirilirse, derleyici ne zaman gerekirse kendisi þablondan faydalanarak iki tane türü tek bir türmüþ gibi 
sarmalayacak kodu yazar.
En büyük ihtiyaç noktasý fonksiyonlarýn geri dönüþ deðeri.


/////////////////////////////////////////////////////////////////////
int main()
{
	map<string, int> mymap;

	mymap.insert(pair<string, int>{"kardelen", 19});
	mymap.insert(pair<string, int>{"huseyin",  30});
	mymap.insert(pair<string, int>{"aykut",     9});

	auto iter = mymap.begin();

	cout << iter->first << " " << iter->second << endl;

}
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
struct Myclass {
	void set(int);
};
class A{
public:
	Myclass *operator->();
};

class B {
public:
	A operator->();
};

int main()
{	
	B bptr;

	bptr->set(12);
	//bptr.operator->().operator->()->set(12);
}
/////////////////////////////////////////////////////////////////////
Seyrek kullanýlsa da legalize etmenin ikinci bir yöntemi daha mevcut.
bptr->set(12); ifadesi geçerli bir ifade. set aslýnda Myclass'ýn bir fonksiyonu.
Derleyici bptr->set()'i, bptr.operator->().operator->()->set() ifadesine dönüþtürdü.
bptr.operator->() ifadesinin türü zaten A, ardýndan A'nýn operator ok fonksiyonu çaðrýlmýþ oldu.
Ok operatörün fonksiyonunun geri dönüþ deðeri ok'un soluna konulduðu için ancak iki yöntem legal olabilir.
Biri doðrudan adres döndürmesi ikincisi ise bir sýnýfa geri dönmesi ama o sýnýfýn da bir ok operatör
fonksiyonu olmasý. Bu durumda bir sýnýfýn ok operatör fonksiyonu, baþka bir sýnýfýn ok operatör fonksiyonunun
çaðýrýlmasý sonucunu doðurur.


17_12_2017 PAZAR

/////////////////////////////////////////////////////////////////////
int main()
{
	unique_ptr<string> uptr{ new string{"muhittin"} };
	//unique_ptr<string> uptr =  new string{ "muhittin" }; //illegal


	//uptr = new string{ "muhittin" }; //geçersiz, atama yapmak geçerli deðil

	if (uptr)
	{
		cout << "dogru" << endl; //uptr bir nesneyi gösterirse buraya gelir
	}
	else
		cout << "yanlis" << endl; //uptr bir nesneyi göstermiyorsa buraya gelir

	unique_ptr<string> up = move(uptr); //legal, yasak olan kopyalama, taþýma yasak deðil


	if (uptr)
	{
		cout << "dogru" << endl; 
	}
	else
		cout << "yanlis" << endl; //kaynaklari calindigindan, bir yeri göstermez


	if (up)
	{
		cout << "dogru" << endl; //uptr'nin kaynaklarini caldigindan buraya gelir
	}
	else
		cout << "yanlis" << endl; 

}
/////////////////////////////////////////////////////////////////////
Bir nesneyi göstermediðinden if bloðunun yanlýþ kýsmýna girer.
Atama semantiði tamamen yasak. Bir unique ptr nesnesine deðer vermek istenirse
bu sýnýfýn üye fonksiyonlarý aracýlýðý ile yapýlmalý ya da ilk deðer verilmeli.,
unique_ptr sýnýfýnýn constructor'ý explicit olduðu için
unique_ptr<string> uptr =  new string{ "muhittin" }; ifadesi illegal.
Kopyalama yasak ancak taþýma deðil bu yüzden unique_ptr<string> up = move(uptr); 
ifadesi geçerli. unique_ptr nesneleri, not copyable, not assignable but moveable.
Bu sýnýfýn iki tane temel görevi var; biri ömür iliþkisi yani eðer unique_ptr nesnesi
hayata veda ederse gösterdiði nesnenin de hayatý sona erer. Dinamik nesnelerin kontrolünü
oldukça kolaylaþtýrýr, adeta bir garbage collector görevi görür. 
Dinamik nesne neco'ya baüðlandýðýnda mülkiyeti neco'da, neco nesnesi hayata veda ettiðinde
dinamik nesne de hayata veda eder. Taþýma ile baþka bir smart pointer olan nesneye aktarýldýðýnda
dinamik nesnenin hayatý artýk bu yeni nesneye baðlý. Dil, bir nesnenin iki tane sahibi 
olamayacaðýný garanti ediyor, bu stratejiye exclusive ownership denir.(tek sahiplik stratejisi)
Dinamik nesnenin bir sahibi olur sahibi ölürse dinamik nesne de ölür.
Normal pointer kullanmak yerine dinamik nesneleri unique_ptr gibi pointerlara baðlandýðýnda
elde edilen garanti: artýk kaynak sýzýntýsý olma ihtimali yok. Çünkü pointerýn hayatý bittiðinde
dinamik nesnenin de ömrü biter.


int main()
{
	vector<string> svec; //stringleri bir arada tutacak bir nesne havuzu(dinamik dizi, vektör)
	string s1 = { "neco" };
	string s2 = { "aykut" };

	svec.push_back(s1);
	svec.push_back(s2);
}
/////////////////////////////////////////////////////////////////////
C++'da geleneksel olarak en problematik durumlardan biri, containerda dinamik
nesne tutmaktý yani container'da nesnenin kendisini tutmak. Bunun nedeni C++'da normalde
bütün containerlar kopyalama semantiði ile çalýþýyor. 
svec bir vektör olmak üzere, içinde "neco" ve "aykut" yazýlarýný tutar. Ancak s1 ve s2'nin
kendisi deðil, kopyasý svec içinde. Normalde bütün containerlar bu þekilde çalýþýr, containera
bir þey koymak için ilgili fonksiyonlarý çaðýrýldýðýnda(insert, pusback fonksiyonlarý) 
container içine koyulacak nesnenin kopyasýný çýkartýp onu koyar. containerlar referans semantiði
ile deðil kopyalama semantiði ile çalýþýr. Ancak bazen programlamada nesnenin kendisi containera
konulmak isteniyor, özellikle dinamik ömürlü nesneler söz konusu oluyor.


/////////////////////////////////////////////////////////////////////
int main()
{
	vector<string> svec; 
	vector<string *> pvec;

	string *pd = new string{ "ismail" };

	svec.push_back(*pd); //bu þekilde yazýldýðýnda kopyasý containera konulur.
	pvec.push_back(pd); //burada, pvec'e dinamik nesnenin adresi konulur.
}
/////////////////////////////////////////////////////////////////////
Bu string nesnesinin kendisi, containera konulmak istenirse eskiden böyle
durumlarda container string tutacak þekilde deðil, string pointeri tutacak 
þekilde ayarlanýrdý. vector<string *>svec; þeklinde bildirilirdi ve dinamik
nesnenin adresi containerda tutulurdu. Ancak buradaki problem ise bunun delete
edilmesinde. Bu containerýn kullanýldýðý kod ile dinamik nesneyi üreten kod
farklý yerlerde olabilir ama sonuçta bu delete edilmeli.


/////////////////////////////////////////////////////////////////////
int main()
{
	vector<unique_ptr<string>> svec;

	svec.push_back(unique_ptr<string>{new string{ "ali" }});

}
/////////////////////////////////////////////////////////////////////
Artýk dil vector'un string * açýlýmýný kullanmak yerine madem unique_ptr
de bir sýnýf o zaman bir vektör içinde unique_ptr'nin string açýlýmý türünden
nesneler tutabilmesine olanak saðlar.
Bu vektöre, unique_ptr nesneleri konur. unique_ptr nesnesinin hayatý bittiðinde
dinamik nesnenin de hayatý biter. Bir container nesnesinin hayatý bittiðinde 
containerda tutulan öðelerin de destructor'ý çaðýrýlýr. Ancak kopyalama semantiði
söz konusu olsaydý, diðer nesnenin hayatý bundan etkilenmezdi.(çünkü containerdaki
nesnenin kendisi deðil, kopyasý)
svec.push_back(unique_ptr<string>{new string{ "ali" }}); ifadesinde containera
unique_ptr'nin string açýlýmý türünden geçici bir nesne konulur. Bu container 
nesnesinin hayatý bittiðinde içindeki nesnelerin de hayatý bitecek, yani unique_ptr
nesnelerinin de hayatý bitecek. unique_ptr'nin hayatý bitince de onun gösterdiði
dinamik nesnenin hayatý biter. 


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{

	}
	~Myclass()
	{
		std::cout << "Myclass nesnesi kaynaklari geri verildi\n";
	}
};
int main()
{
	cout << "main basladi\n";

	if (true)
	{
		unique_ptr<Myclass> up{ new Myclass };
	}

	cout << "main devam ediyor\n";
}
/////////////////////////////////////////////////////////////////////
if'in doðru kýsmýndan çýkýp, main devam ediyora gelmeden önce dinamik nesne hayata veda
edecek çünkü blok içindeki yerel nesnenin hayatý biter. Bu exclusive ownership modeli.
Zaten bir nesnenin ikinci bir sahibi olamaz.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{

	}
	~Myclass()
	{
		std::cout << "Myclass nesnesi kaynaklari geri verildi\n";
	}
};
int main()
{
	cout << "main basladi\n";
	
	shared_ptr<Myclass> sp1{ new Myclass };

	auto sp2 = sp1;
	auto sp3 = sp1;

	cout << sp2.use_count() << endl;

	cout << "main devam ediyor\n";
}
/////////////////////////////////////////////////////////////////////
unique_ptr, tek sahiplik ilkesini implemente eder, yani bir nesnenin
ancak tek bir sahibi olabilir. Ancak bazý durumlarda, bir nesneye birden
fazla pointer ile eriþilmesi gerekir, bu durumda unique_ptr kullanýlamaz.
O zaman da, dilin baþka bir akýllý pointer sýnýfý kullanýlýr, ayný zamanda
bir nesnenin birden fazla sahibi olmasý durumunun kullanýldýðý sýnýf. Ayný 
dinamik nesne üzerinde, birden fazla pointer iþlem yapabiliyor. Bu aslýnda
klasik pointerlara benzer, bu modele de shared ownership(paylaþýlmýþ sahiplik) 
denir. Burada klasik pointerlarýn sorunu, birden fazla pointerdan hangisi bu
dinamik nesneyi delete edecek ? Buradaki modele göre dinamik nesne onu gösteren 
en az bir pointer nesne olduðu sürece hayatta kalýr. Burada aslýnda kullanýlan
implementasyon tekniðine, reference counting denir.(referans sayýmý) Buradaki
akýllý pointerlar belirli bir anda kaç tane smart pointer bu nesneyi gösteriyor,
bu bilgiyi de biliyor böylece kendi hayatý bittiðinde eðer sadece kendisi nesneyi
gösteriyorsa kendisi hayata veda ederken, dinamik nesneyi de delete eder. C++11
öncesi böyle bir sýnýf yoktu, modern C++ ile gelen bu sýnýf shared_ptr.
auto sp2 = sp1; ifadesinde kopyalama gerçekleþir, kopyalama semantiði mülkiyeti
kopyalar. sp1 ve sp2 ayný dinamik nesneyi gösterir.(kopyalama burada deðil
uniqu_ptr de geçersiz) 
Sýnýfýn use_count() fonksiyonunun geri dönüþ deðeri, dinamik nesneyi kaç tane nesnenin
gösterdiðinin sayýsý. Dinamik nesneyi gösteren son pointerýn hayatý bittiði zaman
dinamik nesnenin de hayatý bitecek.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass()
	{

	}
	~Myclass()
	{
		std::cout << "Myclass nesnesi kaynaklari geri verildi\n";
	}
};
int main()
{
	cout << "main basladi\n";

	if (true) {
		shared_ptr<Myclass> sp1{ new Myclass };
		if (true) {
			auto sp2 = sp1;
			auto sp3 = sp1;
		}

		cout << "main devam ediyor 1\n";
	}

	cout << "main devam ediyor 2\n";
}
/////////////////////////////////////////////////////////////////////
Ýlk "main devam ediyor" yazýsý çýkmadan önce Myclass nesnesi destroy
olmaz çünkü halen sp1 hayatta.
"main devam ediyor 1" yazýsýyla "main devam ediyor 2" yazýsý arasýnda
dinamik nesne hayata veda edecek çünkü son nesne olan sp1'in scope'u
"main devam ediyor 1" yazýsýnýn altýnda bitecek.

C'deki pointerlara, C++'da raw pointer veya naked pointer denir. C'deki pointerlar 
artýk alt seviyeli kodlarda var. C++'da akýllý pointerlar çok daha sýk kullanýlýr.

/////////////////////////////////////////////////////////////////////
using Sptr = shared_ptr<string>;
int main()
{
	vector<Sptr> svec;
	
	list<Sptr> slist;

	Sptr sp{ new string{ "Necati" } };
	svec.push_back(sp);
	slist.push_back(sp);

	*svec[0] += "can";

	*slist.front() = "Hasan" + *slist.front();

	cout << *sp << endl;

}
/////////////////////////////////////////////////////////////////////
Ayný dinamik nesne hem vektöre hem de baðlý listeye konuldu.
*svec[0] ifadesi ile vektörün 0 indisli öðesi olan akýllý pointerýn gösterdiði
nesneye eriþildi. Böylece vektördeki öðe "necatican" oldu.
containerlarýn front() isimli fonksiyonu, containerdaki ilk öðeye eriþtirir.
slist.front()'un dereference edilmesi ile pointerin gösterdiði nesneye eriþilir.
Bir dinamik nesne birden fazla containerda tutuldu. sp nesnesi önce vektör yolu
ile ardýndan baðlý liste yolu ile deðiþtirildi. Bu tür iþlemler shared_ptr ile 
rahatça yapýlabiliyor. Ortada bir dinamik nesne var, birden fazla sahibi var.
Ayný nesne birden fazla containera konulabiliyor.


Fonksiyon Çaðrý Operatörünün Yüklenmesi

Fonksiyon çaðrý operatörünün yüklenmesi gerçek faydasýný þablonlar ile kullanýldýðýnda verecek.
func(); ifadesi C'de geçerli ise, func bir fonksiyon ismidir, bu isimde bir fonksiyon çaðrýlmaktadýr
veya func bir function pointerdýr, function pointerýn deðeri olan adresteki fonksiyon çaðrýlmaktadýr
ya da func bir makrodur, derleyici func'ý bile görmez, öniþlemci function like makro'yu açar.
C++'da ise func() ifadesi C'de olduðundan çok daha fazla anlama gelebilir. Bu yine bir fonksiyon çaðrýsý
veya fonksiyon gösterici ile çaðrý olabilir, func bir sýnýf nesnesi de olabilir.
func'ýn bir sýnýf nesnesi olmasý durumunda böyle bir fonksiyon çaðrýsý yapýlabilir tabi sýnýf için
fonksiyon çaðrý operatörü overload edilmiþ ise. Sýnýf nesneleri fonksiyon çaðrý operatörünün operandý
yapýlýr. Derleyici bu durumda durumdan vazife çýkartýp sýnýfýn bir üye fonksiyonunu çaðýrýr.
Bu fonksiyonun global olmasý yasak, fonksiyon çaðrý operatör fonksiyonu üye operatör fonksiyon olmak
zorunda. Bu da bir fonksiyon çaðýrma yöntemi ancak barýndýrdýðý özellikler açýsýndan normal fonksiyonlara
göre daha yüksek bir araç.
func(); ifadesi C++'da baþka anlamlara da gelebilir, func bir lambda olabilir, bir bind nesnesi olabilir..

Böyle yapýlara callable deniyor, func bir callable. Yani eðer bir ifade fonksiyon çaðrý operatörünün
operandý olduðunda, bir fonksiyon çaðýrýlýyor ise o ifade bir callable, çaðýrýlabilir anlamýnda.

/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	void operator()()
	{
		std::cout << "Myclass::operator()()\n";
		std::cout << "this = " << this << "\n";
	}
};
int main()
{
	Myclass m;
	
	m();
	m.operator()();

	cout << "&m = " << &m << endl;
}
/////////////////////////////////////////////////////////////////////
Fonksiyon çaðrý operatör fonksiyonu bildirilmemiþ olsaydý, m() ifadesi
geçersiz olurdu. Derleyici m() ifadesini m.operator()() ifadesine dönüþtürür.
Fonksiyon çaðrý operatörü sýnýfýn non-statik üye fonksiyonu, statik üye 
fonksiyon olsaydý this göstericisi olmazdý.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	void operator()()
	{
		std::cout << "Myclass::operator()()\n";
		std::cout << "this = " << this << "\n";
	}
};
int main()
{
	Myclass m();

	Myclass s;
	s();
}
/////////////////////////////////////////////////////////////////////
Myclass m(); ifadesi bir declaration, bir tür bilgisi mevcut. Örneðin
sýnýfýn int parametreli bir constructor'ý olduðu düþünüldüðünde Myclass m(12);
ifadesinde constructor'ýn çaðýrýlmasýný saðlayan, bu declaration, türü Myclass
olan ismi m olan bir nesne tanýmlandý.
s(); ifadesinde ise bir declaration yok, s zaten hayattaki bir nesne. Bu bir 
bildirim olmadýðýna göre constructor çaðrý ifadesi olamaz. Derleyici de ikisi
arasýndaki ayýrýmý böyle yapar, buna göre constructor'ý veya fonksiyon çaðrý
operatör fonksiyonunu çaðýrýr.



/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	void operator()(int x)
	{
		std::cout << "x = " << x << std::endl;
	}
};
int main()
{
	Myclass m;
	m(23);
}
/////////////////////////////////////////////////////////////////////
Nesneyi oluþturan Myclass m bildirimi, default constructor çaðýrýlýr.
m(23); ifadesinde ise m zaten hayatta, m fonksiyon çaðrý operatörünün
operandý yapýldý. Operatör fonksiyonunun parametresi olmasaydý derleyici
parametresi olmayan bir fonksiyona, argüman gönderildiði için hata verirdi.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	void operator()(int)
	{
		std::cout << "operator()(int)\n";
	}
	void operator()(double)
	{
		std::cout << "operator()(double)\n";
	}
	void operator()(int, int)
	{
		std::cout << "operator()(int, int)\n";
	}
	void operator()(long x = 0)
	{
		std::cout << "operator()(long) " << "x = " << x << "\n";
	}
};
int main()
{
	Myclass m;

	m(12); //int parametreli
	m(4.7); //double parametreli
	m(6, 7); //int, int parametreli

	m(); //long parametreli olan
	m(12L); //long parametreli olan
}
/////////////////////////////////////////////////////////////////////
operator overloading mekanizmasýnda varsayýlan argüman alabilen tek operatör
fonksiyonu, fonksiyon çaðrý operatör fonksiyonudur.


/////////////////////////////////////////////////////////////////////
class Random {
	int mlow, mhigh;
public:
	Random(int low, int high) : mlow{low}, mhigh{high} {}
	int operator()()
	{
		return rand() % (mhigh - mlow + 1) + mlow;
	}
};
int main()
{
	srand(static_cast<unsigned>(time(nullptr)));

	Random r1{ 34, 67 };
	Random r2{ 90, 99 };

	for (int k = 0; k < 10; ++k)
		cout << r1() << " ";

	cout << "\n";

	for (int k = 0; k < 10; ++k)
		cout << r2() << " ";

	cout << "\n";

}
/////////////////////////////////////////////////////////////////////
Rastgele sayý üretimi fonksiyon çaðrý operatör fonksiyonu ile yapýlýyor.
Bunu yapan bir global fonksiyon olsaydý, bu durumda bu deðerler fonksiyon içinde
statik yerel deðiþken olabilirdi. Global fonksiyon çaðýrýlsaydý, aralýk deðerleri
fonksiyona argüman olarak geçilmeli, veya statik yerel deðiþken kullanmak gerekir.
Burada, bu nesneler ayný türden	ancak davranýþlarý farklý, davranýþlarýnýn nasýl
olacaðýný belirleyen ise ne þekilde construct edildikleri.


TÜR DÖNÜÞTÜRME OPERATÖR FONKSÝYONLARI

ival int türden bir deðiþken, m ise Myclass türünden bir nesne olduðunda
ival = m; ifadesi normalde sentaks hatasý çünkü Myclass türünden int türüne dönüþüm yok.
Ancak Myclass sýnýfýnýn int türüne dönüþüm gerçekleþtiren bir operatör fonksiyonu varsa
derleyici bu ifadeyi geçerli kýlar, durumdan vazife çýkartýp ival'e m nesnesinin operatör
int fonksiyonuna yapýlan çaðrýnýn geri dönüþ deðerini atar. Bu tür dönüþümleri yapan
fonksiyonlara tür dönüþtürme operatör fonksiyonlarý denir.

/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
public:
	Counter(int val = 0) : mx{val} {}
	void set(int val)
	{
		mx = val;
	}
	Counter &operator++()
	{
		++mx;
		return *this;
	}
	Counter operator++(int)
	{
		Counter temp{ *this };
		++*this;
		return temp;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	friend std::istream &operator>>(std::istream &is, Counter &c)
	{
		return is >> c.mx;
	}

	operator int()const
	{
		std::cout << "operator int()const" << endl;
		return mx;
	}

};
int main()
{
	Counter c{ 10 };

	int ival = c;
	//int ival = c.operator int();

	cout << "ival = " << ival << endl;

}
/////////////////////////////////////////////////////////////////////
Sýnýfýn tür dönüþtürme operatör fonksiyonu olmadýðýnda int ival = c; ifadesi geçersiz.
Çünkü Counter türünden int türüne otomatik dönüþüm yok ancak böyle bir dönüþüm mümkün
kýlýnabilir.
Tür dönüþtürme operatör fonksiyonlarý yazýlýrken yine operatör anahtar sözcüðü yazýlýr,
ardýndan hangi türe dönüþüm olacaksa o türün adý yazýlýr. int'e dönüþtüren operatör tür
dönüþtürme fonksiyonunun ismi operator int, double'a dönüþtürenin ismi operator double.
Hedef türün primitif bir tür olma zorunluluðu yok, hedef tür user defined türlerden de 
olabilir. Bu fonksiyonlar hemen her zaman const üye fonksiyonlar.
Fonksiyonun geri dönüþ deðeri türü yazýlmadý, durum burada constructor gibi deðil.
Constructor'ýn ve destructor'ýn geri dönüþ deðerinin türünün yazýlmamasýnýn sebebi
bu özel iþlevlerin geri dönüþ deðeri kavramý yok. Burada yazýlmamasýnýn sebebi ise 
zaten hedef tür bu fonksiyonun geri dönüþ deðerinin de türü. Burada tür yazýlmýyor olsa 
da derleyici fonksiyonun geri dönüþ deðeri türünün hedef tür olduðunu bilir. 
Counter türünden bir deðer nerede int'e dönüþtürülmesi gerekse derleyici bu dönüþümü, 
tür dönüþtürme operatör fonksiyonuna çaðrý yaparak gerçekleþtirir.
operator int() fonksiyonu, mx'i geri döndürdüðünden, ival = c ifadesinde ival'e c'nin
deðeri atanýr. 
int ival = c; ifadesi için derleyicinin yazmýþ olduðu kod ise int ival = c.operator int();


int main()
{
	Counter c{ 10 };

	int i1 = c;
	int i2 = c.operator int();
	int i3 = static_cast<int>(c);
	int i4 = (int)c;

	cout << i1 << endl;
	cout << i2 << endl;
	cout << i3 << endl;
	cout << i4 << endl;

}
/////////////////////////////////////////////////////////////////////
Derleyici otomatik olarak bu dönüþümü yapar, programý yazan olarak bu tür dönüþtürme operatörü
kullanýlarak da fiilen yaptýrýlabilir. Bu fonksiyonu devreye almanýn, çalýþtýrmanýn iki yolu
daha mevcut. Burada C tarzý tür dönüþtürme operatünü kullanmak da legal ancak tercih edilmemeli.
Bu yazým biçimlerinden hepsi tür dönüþtürme operatör fonksiyonunu çaðýrýr. Çaðrýlan fonksiyon da 
nesnenin private veri elemaný olan mx veri öðesini geri döndürür.


int main()
{
	Counter c{ 10 };

	double dval;

	dval = c;
}
/////////////////////////////////////////////////////////////////////
Dönüþümler iki kategoride, biri user defined conversion diðeri normal conversion.
User defined conversion, normalde yasak, dilin kurallarýna aykýrý, programcý bir 
fonksiyon bildirdiði için geçerli olan dönüþümler. Conversion Constructor da bir 
user defined conversion. 
Standart conversion onu izleyen user defined conversion veya tersi olmasý durumunda
derleyici dönüþümü otomatik olarak yapar.
Eðer dönüþüm arka arkaya iki tane user defined conversion yolu ile yapýlabiliyor ise
derleyici bunu asla otomatik olarak yapmaz.(tür dönüþtürme operatörü ile yapýlabilir)
dval = c ifadesi geçerli bir ifade çünkü c'den yani Counter türünden, int'e dönüþüm
user defined conversion, int'den de double'a dönüþüm standart conversion bu yüzden
derleyici otomatik tür dönüþümünü yapar. 


/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
public:
	Counter(int val = 0) : mx{val} {}

	explicit operator int()const
	{
		std::cout << "operator int()\n";
		return mx;
	}
};
int main()
{
	Counter c{ 356 };
	Counter c1;

	int ic1;

	ic1 = c; //geçersiz


	int i2 = c.operator int(); //geçerli
	int i3 = static_cast<int>(c); //geçerli
}
/////////////////////////////////////////////////////////////////////
c1 = c yazmak yerine yanlýþlýk ile ic1 = c yazýldýðý düþünülsün. Sentaks
hatasý deðil. C++11 öncesinde böyle dönüþümlerden kaçýnabilmek için kod yazýlmasý
gerekiyordu. Artýk problemin basit bir çözümü mevcut: iþi derleyiciye býrakmak.
Madem conversion constructor, explicit olabiliyor tür dönüþtürme operatörü de 
explicit olabiliyor. Bu durumda ancak tür dönüþtürme operatörü ile dönüþüme izin
verilir. tür dönüþtürme operatör fonksiyonu explicit yapýldýðýnda, ic1 = c; ifadesi
artýk geçersiz olur, çünkü otomatik tür dönüþümü yok. Bilerek isteyerek yapýlan
dönüþümler geçerli(i2 ve i3 için yapýlan dönüþümler açýk olarak tür dönüþtürme
operatörünün kullanýlmasýyla yapýldýðý için geçerli).

Bu fonksiyonlarýn explicit yapýlmasý, böylece dönüþüm hakký kimsenin elinden alýnmaz.
Dönüþümü gerçekleþtirmek isteyen, tür dönüþtürme operatörü ile veya operatör fonksiyonunu
ismi ile çaðýrarak dönüþümü gerçekleþtirir, explicit yapýlmasý ile de yanlýþlýkla 
dönüþümün yapýlmasýnýn önüne geçilmiþ olur.

double d = .365 ifadesi için, d deðiþkeni (int)d ile tür dönüþtürme operatörünün operandý 
yapýldýðýnda bu iþlemde bir yan etki yok. d'yi etkileyen bir iþlem deðil. Dolayýsýyla
bir nesne tür dönüþtürme operatörünün operandý yapýldýðýnda nesnenin deðeri deðiþmez.
(int)d ifadesinin gerçek operatör deðil de bir fonksiyon olduðu düþünüldüðünde d nesnesinin 
deðiþmeme garantisinin saðlanmasý için ya bu fonksiyon call-by-value olmalý ya da referans
semantiði ile çaðýrýlýyorsa da const referans olmasý gerekir. *this'i const olanlar da zaten
sýnýfýn const üye fonksiyonlarý. Dilin kurallarý tür dönüþtürme operatör fonksiyonlarýný const
olmak zorunda tutmuyor ama const olmayan bir tür dönüþtürme operatör fonksiyonu çaðýrýldýðýnda 
bunun sakýncalarý mevcut, yanlýþlýkla bu fonksiyon içinde nesne deðiþtirildiðinde herhangi bir
uyarý alýnmaz. Daha da önemlisi eðer ki tür dönüþtürme operatör fonksiyonu const olmasaydý,
örnekte eðer Counter c nesnesi const olsaydý bu durumda; int ival = c ifadesi geçersiz olurdu.
Çünkü const nesneler için sýnýfýn sadece const üye fonksiyonlarý çaðýrýlabilir.



/////////////////////////////////////////////////////////////////////
int main()
{
	string s = "mustafa"; 

	string t;

	t = "necati";
}
/////////////////////////////////////////////////////////////////////
const char * türünden string türüne otomatik tür dönüþümü var.
Bunun standart kütüphanenin string sýnýfý olmadýðý, üçüncü parti bir
kütüphanenin string sýnýfý olduðu düþünülsün. Bunu legal kýlan yapýlar,
sýnýfýn explicit olmayan bir const char * parametreli bir constructor'ý 
olabilir bu durumda derleyici otomatik olarak bu dönüþümü o ctor ile yapar.
t = "necati", explicit olmayan conversion constructor ile de yapýlýr. Ancak 
her ikisinde de explicit olmamasý gerekir.
t = "necati", bir atma iþlemi olduðundan sýnýfýn atama operatör fonksiyonu 
da olabilir, sýnýfýn const char * parametreli bir atama operatör fonksiyonu
varsa bu fonksiyon çaðrýlabilir.


/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "sinan" };

	strlen(s); //geçersiz
	
	strlen(static_cast<const char *>(s)); //geçersiz

	cout << strlen(s.c_str()) << endl; //geçerli

	

}
/////////////////////////////////////////////////////////////////////
String sýnýfýndan const char * türüne dönüþüm geçerli deðil.
Eðer dönüþüm var ancak explicit olsaydý, string sýnýfýnýn operator const
char * gibi bir fonksiyonu olmasý gerekirdi ki yok veya static_cast kullanýlýp
operand olarak string türünden nesne, hedef tür olarak const char * verilmesi
durumunda geçerli olmasý gerekirdi, geçerli deðil.
Ancak bu çok gereken bir iþlem olduðundan, isimlendirilmiþ fonksiyon olarak
C++'da mevcut, string sýnýfýnýn önemli fonksiyonlýndan biri c_str() fonksiyonu
bu durumlarda kullanýlýr. c_str() fonksiyonunun geri dönüþ deðeri türü const 
char *. 
Not: C tarzý bir yazýdan bahsedilirken yani C'de sonunda null karakter olan yazýlar
için cstring terimi kullanýlýr, string ise doðrudan C++'nýn string sýnýfý türünden
varlýklarý için kullanýlýr. çift týrnak içinde yazýlan yazýlanlar da string literali
olarak nitelendirilir.
String sýnýfýndan cstringe otomatik tür dönüþümü yok, ancak sýnýfýn bu dönüþümü yapan
c_str() ismli const üye bir fonksiyonu var.(Bu fonksiyon const char * döndürür yani
buradan bir adres alýp, yazý asla deðiþtirilmeye çalýþýlmamalý)


/////////////////////////////////////////////////////////////////////
int main()
{
	Counter c{ 235 };

	if (c)
		cout << "dogru\n";
	else
		cout << "yanlis\n";

}
/////////////////////////////////////////////////////////////////////
Counter sýnýfýnýn operator int() tür dönüþtürme operatör fonksiyonu
mevcut. Eðer önce user defined sonra standart conversion yapýlarak bir
dönüþüm mümkünse, derleyici bu dönüþümü otomatik olarak yapar. Bu durumda
böyle bir fonksiyon varsa, lojik baðlamda da bu fonksiyon kullanýlabilir.
if kontrol deyiminin içinde boolean deðer gerekir, derleyici durumdan 
vazife çýkartýp sýnýfýn operator int fonksiyonunu çaðýrýr, bu fonksiyonda
elde ettiði deðeri de bool türüne dönüþtürür, Derleyicinin ürettiði kod;
if(static_cast<bool>(c.operator int()));



/////////////////////////////////////////////////////////////////////
int main()
{
	Counter x{ 12 };
	
	int *ptr = c; //sentaks hatasý bool'dan int *'a dönüþüm yok

	double dval = c; //geçerli
}
/////////////////////////////////////////////////////////////////////
Ancak dönüþümü böyle yapmanýn dezavantajý da var, eðer sadece lojik dönüþüm
istenerek böyle bir kod yazýlmýþ ise, derleyicinin bunun yalnýzca lojik
dönüþüm için yazýldýðýný bilme imkaný yok, derleyici dilin kurallarýnýn izin
verdiði ölçüde çaðýrabildiði her yerde bu fonksiyonu çaðýrýr. Bunun yerine 
operator bool tür dönüþtürme fonksiyonu yazýlabilir ancak bunun da þöyle bir
zararý var: bool türünden bir deðiþkenin atanabileceði bir durumda kullanýlýrsa
sentaks hatasý olmayacak. double dval = c; ifadesi fonksiyonun amacý bunu gerçek-
leþtirmek olmasa da bunu da legal kýlmýþ olur çünkü dilin kuralýna göre önce
user defined conversion ardýndan standart conversion ile legalite saðlanýyorsa 
dönüþüm yapýlýr(atama anlamsýz olsa da dilin kurallarýna göre legal). C++11 öncesi
bu bir problemdi, hem operatör bool'un olmasý isteniyor ancak diðer taraftan bu 
fonksiyonun olmasý bazý baþka istenmeyen durumlarý da legal kýlýyor.

C++11 öncesinde ilginç bir teknik kullanýlýyordu, operator bool yerine operator void *
fonksiyonu yazýlýyordu.
/////////////////////////////////////////////////////////////////////
operator void *()
{
	return rand() % 2 ? nullptr : this;
}
int main()
{
	Counter c{25};

	double dval = c; //geçersiz, void *'dan double'a otomatik dönüþüm yok.

	if(c) //geçerli
	{}
}

/////////////////////////////////////////////////////////////////////
operator void * fonksiyonu yazýldýðýnda dönüþüm void * türüne yapýlýr. Pointer tür-
lerinden tamsayý türlerine otomatik dönüþüm yok. Bu durumda örneðin bir double'a
bir Counter nesnesi atandýðýnda fonksiyon dönüþümü yapmaz çünkü double'a void *
atanmaz. Ancak lojik konsept için fonksiyon kullanýlabilir, çünkü Counter türünden
bir nesneden void *'a dönüþüm, user defined conversion, void *'dan bool'a dönüþüm
ise var(nullptr false'a geri kalan hepsi true'ya dönüþür).



/////////////////////////////////////////////////////////////////////
class Counter {
	int mx;
public:
	Counter(int val = 0) : mx{ val } {}
	void set(int val)
	{
		mx = val;
	}
	Counter &operator++()
	{
		++mx;
		return *this;
	}
	Counter operator++(int)
	{
		Counter temp{ *this };
		++*this;
		return temp;
	}
	friend std::ostream &operator<<(std::ostream &os, const Counter &c)
	{
		return os << "(" << c.mx << ")";
	}
	friend std::istream &operator >> (std::istream &is, Counter &c)
	{
		return is >> c.mx;
	}

	explicit operator bool()
	{
		return rand() % 2 ? true : false;
	}
};

int main()
{
	Counter c{ 17 };

	double dval = c; //geçersiz

	if (c) //geçerli
		++c;
}
/////////////////////////////////////////////////////////////////////
C++11 ile bu durum ile ilgili kural deðiþikliðine gidildi. Bir sýnýfa operator bool 
fonksiyonu yazýldýðýnda ve bu fonksiyon explicit yapýldýðýnda baþka türe otomatik tür 
dönüþümü yasaklanmýþ olur. Yanlýþlýkla da olsa, dval'e, Counter türünden nesne atamak
sentaks hatasý. Ancak bu kurala, lojik bir context içinde bir Counter nesnesi kullanýldýðý
durumda fonksiyonun explicit olmasýnýn bu dönüþümü geçersiz kýlmayacðý þeklinde istisna
eklenmiþtir. Yani lojik anlamda kullanýldýðýnda dönüþüm yine de otomatik olarak yapýlýr.



23_12_2017 CUMARTESÝ

NESTED TYPES (ÝÇSEL TÜRLER)

Sýnýfýn Tür Öðeleri (Type Members)

/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	typedef int Word;
	using Uint = unsigned int; //C++11 ile
	class Member {
	public:
		void func();
	};

	enum {On, Off, Hold, StandBy}; //isim verilerek de kullanýlabilir.
};
/////////////////////////////////////////////////////////////////////
Bir türün bildirimini bir sýnýfýn içinde yapmak ile sýnýfýn dýþýnda
yapmak arasýnda fark var. Sýnýf içinde yapýldýðýnda, class scope'daki 
bir tür. C++'da tür eþ isimlerinin bildirimi sýklýkla sýnýf içerisinde
yapýlýr. Baþka bir sýnýf türünün bildirimi de sýnýf içerisinde yapýlabilir.
En sýk karþýlaþýlan nested type biçimleri; typedef bildirimleri, sýnýfýn 
bir öðesinin baþka bir sýnýf türünden olmasý ve enum.


int main()
{
	Word x; //geçersiz
	Myclass::Word x; //geçerli
	
	int y = Myclass::Off;
	Myclass::Member m;
}
/////////////////////////////////////////////////////////////////////
Bu türler artýk class scope'da. Word x; ifadesinin geçerli olmasý
için derleyicinin ismi class scope'da aramasý lazým, bunun için de 
çözünürlük operatörünün saðýnda olmasý gerekir.


/////////////////////////////////////////////////////////////////////
class Myclass {
	typedef int Word;
public:
	using Uint = unsigned int; //C++11 ile
	class Member {
	public:
		void func();
	};

	enum {On, Off, Hold, StandBy}; //isim verilerek de kullanýlabilir.
};
int main()
{
	Myclass::Word x; //access control hatasý

}
/////////////////////////////////////////////////////////////////////
Access control uygulanýr. Örneðin typedef bildirimi sýnýfýn private
bölümünde yapýlmýþ olsaydý, isim arama açýsýndan bir fark olmaz ancak 
access control'e takýlma durumu olur.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	class Member {
		void pfoo();
	public:
		void func();
	};

	Member mx;
};
/////////////////////////////////////////////////////////////////////
Bir türün sýnýfýn öðesi olmasý ile, sýnýfýn o türden bir data membera
sahip olmasý ayný þey deðil. Örnekte Myclass sýnýfýnýn, içsel türü olan
Member sýnýfý türünden bir veri öðesi mevcut.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	class Member {
		void pfoo();
	public:
		void func();
	};

	void mfunc() //Myclass'ýn üye fonksiyonu
	{
		Member m;
		m.pfoo(); //geçersiz, sýnýfýn private bölümüne eriþim geçersiz
	}
};
/////////////////////////////////////////////////////////////////////
Buradaki Member gibi bir türün, sýnýfýn öðesi olmasý, bu bildirimi 
içeren sýnýfýn yani Myclass sýnýfýnýn nested type'ý olan Member sýnýfýnýn
private bölümüne eriþebilmesi anlamýna gelmez. friend'lik verilmiþ olsa bu
eriþim geçerli olurdu. Member sýnýfý içerisinde friend Myclass; bildirimi
yapýlýp, Myclass sýnýfýna arkadaþlýk verilse idi, bu durumda Myclass sýnýfý,
Member sýnýfýnýn private bölümüne eriþebilirdi.


/////////////////////////////////////////////////////////////////////
class Myclass {
public:

	Word mword; //geçersiz
	typedef int Word;

};
/////////////////////////////////////////////////////////////////////
Word mword; ifadesi geçersiz. Eðer class definition içinde bir isim
aranacaksa(sýnýfýn üye fonksiyonu içinde deðil, sýnýfýn tanýmý içinde)
bu durumda isim arama kurallarý deðiþir, artýk sýnýfýn her yerinde aranmaz.
Ýsim class tanýmýndan baþlayarak, kullanýldýðý yere kadar aranýr, bulunmazsa
global alanda aranýr.


/////////////////////////////////////////////////////////////////////
class Word{
public:
	void foo();
};
class Myclass {
public:
	Word mword; //geçerli
	typedef int Word;

};
int main()
{
	Myclass m;
	m.mword.foo();
}
/////////////////////////////////////////////////////////////////////
Sýnýfýn veri elemaný olan mword, class Word sýnýfý türünden.


/////////////////////////////////////////////////////////////////////
class Word{
public:
	void foo();
};
class Myclass {
public:
	typedef int Word;
	Word mword; 


};
int main()
{
	Myclass m;
	m.mword.foo(); //geçersiz
}
/////////////////////////////////////////////////////////////////////
typedef int Word; bildirimi üste, Word mword; ifadesinin üstüne 
alýndýðýnda main'deki ifade geçersiz olur çünkü artýk Word sýnýf içindeki
tür. Sýnýf içinde kullanýlan(sýnýfýn tanýmý içinde kullanýlan üye fonksiyon
içinde deðil) bir isim arandýðýnda önce kullanýldýðý yere kadar class
definition'a bakýlýr ondan sonra bulamazsa global alana bakar ve kesinlikle
kullanýldýðý yerden daha aþaðýya bakýlmaz.



/////////////////////////////////////////////////////////////////////
class Word{
public:
	void foo();
};
class Myclass {
public:
	void func()
	{
		Word wx;

		wx = 7;

	}
	typedef int Word;

};
/////////////////////////////////////////////////////////////////////
Fonksiyonlarýn inline olmasý isim arama kurallarýný deðiþtirmez.
func() fonksiyonu içinde bildirilen, wx deðiþkeni int türdendir.
Ýsim arama aynen geçerli. Fonksiyonun tanýmýnýn sýnýf içinde deðil de 
cpp dosyasý içinde yapýldýðý düþünüldüðünde, isim arama kurallarýna 
göre isim önce blok içinde aranýr ardýndan class scope'da aranýr eðer 
bulunamazsa global alana bakýlýr. Ýsim class scope'da bulunduðundan 
wx, int türdendir.


/////////////////////////////////////////////////////////////////////
class Myclass {
	Word wx;
public:
	typedef int Word;
};
/////////////////////////////////////////////////////////////////////
Bir sýnýfý yazarken public veya protected bölümün hangisinin önce 
yazýlacaðý programcýya baðlý. Fakat bazý durumlarda koþullar bir bölümün
daha önce veya sonra yazýlmasýný gerektirebilir.
Private bölümün daha yukarýda yazýldýðý düþünülsün, public bölümde clientlara
da açýlan bir typedef bildirimi var, sýnýfýn veri elemaný ise bu türden.
Private bölümdeki Word wx; ifadesi geçersiz. Word ismi aranýrken aþaðýya
bakýlmaz ve isim bulunamaz. Bu durumda sýnýfýn public bölümü daha önce
private bölümü daha sonra oluþturulmalý böylece typedef bildirimi daha yukarýda
olduðundan ifade geçerli olur.


Private bölümde ne olduðu hedaer dosyasý ile beraber client kodlara da gösterilmiþ olur.
/////////////////////////////////////////////////////////////////////
//onder.h
Neco nec;
Class Onder{
	Neco nec; //sentaks hatasý
	Neco *pnec; //geçerli
public:
};
/////////////////////////////////////////////////////////////////////
Ýlk ifadenin geçerli olmasý için Neco ismi ile belirlenen türün complete olmasý
gerekir, pointer olduðundaysa incomplete type olmasý yeterli.
Sýnýfýn veri elemaný baþka bir sýnýf türünden olacaksa bu sýnýfý kullanacak kodlara 
Neco sýnýfýnýn tanýmýný da göstermesi gerekir. Bu durumda onder.h, Neco sýnýfýnýn tanýmýnýn 
olduðu Neco.h'yý dahil etmeli.
onder.h, neco.h'yý include edecek bu durumda artýk onder.h'yý include eden bütün client
dosyalar neco.h'yý da include etmiþ olur, hem compile time süresi uzamýþ olur hem de artýk
Neco'nun interface'inde yapýlan bir deðiþiklik aslýnda doðrudan onder.h'nýn clientlarýný 
ilgilendirmese de onder'in clientlarýnýn da tekrar derlenmesi gerekecek.

Pimple Ýdiyomu: Pimple idiyomu kullanýlarak sýnýfýn private bölümü tamamen client kodlardan
gizlenebilir. C++11 ile birlikte, pimple idiyomu eski C++'ya göre akýllý pointerlarýn 
kullanýlmasý ile kolaylaþtý.
Örnekte pimple idiyomu, Fighter sýnýfý üzerinde gerçeklendi, sýnýfýn private bölümü birinci
versiyonda dýþarýya açýldý ikinci verisiyonda ise dýþarýya kapatýldý. Öncelikle sýnýfýn
private bölümü dýþarýya açýlacak þekilde kod yazýldý.

/////////////////////////////////////////////////////////////////////
Birinci versiyon..
/////////////////////////////////////////////////////////////////////
///fighter.h///
#pragma once
#include <string>
#include <vector>
#include "weapon.h"

class Fighter {
	Weapon mweapon;
	std::string mname;
	std::vector <std::string> mfriendvec;
	int mage;
public:
	Fighter();
	void func();
};
/////////////////////////////////////////////////////////////////////
///fighter.cpp///
#include "fighter.h"

Fighter::Fighter() : mname{"hakan"}, mfriendvec{"ali", "selim", "hasan"}
{
	mage = 23;

}
void Fighter::func()
{
	++mage;
	mname += "can";
	mfriendvec.push_back("nizam");

	mweapon.maintain();
}
/////////////////////////////////////////////////////////////////////
///weapon.h///
#pragma once

class Weapon {
public:
	void maintain();
};
/////////////////////////////////////////////////////////////////////
///client kod///
#include "fighter.h"

int main()
{
	Fighter f;
	f.func();
}
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
Sýnýfýn string sýnýfý ve vector sýnýfý türünden veri elemanlarý olduðundan 
string ve vector baþlýk dosyalarý include edildi. Bu durumda fighter baþlýk
dosyasýný include eden tüm kodlar string ve vector sýnýfýnýn baþlýk dosyalarýný
da dahil etmiþ olur. Yine ayný þekilde weapon sýnýfýný da dahil etmiþ olur.
Sýnýfýn private bölümünü, client kodun hiç görmemesi istenebilir. Ancak bu 
sürümde diðer bir nokta ise, client kod fighter sýnýfýný dahil ettiðinde string,
vector ve weapon sýnýfýný da dahil etmiþ olacak. Bu durumda örnek olarak weapon
deðiþtiðinde sadece figther'in tekrardan derlenmesi yeterli olmayacak, fighter'ý 
include eden kodlarýn da tekrar derlenmesi gerekecek, bu büyük bir projede bir
problem, hem compile time süresi uzar hem de bu baðýmlýlýk iliþkisi nedeni ile 
deðiþiklikler baþka kodlara yansýmýþ oluyor.
client kodda, fighter.h include edildi ancak ne vector sýnýfý ne string sýnýfý
ne de weapon sýnýfý doðrudan kullanýldý ancak üçü de include ediliþ oldu.
Ayný zamanda fighter.h include edidliði için, sýnýfýn private bölümü client kodlar
tarafýndan da görülmekte.

Yapýlacak olan hile ile, main.cpp gibi client kodlar, fighter sýnýfýný kullanmalarýna
karþýn fighter'ýn include ettirdiði string, vector ve weapon baþlýk dosyalarýný
include etmeyecek. Yani bu baþlýk dosyalarýna herhangi bir deðiþiklik olduðunda
client kod bundan etkilenmeyecek, client kodun tekrar derlenmesi dahi gerekmeyecek.
Ýþte bunu yapan idiyoma pimple idiyomu denir. Ayný zamanda sýnýfýn private bölümü
de client kodlara hiç gösterilmeyecek.

/////////////////////////////////////////////////////////////////////
Ýkinci versiyon, pimple idiyomu..
/////////////////////////////////////////////////////////////////////
///fighter.h///
#pragma once
class Fighter {
	struct Pimple; //forward declaration
	Pimple *mp;

public:
	Fighter();
	void func();

};
/////////////////////////////////////////////////////////////////////
///fighter.cpp///
#include "fighter.h"
#include "weapon.h"
#include <string>
#include <vector>

struct Fighter::Pimple //baþlýk dosyasýnda bildirilen sýnýfýn tanýmý
{
	Weapon mweapon;
	std::string mname;
	std::vector <std::string> mfriendvec;
	int mage;

	Pimple() : mname{ "hakan" }, mage{ 23 }, mfriendvec { "ali", "selim", "hasan" }
	{
		///
	}
};
Fighter::Fighter() : mp{new Pimple}
{
}
void Fighter::func()
{
	++mp->mage;
	mp->mname += "can";
	mp->mfriendvec.push_back("nizam");

	mp->mweapon.maintain();
}
/////////////////////////////////////////////////////////////////////
///weapon.h///
#pragma once

class Weapon {
public:
	void maintain();
};
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
fighter.h'daki #include deyimleri ve sýnýfýn private bölümü silindi.
Sýnýfýn private bölümünde struct Pimple(class da olabilir) isminde
bir forward declaration yapýldý. Bu forward declaration sýnýfýn içinde
yapýldýðýndan bir nested type'a iliþkin. Bir de bu Pimple türünden bir
pointer öðe olarak private bölüme konur.(öðe pointer olduðundan type'in
complete olmasý gerekmiyor)
Client kod açýsýndan bakýldýðýnda, derlenmesi ile ilgili herhangi bir 
problem yok, yine Fighter sýnýfý türünden nesne ile sýnýfa iliþkin
iþlemleri yapabilir ancak vector, string ve weapon baþlýk dosyalarý
dahil edilmedi.
Client kod sýnýfýn private bölümünü yine görüyor ancak orada sadece
bir forward declaration ve sýnýf türünden bir pointer var dolayýsý ile
private bölüme bakýlarak herhangi bir fikir sahibi olunamaz.
Baþlýk dosyalarý  fighter.cpp dosyasýnda include edilir, bu durumda 
include'ý sadece fighter.h nýn kendi cpp dosyasý yapmýþ olur.
Baþlýk dosyasýnda forward declarationu yapýlan struct Pimple'ýn tanýmý
fighter.cpp'de yapýlýr. Bir önceki versiyonda sýnýfýn private bölümünde
bulunan öðeler artýk Pimple sýnýfýnýn öðeleri yapýlýr.
Fighter sýnýfýnýn constructorý veri elemaný olan mp'yi construct eder.
Pimple sýnýfýnýn constructor'ý ise birinci versiyondaki Fighter sýnýfýnýn
constructorýnýn yaptýðýný yapar.
Fighter'ýn ctor'u dinamik pimple nesnesinin adresini sýnýfýn mp isimli
veri öðesinde tutar, sýnýfýn destructorýnýn yapmasý gereken bunu delete
etmek. 
Önceki versiyonda büütün fonksiyonlar veri elemanlarýný isimleri ile kullandý,
þimdi artýk isimleri ile kullanmak yerine öðesi olan mp yolu ile kullanacaklar.

Pimple idiyomunun da bazý negatif taraflarý var; ilk olarak dinamik bellek
yönetimi kullanýlýyor, normalde yaratýlmayacak bir dinamik nesne yaratýlýyor.
Ancak çok verim kritik bir uygulama olmadýðýnda büyük bir problem deðil.

C++11 ile burada normal pointer kullanmak yerine unique pointer kullanýlmasý
durumunda bu dinamik nesnenin kimse tarafýndan delete edilmesine gerek kalmaz.
Veri elemaný olan unique_ptr nesnesinin hayatý bittiðinde destructor'ý çaðrýlýr,
onun destructor'ý da dinamik nesneyi delete eder. Bu durumda sýnýfýn veri elemaný
Pimple açýlýmý türünden bir unqieu_ptr pointeri yapýlýr.


/////////////////////////////////////////////////////////////////////
class Myclass {
	class Neco {
		int mx, my;
	public:
		Neco(int a, int b);
		void func();
	};
};

///myclass.cpp///
Myclass::Neco::Neco(int a, int b) ::mx{ a }, my{b}
{}
void Myclass::Neco::func()
{
	++mx;
	++my;
}
/////////////////////////////////////////////////////////////////////
Nested type olan Neco sýnýfýnýn üye fonksiyonlarý iki þekilde taným-
lanabilir. Inline olarak tüm sýnýflarda olduðu gibi fonksiyonar sýnýf
içinde tanýmlanabilir. Ýkincisi ise bu fonksiyonlarýn tanýmlarýnýn da
.cpp dosyasýnda yapýlabilmesi.


/////////////////////////////////////////////////////////////////////
class Myclass {
	class Neco {
		int mx, my;
	public:
		Neco(int a, int b);
		void func();
		Neco(const Neco &r);
		Neco &operator=(const Neco &r);
	};
	/////// nested type'a iliþkin fonksiyon tanýmlarý burada yapýlamaz.
	static Neco necx;
};

///myclass.cpp///

Myclass::Neco Myclass:necx{7}

Myclass::Neco & Myclass::Neco::operator=(const Neco &r)
{
	mx = r.mx;
	my = r.my;
	return *this;
}

Myclass::Neco::Neco(const Neco &r) : mx{r.mx}, my{r.my}
{

}

Myclass::Neco::Neco(int a, int b) :mx{ a }, my{b}
{}

void Myclass::Neco::func()
{
	Neco nec{ 2, 5 }; //Myclass::Neco{2, 5}
	++mx;
	++my;
}
/////////////////////////////////////////////////////////////////////
Copy constructor'ýn tanýmý yapýlýrken, parametre deðiþkeninin türü
yazýlýrken Neco ismi kullanýldý, Myclass::Neco yazýlmasýna gerek yok
çünkü o bölüm artýk bir scope. Yine ayný þekilde func fonksiyonu içinde
Neco türünden bir yerel nesne tanýmlanýrken Neco, Myclass::Neco gibi
yazýlarak nitelenmedi.
Ancak fonksiyonlarýn geri dönüþ deðerinin türünün yazýldýðý yer class
scope içinde kabul edilmez. Sýnýfýn atama operatör fonksiyonu yazýlýrken
Neco & Myclass::Neco::operator=(const Neco &r){}
þeklinde yazýlmasý halinde derleyicinin verdiði hata mesajý () içindeki
bölümle alakalý deðil. Ancak geri dönüþ deðerinin türünün yazýldýðý yer
class scope'da olmadýðýndan Myclass ismi ile nitelemeden yazmak geçersiz.
Bir nested type'a iliþkin üye fonksiyonlarýn tanýmý bu nested type'in 
tanýmýný kapsayan sýnýf içinde yapýlamaz.

/////////////////////////////////////////////////////////////////////
int main()
{
	list<string> mylist{ "ali", "veli", "sinan", "dursun", "sena" };

	list<string>::iterator iter = mylist.begin();
	//auto iter = mylist.begin();

	while (iter != mylist.end())
	{
		cout << *iter << endl;
		++iter;
	}
}
/////////////////////////////////////////////////////////////////////
Standart kütüphanede, container sýnýflarýn da içsel türleri vardýr.
iterator isimli içsel türler, vektörde veya baðlý listede tutulan öðelerin 
konum bilgisini tutan akýllý pointer sýnýflarý. Yani list'in iteratorü
türünden bir nesnenin varlýk nedeni, liste içinde tutulan bir öðenin
konumunu tutmak.


/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "mustafa elkar" };

	string::size_type len = s.length();
	//auto len = s.length();


}
/////////////////////////////////////////////////////////////////////
sýnýfýn length fonksiyonun geri dönüþ deðeri, tutulan yazýnýn uzunluðu.
Bu geri dönüþ deðerinin türü, bir nested type olan size_type türü.
size_type, string sýnýfýnýn içinde yapýlan bir typedef bildirimi.


STANDART STRING SINIFI

string sýnýfý ayný zamanda bir container. string sýnýfý veri yapýsý olarak bakýldýðýnda
bir dinamik dizi. string aslýnda bir sýnýf þablonu, string ise bir typedef ismi yani string
bir template sýnýfýn açýlýmýnýn typedef ismi.

C++'da ismi basic_string olan bir template var.

template<typename Ctype>
class BasicString{};

Buradaki template tür parametresi, yazýnýn karakterlerinin türü. Eðer Ctype char ise 
yazýnýn her bir karakteri char. Farklý Ctype türleri için farklý string sýnýflarý
yazýlabilir. Bu basic string sýnýfýnýn template tür parametresi olan Ctype yerine
char alýnmýþ halinin typedef ismi string.
string baþlýk dosyasýnda, typedef BasicString<char> string; gibi bir typedef bildirimi
mevcut, yine string baþlýk dosyasýnda typedef BasicString<wchar_t> wstring; bildirimi var
wchar_t türü 2 bytle'lýk karakter türü, bunun ismi de wstring;
Standart kütüphane C++11'deki eklemeler ile birçok string sýnýfýnýn template kodunu kendisi
verir. String baþlýk dosyasý dahil edildiðinde tüm bu template kodlar kullanýlabilir.
Gerçek string sýnýfýnýn kodunu compile time'da derleyici yazar.
String büyük bir sýnýf, çok fazla fonksiyonu var, örnek olarak 40'a yakýn arama fonksiyonu var,
string sýnýfý normal bir sýnýf olsaydý bütün bu kodlar derlenecekti. Ancak templatelerin getirdiði
önemli avantajlardan biri client kod fonksiyonlardan hangisini çaðýrýrsa derleyici onun kodunu
yazar. Sýnýfýn 300 tane üye fonksiyonu olabilir, bir string nesnesi yaratýldýðýnda derleyici
ctor ve destructor'ý yazar, hangi fonksiyona iliþkin iþ yapýlmýþsa derleyici onun kodunu yazar.
 
basic_string'in aslýnda 3 tane template türü parametresi var.

template <typenam Ctype, typename T, typename A>
class String{};

Ctype -> yazýdaki karakterlerin türü, T -> traits denilen tür, A -> allocator denilen tür.
Derleyiciye sýnýfýn kodunu yazdýrmak için sadece Ctype'ýn ne olduðunu söylemek yetmiyor,
ikinci ve üçüncü template tür parametrelerinin de ne olduðunu söylemek gerekiyor.
Templatelarda kullanýlan araçlardan biri, template tür parametrelerinin varsayýlan tür
argümaný almasý, burada da o kullanýlýyor.
template <typenam Ctype, typename T = std::char_traits<Ctype>, typename A = Allocator<Ctype>>
Compile time'da derleyiciye T türünün ne olduðu söylenmezse, derleyici T türünün ne olduðunu
varsayýlan tür argümanýndan anlar.
Ýkinci template tür parametresi, yazýnýn karakterleri ile ilgili iþlemlerin tanýmlandýðý sýnýf.
Üçüncü template tür parametresi ise yazýnýn tutulacaðý dinamik bellek ile ilgili iþlemlerin
nasýl yapýlacaðýný belirleyen sýnýf.
Çok özel bir durum olmadýkça, bu default tür argümanlarý seçilir.

/////////////////////////////////////////////////////////////////////
int main()
{
	basic_string<char, char_traits<char>, allocator<char>> s;	
	basic_string<char >s;

	string s{"neco"}; //client kodun yazdýðý

}
/////////////////////////////////////////////////////////////////////
Ýkisi birbirine eþ, varsayýlan tür argümaný aldýðýndan, ikinci ve üçüncü tür parametresi
yazýlmasa da yazýlmýþ muamelesi yapýlýr. Yukarýdaki sýnýfýn typedef ismi de zaten string.
derleyici string s{"neco"}; ifadesini yorumlarken varsayýlan tür argümaný aldýðýný da
hesaba katarak kod üretir.


23_12_2017 PAZAR

String sýnýfý þablondan türetilmiþ bir sýnýf, derleyici kodlarýný compile time'da yazar.
Yazýnýn karakteri olacak türün ne olduðuna baðlý olarak yazýnýn karakterleri ile ilgili temel
iþlemlerin nasýl yapýlacaðýna iliþkin tür bilgisinin ne olduðunda baðlý olarak ve arka plandaki
bellek iþlemlerinin nasýl yapýlacaðýna baðlý olarak farklý farklý sýnýflar oluþturulabilir.
Standart kütüphanenin verdiði template, basic_string. Bunun char açýlýmý alýndýðýnda, diðer iki
template tür parametresi de default olarak seçildiðinde bu sýnýf string sýnýfý olmuþ olur.

Ýki string sýnýfý önemli; string ve wstring.
wstring, basic_string þablonunun wchar_t türü için açýlmýþ hali. Özellikle windows kendi apilerinde
bunu kullanýr(yazýnýn bir karakteri 2 byte)
Sýnýfý öðrenirken öncelikle nested type'lara bakýlabilir, ardýndan sýnýfýn public, static elemanlar
varsa bunlar öðrenilebilir sonrasýnda ise detaylý bir þekilde interface öðrenilebilir.

String sýnýfýnda size_type isimli bir nested type var. Bu string sýnýfý için size_t'nin typedef ismi.
Yani aslýnda string::size_type'ý demek size_t demeye eþ ancak yine de bu tür kullanýlmasý gereken
yerde size_t yerine açýkça bu tür kullanýlmalý. string'in size_type'ý; tane, adet türü (bazý
fonksiyonlar parametre olarak tane, adet ister), uzunluk türü(bir yazýnýn uzunluðu), index türü
deðerleri string'in size_type'ý türünden.
Yazýnýn bir karakterinin konumu söz konusu olduðunda index veya iterator kullanýlýr.
string sýnýfý, kendi tuttuðu yazýnýn adresini doðrudan vermez, interface iterator'e veya index'e
dayalý. Yazýnýn indexinin türü de yine string'in size_type'ý. Arama fonksiyonlarýnýn hepsi size_type
döndürür(index döndürür). Bizim sistemimizde size_t'de unsigned int'in typedef eþ ismi.

Nested type olarak bütün containerlarda olan nested typelar; 
string::iterator
string::const_iterator
string::reverse_iterator
string::const_reverse_iterator da string sýnýfýnýn içsel türleri.
Bunlar pointer like interface'e sahip sýnýflar gibi. Bu türden nesnelerin deðeri yazýnýn karakterlerinin
konumu. Tüm stl'in ortak arayüzü.

/////////////////////////////////////////////////////////////////////
int main()
{
	string name{ "sinan sezgin" };
	string::const_iterator iter = name.begin();

	while (iter != name.end())
	{
		cout << *iter << " ";
		++iter;
	}
}
/////////////////////////////////////////////////////////////////////

Hangi container olursa olsun(vektör, liste...); containerda tutulan öðeler düþünüldüðünde, containerdaki
her öðenin bir konumu var. Konum bilgisini tutmak için iterator türleri var. Container sýnýfýn begin()
fonksiyonuna çaðrý yapýlýrsa, begin fonksiyonu iterator döndürür, bu iterator konum tutan nesne. begin()
fonksiyonu containerdaki ilk öðenin konumunu tutan bir iterator döndürür. 
Sýnýflarýn bir de end() isimli fonksiyonlarý var, end() fonksiyonu da begin() gibi iterator döndürür.
end() fonksiyonunun geri dönüþ deðeri olan iterator, özel bir iterator ---> end iteratoru.
Tuttuðu konum, containerda bir öðe daha olsaydý onun konumu olacaktý ama yok. Containerda tutulan bir 
öðenin konumunu tutan bir iteratoru sürekli arttýrýrsak belirli bir noktada end() fonksiyonunun
verdiði geri dönüþ deðerine eþit olur.
for(iter = c.begin(); iter != c.end(); ++i) þeklinde yazýlmýþ bir döngüde bütün container dolaþýlmýþ olur.
Döngünün gövdesinde *iter ile, hangi container sýnýfý olduðundan baðýmsýz olarak containerin öðelerine
eriþilir.
Stl'in 3 önemli bileþeni var, bunlardan biri container sýnýflar, diðeri iteratorler bir diðeri ise
algoritmalar. Algoritmalar, iteratorlere göre yazýlmýþ fonksiyon þablonlarý.
Örnek olarak reverse algoritmasý düþünüldüðünde; reverse(iterator beg, iterator end), bu algoritmada
benzer döngüye sahip, iterator != end() koþulu ile çalýþýr. C++'da buna range denir, range iki tane
konumdan oluþur.Range'deki öðelere ikinci konum dahil deðil yani [beg, end), beg dahil ancak end
dahil deðil. Containerin end() fonksiyonunun geri dönüþ deðeri bir iterator verir ama o iterator
konumunda bir nesne yok, o iterator konumu sadece range'in sonunu belirlemek için kullanýlýr.
C++11 öncesinde, iterator veren fonksiyonlar sýnýflarýn sadece üye fonksiyonlarýydý ancak artýk modern
C++11 ile iterator veren diziler dahil, ayný zamanda global fonksiyonlar da var.

Bir dizi bile iterator veren fonksiyonlar ile dolaþýlabilir.
Range semantiði diziler için de geçerli.
/////////////////////////////////////////////////////////////////////
int main()
{
	int a[] = { 2, 5, 7, 1, 8, 13, 78 };

	for (auto iter = begin(a); iter != end(a); ++iter)
		cout << *iter << "\n";
}
/////////////////////////////////////////////////////////////////////


Bu normal bir dizi deðil de, bir vektör olsaydý, kodda baþka bir deðiþiklik yapýlmasýna
gerek yok, iterator semantiði bütün containerlar için geçerli. 
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<int> a = { 2, 5, 7, 1, 8, 13, 78 };

	for (auto iter = begin(a); iter != end(a); ++iter)
		cout << *iter << "\n";
}
///////////////////////////////////////////////////////////////////// 



/////////////////////////////////////////////////////////////////////
template<typename Iter>
void display(Iter beg, Iter end)
{
	while (beg != end)
	{
		std::cout << *beg << " ";
		++beg;
	}
	std::cout << std::endl;
}
int main()
{
	int a[] = { 2, 45, 34, 35, 7, 12, 9, 44 };
	display(begin(a), end(a));

	list<string> slist{ "muzaffer", "ali", "cumali", "zeynep" };
	display(begin(slist), end(slist));

}
/////////////////////////////////////////////////////////////////////
Derleyici compile time'da yazdýðýmýz þablondan hareketle bir fonksiyon yazdý, fonksiyonun kodunu
derledi ve run time'da o fonksiyonun kodu çalýþtý ve a dizisinin elemanlarý ekrana yazýldý.
Ardýndan derleyici ayný kodu kullanarak bu sefer baðlý listeyi dolaþtý. Container'in begin() ve
end() fonksiyonlarýnýn geri dönüþ deðerleri veya global begin() ve end() fonksiyonlarýnýn geri dönüþ
deðerleri bir containerin full range'ini oluþturur. Bir container'ýn tamamý üzerinde iþlem yapýlacaksa
tek yapýlmasý gereken, container'in begin() ve end() fonksiyonlarýnýn geri dönüþ deðerlerini bir 
range olarak kullanmak. string sýnýfý da range interface'ini destekler. 


stl'in en önemli algoritmalarýndan biri sort, bir sýralama algoritmasý bir range ister, o range'deki
öðeleri sýralar, ilave argüman geçilmezse default küçükten büyüðe sýralar. string de bir container 
olduðundan onun da iteratörleri var o yüzden bir algoritma string sýnýfý üzerinden de çalýþtýrýlýr.
(algoritmalar global fonksiyon þablonlarý, sýnýfýn üye fonksiyonlarý deðil)
sort fonksiyonu da bir þablon, derleyici kodunu compile time'da yazar.	
reverse algoritmasý bir range'i(container deðil, bu range bir stringin, vector'un veya bir baðlý
listenin range'i olabilir, tek ypaýlmasý gereken range'i girmek) ters çevirir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "fethiyildiz" };

	reverse(str.begin(), str.end());
	cout << str << endl;
	
	sort(str.begin(), str.end());
	cout << str << endl;

}
/////////////////////////////////////////////////////////////////////


string sýnýfý söz konusu olduðunda bazý iþlemler string sýnýfýnýn interfaceindeki sýnýfýn üye 
fonksiyonlar tarafýndan yapýlýr ancak her iþlem deðil, bazý iþlemler algoritma denilen global
fonksiyonlara yaptýrýlýr. string sýnýfýnýn reverse diye bir fonksiyonu yok çünkü reverse algoritmasý
sadece string'in deðil bütün range'leri reverse ediyor.

begin() ve end() fonksiyonlarý aslýnda template. Global begin() fonksiyonu referans parametreli,
nesneyi alýr, referans yolu ile olduðu için onun begin() fonksiyonunu çaðýrýr.
begin() ve end() fonksiyonlarý template. Global begin() fonksiyonu referans parametreli, nesneyi alýr
referans yolu ile olduðundan onun begin() fonksiyonunu çaðýrýr. Yani global begin fonksiyonu þöyle;
/////////////////////////////////////////////////////////////////////
template <typename T>
????? begin(T &r)
{
	r.begin();
}
/////////////////////////////////////////////////////////////////////
GLobal fonksiyon olan begin() ile üye fonksiyon olan begin() arasýnda container sýnýf nesneleri söz
konusu olduðu zaman fark yok. Diziler söz konusu olduðunda hiçbir zaman bir sýnýf nesnesi gibi nokta
operatörü ile a.begin() gibi bir çaðrý yapmanýn yolu yok, dizi ismi sýnýf nesnesi deðil. Global begin()
ve end() fonksiyonlarýnýn dile eklenmelerinin önemli nedenlerinden biri de dizileri de containerlar 
gibi iteratörler ile kullanabilme. Templatelar ile ilgili araçlar söz konusu olduðunda, begin()'e
bir dizi gönderildiði zaman derleyici derleme zamanýnda farklý farklý templatelar arasýndan hangisini
seçmesi gerektiðini anlar, uygun template'in döndürdüðü deðer de dizinin ilk elemanýnýn adresi.
Global begin() ve end() fonksiyonlarý olmasaydý önceki örnekteki display() fonksiyonunu çaðýrmak için
ilk öðenin konumu olarak dizinin baþlangýç adresi, end konumu olarak da dizinin bittiði yerin adresi
verilirdi. Modern C++11 öncesi dizi üstünde bir algoritmayý çalýþtýrmak için örnekteki kodu yazmak 
gerekiyordu. 
/////////////////////////////////////////////////////////////////////
template<typename Iter>
void display(Iter beg, Iter end)
{
	while (beg != end)
	{
		std::cout << *beg << " ";
		++beg;
	}
	std::cout << std::endl;
}
int main()
{
	int a[] = { 2, 45, 34, 35, 7, 12, 9, 44 };
	
	display(a, a + sizeof(a) // sizeof(*a)); //Eski C++
	display(a.begin(), a.end()); //derleyici bunu compile time'da yukarýka gibi ele alýr.
}

/////////////////////////////////////////////////////////////////////  

Eðer string sýnýfýnýn bir üye fonksiyonunun parametresi const char * ise, argüman olarak cstring alýr.
(cstring: sonunda null karakter olan bir yazý): s.func(const char *p)
func fonksiyonuna sonunda null karakter olan C'deki yazýlar geçilir(string literali veya char dizi içinde
tutal bir yazý). Bu durumda yazýnýn sonunda null karakter olmasý programcýnýn sorumluluðunda, fonksiyona
argüman olarak geçilen yazýnýn sonunda null karakter yoksa, run time error.
const char * ile buffer parametre karýþtýrýlmamalý, buffer'da const char *T var fakat ikinci parametre
olarak size_type türünden n var. "Bu adresten baþlayarak bu kadar karakter", burada null karakterin bir 
önemi yok.
basic_string& assign (const charT* s); //cstring parametre
basic_string& assign (const charT* s, size_type n); //buffer parametre
basic_string& assign (InputIterator first, InputIterator last); //range parametre

Range parametre, iki tane konum demek, birinci konum dahil ikinci konum hariç. Normal adresler de bir
range. argüman olarak (str, str + 5) deðerleri gönderilirse range parametreli fonksiyon çaðýrýlýr bu durumda
fonksiyon str dahil str + 5 hariç, aradaki yazýyý kullanýr. 
Bir string fonksiyonuna normal bir C adresi 3 farklý þekilde geçilebilir:
1) Sadece adres: bu durumda cstring olarak alýnýr, null karakter görene kadar gider.
2) Bir adres ve iþaretsiz tamsayý: adresten baþlayarak n karakter alýr
3) Ýki adres: range olarak kabul edilir, ilk adres dahil son adres hariç aradaki tümü 

basic_string& assign (size_type n, charT c); argüman olarak n tane c karakterinden alýr.
popüler olarak fill parametre denir. Burada null karakterde fonksiyona geçilebilir.

basic_string& assign (initializer_list<charT> il); initializer list sýnýfý parametreli. 
initializer list(küme parantezi içinde virgüllerle ayrýlmýþ öðeler)  

basic_string& assign (const basic_string& str); string parametreli

basic_string& assign (basic_string&& str) noexcept; move parametre, parametre string &&.
Böylece bu fonksiyona bir sað taraf deðeri ile çaðrý yapýldýðýnda taþýma iþlemi gerçekleþir.
Yani assign fonksiyonuna gönderilen string bir l-value ise kopyalama yapýlýr ancak bir r-value
ise bu assign overloadu çalýþýr ve sað taraf deðerindeki yazý taþýnýr.

basic_string& assign (const basic_string& str, size_type subpos, size_type sublen); buna da 
substring parametre denir. Parametre olarak bir string, bir pozisyon ve kaç karakter olduðu
bilgisini alýr. Stringin o indexinden baþlayarak, uzunluk kadar assign eder.  

/////////////////////////////////////////////////////////////////////
int main()
{
	string s;
	string name{ "muhittin" };
	char str[100] = "berkay";

	s.assign(str);

	cout << "(" << s << ")" << endl; //kaynak olarak str yazýsý kullanýlýr

	s.assign(str + 1, 4);

	cout << "(" << s << ")" << endl; //str + 1 adresinden baþlayarak 4 karakter

	s.assign(str + 1, str + 4);

	cout << "(" << s << ")" << endl; //str + 1 adresinden baþlayarak str + 4'e kadar

	s.assign(15, 'a'); //fill parametre

	cout << "(" << s << ")" << endl; 

	s.assign({ 'a', 'b', 'd' }); //initializer list parametre
	 
	cout << "(" << s << ")" << endl;

	s.assign(name); //string parametreli

	cout << "(" << s << ")" << endl;

	s.assign(name, 2, 3);

	cout << "(" << s << ")" << endl; //substring parametre

}
/////////////////////////////////////////////////////////////////////
str'nin tanýmý char str[] = "berkay" þeklinde yapýlsaydý ve buffer parametreli olana
s.assign(str, 20); geçilseydi compile time'da kod geçerli ancak run time hatasý.
null karakteri görmez, adresten baþlayarak 20 karakteri almýþ olur.

String sýnýfýnýn iki tane uzunluk döndüren fonksiyonu var, size ve length fonksiyonlarý.
Ýkisi de ayný deðeri döndürür, yazýnýn uzunluðu. size, bütün containerlarýn ortak interface'i.
Bir containerin size fonksiyonunun geri dönüþ deðeri, containerda tutulmakta olan öðe sayýsý.
(tek bir istisna olarak forward_list, onun size'ý yok). Bir yazýnýn size'ý olmaz uzunluðu
olur dolayýsý ile length fonksiyonu zaten string'in doðal interface'i ama string de bir 
container olduðundan size fonksiyonu onun için de kullanýlýr. Client ikisini de çaðýrabilir,
aralarýnda fark yok.

Containerlarýn hepsinin empty fonksiyonu var. empty, makempty anlamýnda deðil isempty anlamýnda.
Containerlarýn empty fonksiyonlarýnýn geri dönüþ deðeri türü Bool, boþ ise true boþ deðil ise
false deðer döndürür. Dolayýsý ile container'ýn içinde öðe var mý yok mu sorgulamasý yapýlýrken
size() == 0 demekle empty() demek arasýnda fark yok, empty()'nin constant time olma garantisi 
mevcut bu yüzden sadece string deðil tüm container sýnýflarý için boþ mu sorgulamasý yapýlýrken
empty() fonksiyonu kullanýlýr.

Bir string sýnýfý nesnesi kaç farklý þekilde construct edilebilir ?
String construct etmenin yollarý, sýnýfýn constructorlarý:
assign'daki tüm parametre çeþitleri burada da mevcut.
Default ctor: Henüz bir yazý tutmayan, boþ yazý tutan, uzunluðu sýfýr olan bir yazýyý tutan string.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s;

	cout << "uzunluk: " << s.size() << endl;

	if (s.empty())
		cout << "Bos Yazi\n";
	else
		cout << "Yazi bos degil\n";

}
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "aykut demiralp" };

	while (!s.empty()) {
		cout << "(" << s << ")" << endl;
		s.pop_back();
	}
}
/////////////////////////////////////////////////////////////////////
s string'i boþ olana kadar, sonundan bir karakter silinir. Döngünün her turunda sondan
bir karakter silinir, s en son boþ olduðunda döngüden çýkýlýr.

empty() fonksiyonu boþaltan deðil, boþ mu sorgulamasý yapan fonksiyon(makeempty deðil isempty
anlamýnda). makeempty anlamýndaki fonksiyon ise clear() fonksiyonu. Containerin içindeki
öðelerin tamamýný silen fonksiyon her zaman clear(). clear fonksiyonu da stl'in ortak
interface'i, string'e özel deðil. clear etme destroy etme ile tamamen farklý yalnýzca öðeleri 
silinir.
Bir istisna dýþýnda containerdaki öðeyi silme fonksiyonu remove deðil erase.

Diðer bir constructor, const char * parametreli constructor.
string s{"necati ergin"}; ifadesinde s, const char * parametreli constructor ile hayata gelir.
Not: Container'ýn bellek yönetimi ile programcýnýn bir alakasý yok, bellek alaný geri planda
container tarafýndan ayarlanmakta.

/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "Necati Ergin" };//const char * parametreli ctor
		
	string s1{ "A" }; //içinde tek bir karakteri tutacak þekilde string

	string s2( 1, 'A' );//fill constructor
}
/////////////////////////////////////////////////////////////////////

char parametreli constructor yok. Yani içinde sadece tek bir harf olan bir string nesnesi
oluþturmanýn yolu string s{ 'A' }; deðil, bu sentaks hatasý çünkü parametresi char olan
bir constructor yok. Ýçinde yalnýzca tek bir karakteri tutan bir string nesnesi hayata 
getirmek için const char * parametreli constructor kullanýlabilir. Buna ek olarak fill
parametreli, fill constructor da kullanýlabilir.


/////////////////////////////////////////////////////////////////////
int main()
{
	string s1( 35, 'A' ); //fill ctor.
		
	cout << "(" << s1 << ")" << endl;

	string s2{ 35, 'A' }; //initializer_list ctor

	cout << "(" << s2 << ")" << endl;


}
/////////////////////////////////////////////////////////////////////
Bu durumun dýþýnda constructorda küme parantezi kullanmak ile normal
parantez kullanmak arasýnda fark yok. s1 yazdýrýldýðýnda 35 tane 'A', 
s2 yazdýrýldýðýnda ise #A görülür. String sýnýfýnýn initializer_list 
constructor'ý olduðu için, 2 parametreli constructor çaðýrýlýrken {35, 'A'}
þeklinde çaðýrýlýrsa burada öncelik initializer_list constructorda.
#A çýkmasýnýn sebebi, 35, #'in karakter kod numarasý.
Sýnýflarýn initializer_list parametreli ctor'ý yoksa problem deðil ancak
varsa küme parantezi ile nesne oluþturulduðunda initializer_list ctor'ýn
önceliði var.
Bu durumlarda fill constructor'da normal parantez kullanýlýr.


String sýnýfýnýn move ve copy constructorlarý da tabi ki var.
Range ve substring constructorlarý da var.
/////////////////////////////////////////////////////////////////////
int main()
{
	list<char> mylist{ 65, 66, 67, 68, 69, 70 }; //normal char list
	string s1{ mylist.begin(), mylist.end() };

	cout << "(" << s1 << ")" << endl;

	char str[] = "murathan";	
	string s2{ str + 3, str + 7 };

	cout << "(" << s2 << ")" << endl;

	string sentence{ "bugun hava cok guzel" };
	string s3{ sentence, 6, 4 };
	
	cout << "(" << s3 << ")" << endl;
}
/////////////////////////////////////////////////////////////////////
Baþka bir container'ýn begin ve end range'i arasýndaki char deðerler
kullanýlarak string nesnesi oluþturulabilir.
Yine baþka bir yazýnýn belirli aralýðýndaki yazý kullanýlarak string nesnesi
oluþturulabilir.
string s3{ sentence, 6, 4 }; ifadesinde ise, s3 string nesnesi sentence stringinin
6 indisinden baþlayarak 4 karakterinden oluþacak þekilde construct edilir.

Assign fonksiyonlarýnda olduðu gibi, buffer parametreli constructor da mevcut.
Bir string nesnesi, baþka bir yazýnýn baþlangýç adresinden n karakter kadarý ile
de construct edilebilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "necati ergin", 5 };

	cout << "(" << s1 << ")" << endl;
}
/////////////////////////////////////////////////////////////////////

Sýnýfýn move constructor'ý olduðu için, bir fonksiyonun string döndürmesi artýk
problem deðil.
/////////////////////////////////////////////////////////////////////
string hdiv(const string &s, const string &style)
{
	return "<div class =\"" + style + "\">\n" + s + "\n</div>\n";
}
int main()
{
	cout << hdiv("icindekiler", "neco") << endl;

}
/////////////////////////////////////////////////////////////////////
verilen öðe fonksiyon yolu ile HTML'deki div etiketi içine alýr. 
Koda bakýldýðýnda eskiden olsa böyle fonksiyon yazýlmazdý çünkü burasý bir string ve
bu string kopyalanacaktý ama þimdi, oluþturulan geçici nesnenin kaynaðýný bunu alan
taraf çalacak, taþýma semantiði devreye girecek. Parametreye argüman geçilirken ayný
þey geçerli deðil bu yüzden okuma parametreleri her zaman const string & yapýlmalý.
Gönderilen parametrelerde, gönderilen deðerlerin kaynaklarýný çalacak bir mekanizma yok. 

C++11 ile gelen, string literalleri ile ilgili önemli bir özellik mevcut.
Konu string literalleri olduðunda;
/////////////////////////////////////////////////////////////////////
int main()
{
	char *p = "bugun hava o kadar soguk ki \"
			"ben cok usudum";

	cout << p << endl;

	char *s = "bugun hava o kadar soguk ki \"
"ben cok usudum";

	cout << s << endl;
}
/////////////////////////////////////////////////////////////////////
alt satýrdan devam etmek için ya ayrý bir string literali oluþturulur, kendisi toplar
veya yazý ters bölü ile sonlandýrýlýp alt satýrdan devam edilir. Ancak ters bölü ile 
sonlandýrýldýðýnda, alt satýrdaki yazý için, editördeki boþluklarda yazýya dahil edilmiþ
olur. Bunu engellemek için, alt satýrdaki yazý editörde en sola yaslanýr. C'de de böyle
C++'da da böyle.

Ýkinci bir problem ise string içinde belirli karakterlerin doðrudan kullanýlamamasý.
Örnek olarak " karakteri, string içinde doðrudan kullanýlamaz. String literalinin içinde
" karakteri geçecekse \" yazýlýr. Benzer durum \ karakterinin kendisi için de geçerli.
C'de veya C++'da yazý içinde "\ahmet\" yazýsý yazdýrýlmak istense;
cout << "\"\\ahmet\\\"" << endl; þeklinde yazýlýr.

Raw string literal: Yine string literali sadece yazýma iliþkin bir notasyon.
Raw string literalinin özelliði ise, bu tür yazým zorluklarýna iliþkin kolaylýk saðlamasý.
Örnek olarak çift týrnaðýn kendisi doðrudan yazýlýr, ters bölü karakteri doðrudan yazýlýr.
/////////////////////////////////////////////////////////////////////
int main()
{
	cout << R"(\"murat\")" << endl;

	cout << R"(arkadasim dedi!
	Bir bak hele buraya...
	"Murat!" sen misin? dedi kadýn)" << endl;
}
/////////////////////////////////////////////////////////////////////
çift týrnak ve parantezler string literaline dahil deðil, delimeterlar.
Böyle alt satýrdan devam etmesi istenen, içinde " karakterleri gibi özel
karakterleri bulunduran yazý doðrudan raw string literalinin içine kopyalandý,
yazý hem içinde boþluksuz olarak doðrudan editördeki gibi saklandý hem de 
içindeki özel karakterler yazýya dahil olmuþ oldu.

string bir dinamik dizi sýnýfý, aslýnda yazý dinamik bir bellek alanýnda tutuluyor.
Bu alandan sýnýf nesnesi sorumlu, client olarak bu bellek alanýna gerekmedikçe
müdahale edilmez.  
Dinamik dizinin sondan ekleme maliyeti sabit. Container geri planda tutulan öðelerin
yerleþtirildiði bellek alanýnýn haricinde ekleme iþlemlerinin sondan sabit maliyetle
yapýlmasý için ilave bir bellek alaný daha tutar. Arka planda allocate edilmiþ bellek
alanýna kapasite denir. Örnek olarak container'da 20 tane öðe tutuluyor ancak 10 öðelik
daha yer var, bu durumda kapasite 30. Reallocation olmadan 10 tane daha insert iþlemi
yapýlabilir. Kapasite dolduðu zaman, yani kapasite size'a eþit olduktan sonra artýk
eklemeye yer yok. Ýlk ekleme iþleme reallocationa neden olur, bu durumda containerdaki
öðelerin tamamý, daha büyük olan yeni alana kopyalama yolu ile taþýnýr. Container bellek
alanýný geri verir ve yeni bellek alaný elde eder, öðeleri de kopyalar. Dolayýsý ile 
sondan ekleme, bir pointerýn gösterdiði yere yazmak tabi kapasite dolana kadar(kapasite
dolduktan sonra reallocation). Reallocation zaman alan bir iþlem, ilave bir kopyalama maliyeti.
Reallocation durumunda, eski bellek alanýný gösteren pointer veya iteratorler de invalid
hale gelir(dangling pointer durumu). 

Sýnýfýn capacity isminde bir const fonksiyonu var, geri dönüþ deðeri size_type türünden.
capacity fonksiyonu bir get fonksiyonu. kapasite - size; reallocation olmadan insert
edilebilecek karakter sayýsýdýr.
/////////////////////////////////////////////////////////////////////
int main()
{	
	string s{ "tacettin muratoglu" };

	cout << s.capacity() << endl; //kapasite: 31
	cout << s.size() << endl; // size: 18
}
/////////////////////////////////////////////////////////////////////
13 karakter daha eklenebilir ancak 14.karakter eklenmesi durumunda reallocation.


Reallocationdan programcý sorumlu deðil, bu sýnýfýn kendi sorumlululðunda.
/////////////////////////////////////////////////////////////////////
int main()
{
	
	string s{ "tacettin muratoglu" };

	cout << s.capacity() << endl;
	cout << s.size() << endl;

	s += "toprakkaya holding";

	cout << s.capacity() << endl;
	cout << s.size() << endl;
}
/////////////////////////////////////////////////////////////////////
Yazýnýn sonuna 13'den daha fazla karakter olduðunda reallocation durumu oluþur,
yeni yazýnýn size'ý 37, kapasite ise 47.


/////////////////////////////////////////////////////////////////////
int main()
{
	string s;

	auto cap = s.capacity();

	for (;;)
	{
		s.push_back('A');
		if (s.capacity() > cap) {
			cout << "kapasite " << cap << " degerinden " << s.capacity() << " degerine yukseldi\n";
			cap = s.capacity();
			getchar();
		}
	}
}
/////////////////////////////////////////////////////////////////////
String büyüdükçe, kapasitenin yetmediði zaman kapasitenin artýþýnýn da arttýðý görülür.
Bunun bir negatif tarafý ise, o alan kullanýlsa da kullanýlmasa da string nesnesi hayatta
olduðu sürece o kapasite string nesnesine ait, o bellek alaný farklý þekilde kullanýlamaz.


Ýhtiyaç olduðunda kapasite büyüyor ancak ihtiyaç ortadan kalktýðýnda kapasite azalmýyor.
Kapasite otomatik olarak büzülmez.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s(987777, 'A');

	cout << "size = " << s.size() << endl; // 987777
	cout << "cap = " << s.capacity() << endl; // 987791

	s.erase(5); // 5 indexi ve sonrasý her þey silinir

	cout << "size = " << s.size() << endl; // 5
	cout << "cap = " << s.capacity() << endl; // 987791

	s.shrink_to_fit();

	cout << "size = " << s.size() << endl; // 5
	cout << "cap = " << s.capacity() << endl; // 15
}
/////////////////////////////////////////////////////////////////////
String içindeki yazý küçülse dahi, kapasitesi otomatik olarak küçülmez.(kapasite shrink edilmez)
C++11 öncesinde string sýnýfýnýn interfaceinde buna yönelik bir fonksiyon yoktu, kapasiteyi
büzmeye yönelik kodlarý programcý kendisi yazýyordu ancak C++11 ile birlikte gelen
shrink_to_fit isimli bir fonksiyon var. Bu fonksiyon çaðrýldýðýnda kapasite mevcut size'a
göre daraltýlýr. Bu fonksiyon ile kapasite doðrudan küçültülebilir. Örnekte s için
shrink_to_fit() fonksiyonu çaðrýldýktan sonra, kapasite 15'e düþtü.

Yazýlacak programda, oluþturulan string nesnesinin nihai olarak 1, 2 milyon karakter
sayýsýna ulaþýlacaðý biliniyorsa bu durumda bir önceki örnekteki gibi bir implementasyon
yapýlýrsa, yazýnýn büyüklüðü 1, 2 milyona çýkana kadar 25'e yakýn reallocation yapýlmýþ
olur. Bu sebeple bu tür sýnýflarýn interfaceinde ismi reserve() olan bir fonksiyon mevcut,
bu fonksiyon kapasiteyi reserve eder, size ile bir ilgisi yok. String nesnesinin ihtiyaç
duyduðu kapasite baþtan ayarlanýr, örnek olarak stringin kapasitesi 1 milyon olarak reserve
edildiðinde string'in size'ý baþta 0 olsa ve yavaþ yavaþ 1 milyona yaklaþsa bile, 1 milyona
kadar reallocation olmayacaðý garanti altýnda. Reserve, istenen deðere kapasiteyi set eder.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s;

	auto cap = s.capacity();
	s.reserve(6000000);

	for (;;)
	{
		s.push_back('A');
		if (s.capacity() > cap) {

			cout << "kapasite " << cap << " degerinden " << s.capacity() << " degerine yukseldi\n";
			cap = s.capacity();
			getchar();
		}
	}
}
/////////////////////////////////////////////////////////////////////
Yine karakter karakter ekleme yapýldý ama 6000000'a gelene kadar, reallocation yapýlmadý.
Reserve kullanmaktan çekinilmemeli. Eðer ki baþtan belli ise, oraya yavaþ yavaþ yükseleceði
reallocation maliyetinden kaçýnmak için o kadar bir kapasite doðrudan ayarlanabilir.
reserve() fonksiyonuna daha küçük bir deðer geçilirse bu non-binding shrink request(baðlayýcý
olmayan büzülme talebi). Bu durumda derleyici asla kapasiteyi küçültmez. Kendi kapasitesinden
daha küçük bir deðer için reserve() çaðrýldýðýnda kapasite geri verilmiþ olunmaz.

Kapasitenin olmasý, o bellek alanýnýn orada bir yazýnýn karakteri varmýþcasýna kullanýlabileceði
anlamýna gelmez. size'a dahil olmayan bir yerde yazýnýn karakteri varmýþ gibi oraya ulaþmak
çalýþma zamaný hatasý.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s;

	s.reserve(200000);

	s[1000] = 'A'; //run time error
}
/////////////////////////////////////////////////////////////////////  

size ne zaman ve nasýl büyür ?
ekleme iþlemleri ile: .insert(), .append(), .assign(), =, +=, .push_back()
resize, size'ý büyüten veya küçülten bir fonksiyon, hem büyütme hem de küçültme fonksiyonu.


size ne zaman ve nasýl küçülür ?
resize, size'ý büyüten veya küçülten bir fonksiyon, hem büyütme hem de küçültme fonksiyonu.
.erase(), .assign(), =, .clear(), .pop_back()

resize() aslýnda daha çok containerlara yönelik bir interface.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "murat" };
	string s2{ "murat" };

	s1.resize(20); // 20 - 5 tane null karakter ekler
	
	s2.resize(20, 't'); // 20 - 5 tane 't' karakteri ekler

	cout << s2 << endl;

	for(size_t k = 0; k < s.size(); ++k)
		cout << static_cast<int>(s[k]) << " "; //null karakterleri görmek için

}
///////////////////////////////////////////////////////////////////// 
resize() fonksiyonuna yapýlan çaðrý sonucu, sýnýf nesnesine resize() fonksiyonuna
geçilen parametre - sýnýfýn var olan size'ý kadar ekleme yapýlýr.   
resize() fonksiyonunun 2 tane overloadý var, ilki tek parametreli yazýya null karakter
ile ekleme yapar. Ýkincisi ise yazýnýn sonuna belirtilen karakter ile ekleme yapar.

atama operatörünü overload etmek yerine assign fonksiyonunun da olmasýnýn sebebi,
atama operatör fonksiyonu binary operator. Mesela bir string nesnesine 5 tane 'a'
karakterinden oluþan yazýyý atamak gibi bir iþlem atama operatör fonksiyonu ile yapýlamaz
çünkü atama operatör fonksiyonu binary, assign fonksiyonu ile 5 ve 'a' fonksiyona parametre
olarak geçilebilir. Atama operatör fonksiyonu ile en fazla baþka bir ifade atanabilir.

String sýnýfýnýn npos'u:
npos, string sýnýfýnýn const static public member'i. npos identifier'i string sýnýfýnýn
bir veri elemaný. salt okuma amaçlý kullanýlýr. string::npos'unun türü string'in size_type'ý,
o da zaten size_t türü olduðundan string'in npos'u aslýnda unsigned int türden bir const static
veri elemaný, bir tamsayý deðeri.

cout << string::npos << endl; 4294967295, 4-byte iþaretsiz tamsayý sýnýr deðeri

Bir stringin olabilecek en büyük uzunluðu npos. Bir string en fazla 4294967295 uzunluðunda
olabilir, dolayýsýyla hiçbir string nesnesinde bu deðer geçerli bir indeks olamaz. 
Ýki tane temel kullaným alaný var, arama fonksiyonlarýnda çok sýk kullanýlýr. 
C++'da(C ile beraber) üç tane arama interface'i var: 
1)arama fonksiyonu adres alýr, adres verir aradýðýný bulamadýðýnda null pointer döndürür. 
2)iterator interfacei: arama yapan algoritmalarýn hepsi iterator interface'ine göre arama 
yaparlar, fonksiyon bir range'i alýr(begin ve end), aranýlan öðenin konumu bulunur(iterator),
fonksiyonun geri dönüþ deðeri iterator, aranan deðer bulunmazsa n iteratorunu döndürülür.
3)string sýnýfýnýn kendi arama fonksiyonlarýnýn geri dönüþ deðeri ise hep index. Aranan
deðer bulunduðunda, bulunan yerin indexi döndrülür, aranan deðer bulunamazsa npos deðeri
döndürülür(nasýlsa npos'un geçerli bir index olma ihtimali yok). npos'un birinci kullaným
yeri arama fonksiyonlarýnýn baþarýsýzlýk durumunda geri dönüþ deðeri olmasý.

arama fonksiyonlarýnýn hepsinde ortak bir arayüz mevcut, birinci parametre her zaman
aranan deðer. Diðer parametrelerden biri aramanýn nereden itibaren yapýlacaðý ile ilgili,
bu parametreye bir deðer geçilmezse stringin tamamýnda arama yapýlýr.
find() fonksiyonunun ikinci parametresi, aranýlacak offset, yani o indexten baþlayarak.
s.find('a') demek ile s.find('a', 0) demek arasýnda bir fark yok.
find() fonksiyonunun geri dönüþ deðeri, index yani size_type türünden, bulunamazsa npos
döndürülür.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s;

	cout << "bir yazi giriniz: ";
	getline(cin, s); //global fonksiyon, boþluklar dahil yazýyý alýr
	//cin >> s; //ilk white space karakterini delimeter olarak kullanýr, scanf gibi

	auto idx = s.find('a');

	if (idx != string::npos) {
		cout << "aranan karakter bulundu, idx = " << idx << endl;
		s[idx] = 'X';
	}
	else
		cout << "aranan karakter bulunamadi" << endl;

	cout << s << endl;
}
/////////////////////////////////////////////////////////////////////

npos'un ikinci kullaným alaný ise þöyle:
string kütüphanesinin interfaceinde þu þekilde bir parametre çifti var;
string, size_type idx, size_type n
mesela erase'in böyle bir overloadu var, verilen idexten baþlayarak n kadar siler.
Bu interface'in ilginç bir özelliði var, mesela idx parametresine bir deðer geçildi 
ancak diðer parametreye geçilen deðer geriye kalan karakter sayýsýndan daha fazla. 
erase fonksiyonuna mesela 5 ve 2000 geçildi ancak 5. indexten sonra o ancak 20 tane
karakter var, bu ne sentaks hatasý ne de run time hatasý ne de undefined behaviour,
dilin kurallarýna göre bu güvenceli þekilde geriye kalan hepsi anlamýna gelir.
Bu durumda, bu tür iþlemler belirli bir indexten sonraki tüm karakterler için yapýlmak
istenirse ikinci parametre olarak npos deðeri geçilir böylece geçilen parametrenin 
geriye kalacak karakter sayýsýndan büyük olduðu garanti altýna alýnmýþ olur.

06_01_2018 CUMARTESÝ

vektör, string sýnýflarýnýn köþeli parantez operatör fonksiyonlarý const overloading'e tabii ve 
doðrudan öðeye eriþen bir fonksiyon. Bir stringin bir karakterine iki þekilde eriþilebilir, biri
köþeli parantez operatör fonksiyonu. Hem set hem de get amaçlý kullanýlýr.(string nesnesi const
deðilse ancak set amaçlý kullanýlabilir) Köþeli parantez operatör fonksiyonu geçersiz index durumunda
exception throw etmez.


Köþeli parantez operatörüne eþ bir at isimli bir string sýnýfý fonksiyonu mevcut. Aralarýndaki tek fark 
var, geçersiz index olmasý durumunda at fonksiyonu exception throw eder.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "Eskisehir" };

	for (size_t i = 0; i < s.size(); ++i)
		cout << s[i] << endl;
		//cout << s.at(i) << endl;

	s[6] = 'T';
	//s.at(6) = 'T';

	cout << s << endl;
	
	s[352] = 'A' //Run Time Error
	//s.at(352) = 'A'; //out_of_range hata nesnesi gönderir

}
/////////////////////////////////////////////////////////////////////


back ve front fonksiyonlarý vektor, list sýnýflarýnda olan fonksiyonlar. 
back fonksiyonu, referans yolu ile string nesnesinin son öðesine eriþtirir.
front fonksiyonu ise, string nesnesinin ilk öðesine referans verir.
Const overloading mekanizmasý, back ve front fonksiyonlarý için de geçerli, string nesnesi
const olduðunda bu iki fonksiyonu kullanarak, string nesnesini deðiþtirmeye yönelik kodlar geçersiz.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "neco" };

	s.back() = 'a';

	cout << "(" << s << ")" << endl;

	s.front() = 't';

	cout << "(" << s << ")" << endl;

}
/////////////////////////////////////////////////////////////////////


Eðer köþeli parantez operatörü veya front olmasaydý yazýnýn belirli bir karakterine ve öðelerine
iterator yolu ile eriþilirdi. Bütün containerlarda olduðu gibi sýnýfýn begin fonksiyonu ilk öðeye
iterator verir, begin'in geri dönüþ deðeri her zaman ilk öðenin konumunu tutan bir iterator.
Containerlarda eðer bir nedenden dolayý iterator konumu geçersiz ise o iterator dereference edidiðinde
bir exception throw edilmez. iterator denilen nesneler ya gerçek pointer veya smart pointer sýnýfýndan.
Ýterator nesnesi, içerik operatorunun operandý yapýldýðýnda o konumdaki nesneye eriþilir, bu bütün
containerlar için geçerli. Bu durumda bir string nesnesinin tuttuðu yazýnýn ilk karakterine eriþmek
için 3 farklý yol var; köþeli parantez operatörü, front fonksiyonu ve begin fonksiyonunun dereference
edilmesi ile elde edilen nesne ancak yazý boþ ise bunlarýn tümü run time hatasý.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "muhittin" };

	string::iterator iter = s.begin();
	//auto iter = s.begin();

	*iter = 'X'; //yazýnýn ilk karakteri

	cout << "(" << s << ")" << endl;
}
/////////////////////////////////////////////////////////////////////


Hangi container olursa olsun, begin fonksiyonu ile end fonksiyonunun geri dönüþ deðerleri bir range olarak
kullanýlýrsa bu, containerda tutulan öðelerin range'i. Bir string nesnesinin tuttuðu yazýnýn karakterleri
bu iki fonksiyon ile de dolaþýlabilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "muhittin" };

	for (auto iter = s.begin(); iter != s.end(); ++iter)
		*iter = toupper(*iter);

	cout << s << endl;
}
/////////////////////////////////////////////////////////////////////



 Yazýnýn son karakterine ise, back fonksiyonu ile, köþeli parantez operatörüne yazýnýn uzunluðu - 1 indis 
 yapýlarak eriþilebilir. end fonksiyonunun geri dönüþ deðerini kullanarak da, yazýnýn son karakterine
 eriþilebilir ancak end fonksiyonu yazýnýn son karakterinin konumunu deðil son öðenin bir sonrasýnýn konumunu
 verir, bu durumda bu iteratorun ifade ettiði konumdan bir önceki konuma eriþilerek son karakterin konumuna
 eriþilebilir. -- kullanmak yerine, bir iterator fonksiyonu olan prev fonksiyonu da çaðýrýlabilirdi.
 prev fonksiyonu, kendisine gönderilen konumdan bir önceki konumu geri döndürür.
 prev fonksiyonu olduðu gibi next fonksiyonu da var, next fonksiyonu da kendisine gönderilen konumdan bir sonraki
 konumu döndürür.
 /////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "muhittin" };

	cout << s.back() << endl;
	cout << s[s.length() - 1] << endl;
	cout << *--s.end() << endl;
	cout << *prev(s.end()) << endl; 
	cout << *next(s.begin()) << endl;

}
/////////////////////////////////////////////////////////////////////


C++11 ile birlikte global begin ve end fonksiyonlarý da eklendi. string nesnesi global end ve begin fonksiyonlarýna
da parametre olarak geçilebilirdi.
iteratorler söz konusu olduðunda, const anahtar sözcüðü ile deðil farklý iterator türleri ile elde edilirler.
Her container sýnýfýnýn bir iterator nested type'ý bir de const iterator nested type'i var, her ikisi de konum
tutar. Iterator sýnýfý türünden nesne set ve get iþlemleri için kullanýlýr ancak const Interator sýnýfý türünden
nesne sadece okuma amaçlý kullanýlabilir, yazma amaçlý kullaným sentaks hatasý.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "muzaffer" };

	string::const_iterator citer = str.begin();

	cout << *citer << endl;

	*citer = 'A'; //sentaks hatasý

}
/////////////////////////////////////////////////////////////////////



Eðer bir range okuma amaçlý dolaþýlacaksa const iterator kullanýlmalý, yazma amaçlý dolaþýlacaksa iterator 
kullanýlmalý. const iteratoru elde etmenin birinci yolu türünün programcý tarafýndan yazýlmasý.(C++11'e kadar
böyleydi).C++11 itibariyle tüm container sýnýflara begin ve end çiftinin yanýnda bir de cbegin ve cend fonksiyonlarý
da eklendi. begin fonksiyonu normal iterator, cbegin fonksiyonu ise const iterator verir.
/////////////////////////////////////////////////////////////////////
int main()
{
	vector<string> svec{"aykut", "arman", "huseyin", "kardelen", "sinan", "omer"};

	for (auto iter = svec.begin(); iter != svec.end(); ++iter)
		iter->back()++; //hepsinin son karakteri birer artmýþ oldu

		
	for (auto citer = svec.cbegin(); citer != svec.cend(); ++citer)
		cout << *citer << endl; //citer ancak okuma amaçlý kullanýlabilir

}
/////////////////////////////////////////////////////////////////////


Container sýnýflarýn üye cbegin ve cend fonksiyonlarý olduðu gibi global cbegin ve cend fonksiyonlarý da dile
eklendi, bu fonksiyonlar dizilerde kullanýlabilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	int a[] = {4, 7, 2, 8, 9, 1, 3, 6};

	for (auto iter = begin(a); iter != end(a); ++iter)
			++*iter; 

	for (auto iter = cbegin(a); iter != cend(a); ++iter)
		cout << *iter << endl; //sadece okuma amaçlý kullanýlabilir

}
/////////////////////////////////////////////////////////////////////



Containerlarýn, reverse_iterator isimli bir içsel türü daha var, bu içsel türün de const olan ve const 
olmayaný var. Containerlarýn iterator türleri; iterator, const_iterator, reverse_iterator, const_reverse_
iterator. reverse_iterator arttýrýldýðý zaman tam tersi eksilen bir iterator. Özellikle sondan baþa 
dolaþma için kullanýlýr.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "nurettin" };

	string::const_reverse_iterator iter = s.crbegin();

	for (; iter != s.rend(); ++iter)
		cout << *iter << endl;

}
/////////////////////////////////////////////////////////////////////
rbegin() fonksiyonu reverse_iterator döndürür. rbegin()'in verdiði deðer son öðenin konumu.
iter ++ operatörünün operandý yapýldýðýnda tam tersi eksilir.
C++11 ile, sýnýflara global crbegin ve crend fonksiyonlarý da eklendi.
Her container için; begin, end, cbegin, cend, rbegin, rend, crbegin, crend fonksiyonlarý var. 
crbegin ve crend fonksiyonlarý const_reverse_iterator döndürür. Sondan baþa dolaþýlacaksa rbegin, rend ve
crend fonksiyonlarý ile reverse_iterator veya const_reverse_iterator kullanýlýr

string, vector, deque, array sýnýflarýnýn iteratorleri, random access denilen kategoriden. Pointerlar ile ilgili
tüm interface'in tamamýna sahipler. Bir iteratore tamsayý toplanýrsa yine iterator elde edilir yani pointerlar ile
yapýlabilen tüm iþlemler bu sýnýflar ile de yapýlýr.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "nurettin" };

	*(s.begin() + 2) = 'S';
	
	cout << s << endl;

	cout << end(s) - begin(s) << endl; //iki iteratorun farký bir tamsayý

}
/////////////////////////////////////////////////////////////////////
 

Range based for loop'un varlýk nedeni programcýnýn iþini kolaylaþtýrmak. Range based for loop oluþturulduðunda 
derleyici karþýlýðýnda iterator kodu üretir, iterator kodu yazma kýsmý derleyiciye yüklenmiþ olur.
Containerdaki öðenin türünden deðiþken : containerin kendisi
Döngünün gövdesinde bu isim kullanýldýðýnda containerda tutulan öðeye eriþilmiþ olur.

/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "taylan akduman" };

	for (char c : s)
		cout << c << " ";

	cout << endl;

	for (char c : s)
		++c;

	cout << s << endl;

	for (char &c : s)
		++c;

	cout << s << endl;

}
/////////////////////////////////////////////////////////////////////
Burada referans semantiði yok, ikinci döngüdeki ++c ifadesi ile deðiþtirilen, derleyicinin ürettiði kodda
yer alan otomatik ömürlü yerel deðiþken. Bu otomatik ömürlü yerel deðiþken, yazýnýn karakterinin kendisi deðil,
derleyici ürettiði kodda *iter'i c'ye atar, dolayýsýyla c yazýnýn karakterinin kendisi deðil.
Karakteri deðiþtirmek üzere bir iþlem yapýlacaksa referans semantiði kullanýlmalý. Üçüncü döngüdeki c deðiþkeni
artýk yazýnýn karakteri olan char nesnenin kendisi.

Modern C++ ile range based for loop'larda auto keywordu kullanýlarak yazým kolaylýðý elde edilir.
Referans semantiði ile auto beraber kullanýlýrsa doðrudan referans semantiði kabul edilir, döngüdeki her turda
containerdaki öðelerin biri. Ancak referans olmazsa yine kopyalama.
/////////////////////////////////////////////////////////////////////
int main()
{
	vector <string> svec{ "aykut", "arman", "huseyin", "kardelen", "sinan", "omer" };

	for (auto s : svec)
		s += "can";

	for (size_t k = 0; k < svec.size(); ++k)
		cout << svec[k] << endl;

	cout << endl;

	for (auto &s : svec)
		s += "can";

	for (size_t k = 0; k < svec.size(); ++k)
		cout << svec[k] << endl;
}
/////////////////////////////////////////////////////////////////////
Birinci döngü için referans semantiði kullanýlmadýðýndan yine kopyalama yapýlmýþ olur, yazýlar deðiþmez.
Bir de const & semantiði var, burda da yine nesnenin kendisi ancak salt okuma amaçlý kullanýlabilir.


/////////////////////////////////////////////////////////////////////
int main()
{
	vector <string> svec{ "aykut", "arman", "huseyin", "kardelen", "sinan", "omer" };

	auto iter = find(svec.begin(), svec.end(), "sinan");

	if (iter == svec.end())
		cout << "arama basarisiz\n";
	else {
		iter->append("can");
		cout << *iter << endl;
	}
		

}
/////////////////////////////////////////////////////////////////////
stl tamamen range mantýðý ile çalýþýr. find fonksiyonuna, svec'in full range'i aralýk olarak
geçildi, son parametre ise aranan deðer. Fonksiyonun geri dönüþ deðeri yine iterator, geri dönüþ
deðeri yine bir iterator nesnesine atanabilir. Arama fonksiyonlarý stl'de baþarýsýz olma durumunda
gönderilen end konumunu döndürür. 


Normalde sýnýfýn üye fonksiyonlarý ile doðrudan yapýlamayan, yapýlsa da fazla kod yazýlmasý gereken durumlarda 
stl algoritmasý ile çok kýsa yapýlabilir. String sýnýfýnýn sort veya reverse diye üye fonksiyonlarý yok ancak
bu isimlerde algoritmalar var, string de bir container olduðundan bu algoritmalar string sýnýfýnda kullanýlabilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "necati-ekrem-ihsan-tahir-suzan" };

	reverse(str.begin(), str.end());

	cout << "(" << str << ")" << endl;

	sort(str.begin(), str.end());

	cout << "(" << str << ")" << endl;
}
/////////////////////////////////////////////////////////////////////

Arama fonksiyonlarýnýn ismi find ile baþlar. Arama fonksiyonlarý ile stringde karakter, baþka bir yazý, bir 
cstring veya bir buffer aranabilir. Arama fonksiyonlarýnýn overloadlarýnýn deðiþen parametrelinden biri ne 
arandýðý. Ýkinci önemli parametre, string nesnesinin tuttuðu yazýnýn neresinden itibaren yapýlacaðý, bunun 
için bir index deðeri geçilir.
find() fonksiyonu sýnýfýn üye fonksiyonu, global fonksiyonlar deðil. Aranýlan öðe her zaman daha önceki parametre,
parametre olarak ilk ne aranýyorsa o geçilir. Ýkinci parametre eðer size_type türünden bir parametre ise indexdir, o
indexten baþlayarak arama yapýlýr ve bu parameter varsayýlan argüman almýþtýr, ikinci parametreye deðer geçilmezse
0 indexi geçilmiþ olur ve stringin tamamýnda arama yapýlýr.
find() fonksiyonunun 4 tane overloadý var, string, c-string, buffer ve character arayan. tüm overloadlar const.
(buffer: bir adres ve o adrese eþlik eden kaç tane karakter olduðu bilgisi)
find() fonksiyonlarýnýn hepsinin geri dönüþ deðeri türü size_type ve hepsi index döndürü, baþarýsýz arama durumunda
npos döndürülür.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "polat alemdar" };

	auto idx = s.find('a');
	auto idx = s.find('a', 4); //arama 4.indexten baþlayarak yapýlýr


	if (idx == string::npos)
		cout << "aranan karakter bulunamadi" << endl;
	else
		cout << "bulundu, idx = " << idx << endl;

}
/////////////////////////////////////////////////////////////////////

rfind() fonksiyonu ise aramayý sondan yapar. C'deki strchr'nin karþýlýðý gibi. strrchr'den farký ise;
rfind() fonksiyonunun da ayný overloadlarý var.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "Vali geldi ali buraya" };

	//auto idx = s.rfind('a'); //karakter aranýr
	auto idx = s.find("ali"); // idx = 1
	auto idx1 = s.rfind("ali"); // idx1 = 11

	if (idx == string::npos)
		cout << "bulunamadi" << endl;
	else
		cout << "bulundu idx = " << idx << endl;

}
/////////////////////////////////////////////////////////////////////

find_first_of() fonksiyonu, eldeki karakter gurubuna ait olan karakterlerin ilkinin yazý içinde geçtiði
yer bulunur, C'deki strpbrk fonksiyonunun karþýlýðý. Birinci parametresi aranan(yine string, c-string,
buffer ve karakter), ikinci parametre index.
find_first_not_of() fonksiyonu ise, tam tersi bu karakterlerden biri olmayan ilkini bulur.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "Mustafa Yalcin" };

	auto idx = s.find_first_of("burak");
	auto idx1 = s.find_first_not_of("burak"); //idx1 = 0

	auto idx2 = s.find_last_of("burak"); // idx2 = 9
	auto idx3 = s.find_last_not_of("burak"); // idx2 = 13, son karakter



	if (idx == string::npos)
		cout << "bulunamadi" << endl;
	else
		cout << "bulundu idx = " << idx << endl;

}
/////////////////////////////////////////////////////////////////////
*this nesnesinde(s nesnesi içinde), "burak" yazýsý içindeki karakterlerden herhangi biri aranýr.
"Mustafa Yalcin" yazýsýnda 'M' bu karakterlerden biri deðil, 'u' karakteri bu karakterlerden biri olduðundan
idx = 1 olur. 
find_first_not_of() fonksiyonu için ise, yazýnýn ilk karakteri olan 'M' karakteri "burak" yazýsý içindeki
karakterlerden olmayan ilk karakter olduðundan idx1 = 0 olur.
index parametresi bütün arama fonksiyonlarýnda geçerli, ikinci parametre olarak bir index deðeri verilirse,
arama yazýnýn bu indexinden baþlayarak yapýlýr.
find_last_of() ve find_not_last_of() da bunlarýn tam tersi, find_last_of bu karakterlerden biri olan en son
karakteri bulur, arama sondan baþa yapýlýyormuþ gibi. 


sub string iþlevi: bir yazýnýn içinden baþka bir alt yazýyý çekmek. Fonksiyonun iki parametresi var, ikisi de
default parametre alýr. Birinci parametre index, nereden baþlanacaðý, ikinci parametre ise kaç karakter olduðu.
Fonksiyonun geri dönüþ deðeri string.
Ýkinci parametreye bir deðer geçilmezse, varsayýlan argüman olarak stringin nposu'nu alýr, geriye kalan 
karakter sayýsýndan daha fazla olduðu için geriye kalan karakterlerin hepsi alýnmýþ olur.
Birinci parametresine aldýðý varsayýlan argüman ise 0 deðeri.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "eskisehir" };
	cout <<	str.substr(4, 5) << endl; //4.indexden baþlayarak 5 karakter, "sehir"
	cout <<	str.substr(4, 5) << endl; //"ise"

	cout << str.substr(2) << endl; //"kisehir" yazýsý elde edilir
	cout << str.substr() << endl; //yazýnýn bir kopyasý elde edilmiþ olur

}
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "<div><p>mustafa</p></div>" };

	auto idx1 = str.find("<p>");
	
	if (idx1 == string::npos) {
		cout << "paragraf yok" << endl;
		return 0;
	}

	auto idx2 = str.find("</p>", idx1 + 3);

	if (idx2 == string::npos) {
		cout << "kapanmamis tag hatasi" << endl;
		return 0;
	}

	cout << str.substr(idx1 + 3, idx2 - idx1 - 3) << endl;
	cout << string(s.begin() + idx1 + 3, s.begin() + idx2) << endl; //string sýnýfýnýn range alan constructor'ý

}
///////////////////////////////////////////////////////////////////// 	 
html paragraf tagi içindeki "mustafa" yazýsý, str yazýsý içinden çekiliyor.



silme iþleminde, substr gibi hangi indexten baþlayarak kaç tane silineceði bilgisi fonksiyona geçilir.
erase() fonksiyonuna ikinci parametre geçilmezse, ayný substr'de olduðu gibi o indexten baþlayarak geriye kalan
hepsini siler. 
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "bugun hava cok guzel" };

	str.erase(6, 5);

	cout << str << endl;

	str.erase(5);

	cout << str << endl;

	str.erase(1, 1); // tek bir karakter silmek için, 'u' karakteri silinir

	cout << str << endl;
}
/////////////////////////////////////////////////////////////////////

Burada çaðrýlan fonksiyonlar string sýnýfýnýn kendi interface'ine iliþkin fonksiyonlar, bir de bütün containerlarýn
ortak silme interface'i var. Bu interfacede fonksiyon bir iterator alýr, o iterator konumundaki öðeyi siler, tüm
containerlarýn iteratör ile silme yapan bir fonksiyonu var. Range parametreli erase fonksiyonu da var, parametre 
olarak iki tane iterator alýr.
erase fonksiyonunun diðer bir overload'ý ise, iki parametreye de argüman geçilmediðinde yazýnýn tamamýný siler.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "necati" };

	str.erase(str.begin() + 1); //iterator olarak konum verildi
	//str.erase(1, 1); // böyle de yapýlýr
	
	cout << str << endl;

	//kalan yazýnýn ilk karakteri ve son karakteri hariç karakterleri silmek için
	str.erase(str.begin() + 1, str.end() - 1);
	//str.erase(next(str.begin()), prev(str.end())); //böyle de yapýlabilir

	cout << str << endl;

	str.erase(); //yazýyý clear etmiþ olur
	cout << str << endl;
}
/////////////////////////////////////////////////////////////////////



insert fonksiyonlarý: push_back() fonksiyonu ile sona ekleme yapýlýr, append() fonksiyonu ile de sona ekleme yapýlýr
ancak insert() fonksiyonu ile istenilen herhangi bir yere ekleme yapýlabilir. 
Bir stringin size'ýný büyütmenin yollarý: += operatörü ile, push_back() ile, atama ile, resize() ile ve insert() ile.
 /////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "ali" };

	cout << "uzunluk = " << str.size() << endl;

	str = "mustafa"; // atama yaparak yazýnýn uzunluðu deðiþtirilebilir
	cout << "uzunluk = " << str.size() << endl;

	str.resize(10, 'a');
	cout << "uzunluk = " << str.size() << endl;

	str += "can";
	cout << "uzunluk = " << str.size() << endl;

	str.append(5, 'x'); // yazýnýn sonuna 5 tane 'x' karakteri ekler
	cout << "uzunluk = " << str.size() << endl;

	str.push_back('Q'); //push_back ile yalnýzca karakter eklenir
	cout << "uzunluk = " << str.size() << endl;

}
/////////////////////////////////////////////////////////////////////

insert()'in farký ise istenilen herhangi bir konuma ekleme yapýlabilmesi. silmede olduðu gibi insert()
fonksiyonunda da iki ayrý interface var, biri index diðeri iterator interface'i.
index fonksiyonlarýnýn hepsinin ortak özelliði, ekleme hangi indexten yapýlacak ve ne eklenecek bilgisinin 
parametre olarak geçileceði. insert() fonksiyonun da overloadlarý var. Belirlenen konuma, string, substring,
c-string veya buffer insert edilebilir. index interface'i ile çalýþan overloadlarýn geri dönüþ deðerlerinin
türü yine *this, nesnesnin kendisini geri döndürürler.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "can" };
	string str{ "ali" };

	str.insert(0, s1); // "canali"
	cout << "(" << str << ")" << endl;

	str = "nurali";

	str.insert(3, s1);
	cout << "(" << str << ")" << endl; // "nurcanali"

	str.insert(3, 2, 'W');
	cout << "(" << str << ")" << endl; // 3.indexten baþlayarak 2 tane 'W' karakteri ekler

}
/////////////////////////////////////////////////////////////////////

insert() fonksiyonunun ayný zamanda iterator interface'ine sahip overloadlarý da var.
Bu fonksiyonlarda, bir iterator konumu parametre olarak geçilir ve insert iþlemi bu iterator konumuna yapýlýr.
iterator parametreli overloadlarý: fill(belirli bir konumdan baþlayarak, belirli sayýda karakter insert etme),
single character(belirli iterator konumuna, bir karakter), range(bir iterator konumuna bir range'i), initializer
list(belirli iterator konumuna, verilen initizalizer list).
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "can" };
	string str{ "xyztq" };

	str.insert(str.begin(), 'A'); //begin konumuna 'A' karakteri insert edildi
	cout << "(" << str << ")" << endl;

	str.insert(str.begin(), s1.begin(), s1.end() - 1); //begin konumuna, s1 için geçilen range insert edildi
	cout << "(" << str << ")" << endl;

	str.insert(str.end(), 5, 't'); //str'nin sonuna 5 tane 't' karakteri insert edildi
	cout << "(" << str << ")" << endl;

}
/////////////////////////////////////////////////////////////////////

stl'deki iterator interface'i ile çalýþan insert ve erase fonksiyonlarýnýn geri dönüþ deðerlerinin türü iterator.
insert için, insert edilen öðenin konumuna; silme iþlemi için ise silinenden sonraki ilk öðenin konumuna iterator.


/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "istanbul antalya yozgat" };

	string s1, s2;
	cout << "hangi yazinin: ";
	cin >> s1;
	cout << "hangi yazi gelecek: ";
	cin >> s2;

	auto idx = str.find(s1);

	if(idx != string::npos){
		str.erase(idx, s1.length());
		str.insert(idx, s2);
	}

	cout << str << endl;
}
/////////////////////////////////////////////////////////////////////
program ile, s1 yazýsýnýn str içinde geçtiði ilk yerde, str yazýsý içindeki s1 silinir, oraya s2
yazýsý eklenir. Eðer s1 için "antalya", s2 için "sakarya" girilirse str "istanbul sakarya yozgat" olmuþ olur.
erase ve insert fonksiyonlarýnýn yerine, replace fonksiyonu kullanýlarak tek bir deyimle yer deðiþtirme iþlemi
yapýlabilir: 
str.replace(idx, s1.length(), s2);

Bu örnekteki iþleri, bu þekilde yapmak yerine string sýnýfýnýn replace fonksiyonlarý var. 
Bütün replace fonksiyonlarýnýn geri dönüþ deðeri *this.
Replace fonksiyonunun overloadlarýndan biri, ilk iki parametreye const iterator türünden bir range alýr,
bu range'e üçüncü parametreye geçilen string nesnesini koyar.
/////////////////////////////////////////////////////////////////////
int main()
{
	string str{ "istanbul" };

	str.replace(str.begin() + 1, str.begin() + 5, "urfa"); 

	cout << str << endl; //yazý "iurfabul" haline gelir
}
/////////////////////////////////////////////////////////////////////

substring overloadý ise, bir pozisyondan(indexten) baþlayarak, girilen sayýdaki karakterin yerine, fonksiyona
geçilen stringin substringini koyar.
c-string overloadý ise substring yerine c-string koyar. c-string ve buffer overloadlarýnýn hem index hem de 
iterator parametreli olan overloadlarý var.
fill parametreli olan overloadýn da yine hem index hem de iterator karþýlýðý var.

range parametreli olan overload ise, bir range'i baþka bir range ile deðiþtirir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "istanbul" };
	string s2{ "ankara" };

	s1.replace(next(s1.begin()), prev(s1.end()), s2.begin(), s2.begin() + 4);

	cout << "(" << s1 << ")" << endl; //"iantal"

}
/////////////////////////////////////////////////////////////////////

append fonksiyonu ise bir stringin sonuna ekleme yapar, append fonksiyonu ile stringin sonuna baþka bir string,
substring, c-string, buffer, istenilen sayýda istenilen karakter, bir range ve initializer list eklenebilir.
Sona tek bir karakter eklemek için iki parametre geçilmeli; s.append(1, 't'); þeklinde.

Atama operatörü varken assign fonksiyonunun kullanýlmasýnýn sebebi daha kompleks atamalar yapýlabilmesi.
Assign fonksiyonlarýnýn geri dönüþ deðerleri *this. Bir stringe baþka bir string atanabilir(bu atama operatör
fonksiyonu ile de yapýlabilir), bir substring, c-string, buffer, fill, range, initializer list atanabilir.


07_01_2018 PAZAR

String sýnýfý türünden nesneler takas edilirken;
temp = s1;
s1 = s2;
s2 = temp; gibi bir ifade yazýldýðýnda sýnýfýn kopyalayan atama fonksiyonu çalýþýr. Bu fonksiyon da deep copy yapar,
tüm kaynaklar kopyalanmýþ olur bu da oldukça maliyetli. Doðru olan string sýnýfýnýn içinde dinamik bellek alanýnýn 
adresini tutan pointeri ve uzunluk bilgisini tutan deðiþkeni takas etmek. Global swap veya string sýnýfýnýn swap
fonksiyonu çaðýrýldýðýnda fonksiyonun kodu da bu þekilde implemente edilmiþ. Bu sadece string sýnýfý nesneleri
için deðil, tüm containerlar için böyle. Container nesneleri, primitif nesneler takas ediliyormuþ gibi takas edilmez.
Sýnýflarýn kendi swap fonksiyonlarý sýnýfýn veri elemanýna eriþebildikleri için swap iþlemini deep copy olarak deðil
pointerlarý takas ederek yapar. Tüm container sýnýflar için sýfýnýn bir swap fonksiyonu var. Global swap fonksiyonu
kullanmanýn da bir dezavantajý yok çünkü template hileleri ile derleyici global swap fonksiyonu hangi nesne için
çaðýrýlýyorsa ona yönelik kod üretir.


Kullanýlan kütühane C++'ýn string sýnýfýný kullanýyor ancak bu kütüphane ile birlikte iþ birliði içinde ayný zamanda
bir C kütüphanesi de kullanýlýyor, C kütüphanesi yazý için c-string ister. Bu durumda bu ikisi ortak kullanýldýðý
zaman stringler bir c fonksiyonuna gönderilir, c fonksiyonundaki yazýyý(c-stringi) string kütüphanesi ile iliþkilen-
dirmek kolay çünkü string sýnýfýnýn hem const char * parametreli ctoru var, hem de temel string operasyonlarýný
yapan string sýnýfý fonksiyonlarýnýn hepsinin de c-string overloadý var. Ancak problem c-string isteyen bir yerde,
elde c-string deðil string olmasý, böylesi durumlarda elde olan string, c-string olarak kullanýlmalý. Bunu yapmak
için sýnýfýn c_str isimli bir fonksiyonu var,  c_str fonksiyonu const char * geri döndürür, aslýnda yaptýðý dinamik
bellek alanýnda tutulan string yazýsýnýn tutulduðu adresi vermek. cstr'den alýnan adresin sonunda null karakter olan,
böylece C fonksiyonlarýna argüman olarak geçilebilecek bir yazý olduðu garanti altýnda. c_str fonksiyonundan alýnan
adres set amaçlý kullanýlmamalý, parametrese char * olan bir fonksiyona da bu adres geçilmemeli. 

Bir string nesnesi için c_str fonksiyonu çaðrýldýðýnda ve fonksiyonun geri dönüþ deðeri olan adres const char * türden
bir pointerda tutulsa ardýndan, bu pointer elimizdeyken string nesnesi manipüle edilse, deðiþtirilse bu durumda yazý
deðiþmiþ olur bu durumda arka planda string nesnesinin kullandýðý dinamik bellek alanýnýn adresi de deðiþmiþ olabilir,
bu adresin deðiþmeyeceði ile ilgili bir garanti yok. Bu durumda göstericide tutulan adres, hala o yazýnýn baþlangýç
adresiymiþ gibi kullanýldýðýnda ne olacaðý belli deðil, run time hatasý. Eðer arkada reallocation olursa bu durumda
eldeki pointerýn gösterdiði adres ile manipüle edilmiþ string nesnesinin adresinin ayný olacaðý ile ilgili dilin bir
kuralý yok. Ancak string salt okuma amaçlý kullanýlýyorsa bu durumda adres deðiþmez, ekleme, silme gibi operasyonlar
sonucu bu adres deðiþmiþ olabilir.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s{ "mustafa aksoy" };
	
	const char *p = s.c_str();

	puts(p);

	s += "uzun suredir goruesemedik";

	puts(p); //p adresi artýk bu yazýnýn baþlangýç adresi olmayabilir

}
/////////////////////////////////////////////////////////////////////


Yazýlarýn karþýlaþtýrýlmasý söz konusu olduðunda iki ayrý kategoride fonksiyonlar mevcut, C bu kategorilerden 
birini hiç bulundurmaz. Ýlk kategoride fonksiyonlar operatör gibi çalýþýr, fonksiyon a büyük mü ? b'den
sorusunun cevabýný verir, bu durumda her bir operatör için bir fonksiyon olur, operator overloading olmayan
dillerde, bunlarýn karþýlýðý olarak isimlendirilmiþ fonksiyonlar verilir.(isgreater, islessthan..)
Fakat C++'da zaten operator overloading olduðundan operatör karþýlýðý olan fonksiyonlar zaten operatör fonksiyonu,
iki string karþýlaþtýrma operatörü ile karþýlaþtýrýlabiliyor, bu fonksiyonlarýn overloadlarý ile birlikte stringler
c-string'ler ile de karþýlaþtýrýlabiliyor. Primitif türler nasýl karþýlaþtýrma operatörlerinin operandý oluyorsa,
string nesneleri de ayný þekilde karþýlaþtýrma operatörlerinin operandý yapýlýr.
Ýkinci kategori ise C'de olduðu gibi strcmp tarzý fonksiyonlar. Sadece stringlere yönelik deðil birçok karþýlaþtýrma
iþlemi için geçerli. Çaðrýlan fonksiyon bir sorunun cevabýný deðil, karþýlaþtýrmanýn sonucunu verir. 
C++'ýn string kütüphanesi her ikisini birden verir, operatörlerin yanýnda ismi compare olan fonksiyonlar strcmp'de
olduðu gibi karþýlaþtýrmanýn sonucunu verir. Operatör fonksiyonlarý global fonksiyonlar(simetrik, binary operatörler,
global operatör fonksiyonu olarak overload edilir) ancak compare fonksiyonu sýnýfýn üye fonksiyonu. Karþýlaþtýrma
iþlemine compare fonksiyonu ile konu olan nesnelerden biri *this. Bir string nesnesi compare fonksiyonu ile;
bir baþka string ile, bir  substring ile, bir c-string ve bir buffer ile karþýlaþtýrýlabilir. Tümünün geri dönüþ 
deðeri int ve strcmp gibi yorumlanýr.
/////////////////////////////////////////////////////////////////////
int main()
{
	string s1{ "bu yil kis gelmedi" };
	string s2{ "burasi mecidiyekoy" };
	/////

	if (!s1.compare(s1.size() - 5, 5, s2, s2.size() - 5, 5))
		cout << "iki yazi esit\n";
	else
		cout << "yazilar esit degil\n";
		
	//iki yazinin sonundaki 5 karakterlik substring karþýlaþtýrýlýyor

}
/////////////////////////////////////////////////////////////////////


Remove Erase Idiyomu: Remove bir algoritmanýn ismi, erase ise string sýnýfýnýn veya bir container sýnýfýn üye
fonksiyonunun ismi. Algoritmalar her zaman iteratör ile çalýþýrlar. Iterator, konum tutan bir nesne, iterator
gerçekte de bir pointer olabilir, vektör sýnýfýnýn implementasyonunun büyük bir kýsmýnda vektörün iteratörü
bir pointer ancak dilin buna yönelik bir garantisi yok. Bir iteratoru kullanarak iteratörün gösterdiði nesne 
kullanýlabiliri bunun okuma veya okuma-yazma olarak kullanýlabilmesi iteratörün türüne baðlý, örnek olarak iterator
string'in iteratoru türünden ise string nesnesini deðiþtirebilir ancak iterator vector'un const_iterator'u türünden
ise nesneyi deðiþtiremez, nesne iterator yoluyla salt okuma amaçlý kullanýlýr.
Ýteratorün türünün ne olduðuna baðlý olarak, ++ ve -- operatörlerini kullanarak o veri yapýsýndaki o öðeden daha
sonraki veya daha önceki öðelere eriþilebilir. String sýnýfýnýn iteratoru, random access iteratoru denilen bir 
kategoride ve bu kategori pointerlarýn saðladýðý interface'in tamamýný saðlar, örneðin bu iterator, random access
iterator ise iter += 2; denildiðinde iter'in yeni deðeri mecut konumundan 2 sonraki öðenin konumudur. Azaltma her
iteratorun interface'inde olan bir iþlem deðil.
Bir iterator dereference edildiðinde containerdaki öðeye eriþilir, containerdaki öðe bir string ise, stringe bir
baþka string atanabilir dolayýsýyla iteratörlerin türleri birbirleri ile ayný olmasa bile bir algoritma farklý
iki container üstünde de iþlem yaptýrabilir. Mesela içinde string tutulan bir vektör nesnesi ve yine içinde string
tutulan bir baðlý liste var, vektördeki öðelerin baðlý listeye kopyalanmasý istendiðinde bu bir algoritma ile 
yapýlabilir. iterator yolu ile öðelere eriþilebiliyor, iki iterator dereference edilebiliyor zaten bu durumda ikisi
de string olmuþ olur, stringler de birbirine atanabildiðine göre *iter1 = *iter2 olabilir, iter'lerin türleri farklý
olmasýna raðmen birbirlerine atanabilir çünkü ikiside string nesnesinin yerine geçmiþ oluyor. 
Ýteratorler ile yapýlma ihtimali olmayan bir durum ise iteratorun gösterdiði nesnenin containerdan silinmesi, çünkü
containera yapýlan ekleme ve silme iþlemlerini kontrol eden container nesnesinin kendisi. Ýterator containera 
eriþtirmez, containerda tutulan öðeye eriþtirir. Elde iterator varsa bu containera ulaþmak demek deðil. Iterator
parametreli bir fonksiyon, ilgili range'e ekleme yapamaz veya ilgili range'den bir silme yapamaz. Stl algoritmalarý
hiçbir zaman bir containera ekleme veya bir containerdan silme iþlemi yapamaz, çünkü ekleme ve silme iþlemlerinin
yapýlabilmesi için container nesnesinin üye fonksiyonunun çaðýrýlmasý gerekir.  
Stl de bir sürü silme algoritmasý var, en tipiði remove, remove algoritmasý bir range'i(begin, end) ve silinecek
deðeri alýr ve o range içinde o deðeri siler. Stl'deki silme algoritmalarý silme yapamýyor ancak lojik silme iþlemi
yapýyor. Elimizde tamsayý tutan bir container olsun, tamsayýlarýn deðeri de sýrasýyla: 3, 7, 9, 3, 4, 1, 3, 6
Stl'in en çok silme algoritmasý olan remove fonksiyonu kullanýlarak bu range'deki 3'ler silinmek isteniyor:
remove(vec.begin(), vec.end(), 3); remove global bir fonksiyon olduðundan böyle çaðýrýlýr.
Bu çaðrýdan sonra bu containerin size'ýnýn küçülme ihtimali yok, burada lojik silme yapýlýr. 3'ler silinmiþ olsaydý
container 7, 9, 4, 1, 6, _, _, _ haline gelirdi. 3'lerden boþalan yerlerdeki deðerlerin ne olacaðý ile ilgili bir 
garanti verilmez. Geri dönüþ deðeri ile _'larýn baþladýðý yere bir iterator verir. Böylece fiziksel bir silme iþlemi
yapmadan(containerýn erase fonksiyonunu çaðýrmadan) silinmiþ muamelesi yapýlýrsa size küçülmemiþ olmasýna raðmen
containerýn içinde öðe olan kýsmý kullanýlýr. Ýkinci olarak gerçekten de containerýn size'ý küçültmek isteniliyorsa
bu durumda artýk containerin içinde öðe olmayan yerlerinin silinmesi için her containerda olan range parametreli 
erase fonksiyonu çaðýrýlýr. Bu durumda artýk içinde öðe olmayan bölüm range'e geçilir. Bu range'in baþlangýç konumu 
ise remove algoritmasýndan gelir, remove algoritmasý zaten geri dönüþ deðeri ile containerin artýk içinde öðe 
bulunmayan yerlerinin baþladýðý yerin konumunu vermiþti. Range'in end'i olarak geçilmesi gereken ise yine containerin
kendi end'i. Ýþte bu iþleme remove erase idiyomu denir, en sýk ihtiyaç duyulan problemlerden biri olan containerdaki
belirli öðelerin tümünü silme iþlemi için remove algoritmasý çaðýrýlýr buna range ve silinecek deðer geçilir, remove 
algoritmasý geri dönüþ deðeri olarak logic end deðerini verir. Containerin gerçek begin'i ve logic end silme iþlemi 
yapýldýktan sonra geriye kalan containerin range'i olmuþ olur. Logic end ile containerin gerçek end'i ise silinmesi
istenen bölge.

/////////////////////////////////////////////////////////////////////
template <typename Iter>
void display(Iter beg, Iter end)
{
	while (beg != end) {
		cout << *beg;
		++beg;
	}
	
	cout << "\n**************************\n";
}
int main()
{
	string str{ "ankarali kahraman asker adanaya vardi" };

	char c;

	cout << "silinecek karakteri giriniz: ";
	cin >> c;

	cout << "remove oncesi size: " << str.length() << endl;

	auto logic_end_iter = remove(str.begin(), str.end(), c);
	
	display(str.begin(), logic_end_iter); 
	display(logic_end_iter, str.end());

	cout << "remove sonrasi size: " << str.length() << endl;

	str.erase(logic_end_iter, str.end());

	cout << "erase sonrasi size: " << str.length() << endl;

}
/////////////////////////////////////////////////////////////////////	
 
remove iþleminden sonra, containerýn boyutu deðiþmez. string nesnesi içinden remove fonksiyonuna geçilen
karakter silinir ancak containerin size'ý küçülmez. Ne zaman ki erase fonksiyonu, range olarak remove'un geri 
dönüþ deðeri olan konumu ve containerin end'ini alýr, o zaman bu logic end'den containerin sonuna kadar olan
bölüm containerden silinir ve ancak o zaman container'in size'ý küçülmüþ olur. Aslýnda remove fonksiyonu ile 
gerçek bir silme iþlemi yapýlmýþ olmaz, öðeler takas edilmiþ olur.
Logic end ile gerçek end arasý yazdýrýlsa burada silinecek karakterlerin bulunacaðý söylenemez, bu algoritmanýn
nasýl implemente edildiði ile alakalý. 

COMPOSITION

Composition sýnýflar arasýnda en çok kullanýlan iliþki biçimlerinden.
Association'da farklý sýnýflar bir iþi yapmak için birlikte çalýþýyorlar, iki farklý sýnýfýn instance'larý bir iþi
birlikte yapar. Ýþin yapýlabilmesi için bu iki farklý sýnýfa ihtiyaç var. Association'ýn özel bir biçimi mevcut,
buna aggregation denir, aggregation'ýn farký ise o da bir association ama burada öðelerden biri diðerinin
sahibi durumunda, sahip olan bir nesne var diðerini kullanarak bu iþ yapýlýyor yani x nesnesi y nesnesinin sahibi
durumunda, x gerektði zaman mülkiyeti altýnda olan y nesnesini kullanarak o iþi yapýyor.
Her aggregation bir association ancak her association bir aggregation olmak zorunda deðil.
Composition her þeyden önce bir association ve ayný zamanda da bir aggregation. Ancak composition'ý, aggregation'dan
farklý kýlan, composition'ýn olmazsa olmazý ömürsel birliktelik. Yine bir nesne baþka bir nesnenin sahibi olacak, 
onu kullanarak iþ yapýlacak ancak sahip olan nesne ile sahip olunan nesne arasýnda ömürsel bir birliktelik olacak.
Sahip olan nesne hayata geldiðinde, sahip olunan nesne de hayata gelmiþ olacak, birinin hayatý bittiðinde ise
diðerinin de hayatý bitecek. 
Araba-motor iliþkisi, aggregation ve composition arasýndaki farký görmek için kullanýlabilir. Her arabanýn bir 
motoru var ve arabanýn birtakým faaliyetlerini sürdürebilmesi için motorunun olmasý gerekir yani her arabanýn
motoru var be araba faaliyetlirini bu motoru kullanarak gerçekleþtirir ortada bir aggregation var.
Eðer araba ile motor birbiri ile ömürsel bir birliktelik içindeyse yani bir arabanýn motoru alýnýp baþka bir 
arabaya takýlamýyor ise bu durumda composition var çünkü araba ile motor arasýnda ömürsel birliktelik mevcut.
Ama mesela örnek olarak bir arabanýn motoru bozulduðunda, arabaya baþka bir motor takýlabiliyor ise bu durumda 
kesinlikle composition olmaz çünkü araba ile motor arasýnda ömürsel bir birliktelik yok.
Her composition bir aggregation ancak her aggregation bir composition olmak zorunda deðil.

Composition için ingilizcede sýnýflar arasýndaki bu sahiplik iliþkisine "has a ?" iliþkisi nedir.
Kalýtým iliþkisine ise "is a ?" iliþkisi denir.
Car has an engine, biri sahip diðeri sahip olunan nesne.
Sýnýflar arasý en çok kullanýlan iki iliþki composition ve kalýtým.
C++'da compositionýn birden fazla yöntemi var en sýk kullanýlan yol bir sýnýfýn baþka bir sýnýf türünden
öðeye sahip olmasý. Computer bir class, Mainboard da bir class, Computer sýnýfýnýn Mainboard sýnýfý
türünden bir non-statik veri elemaný var. Yine Car ve Engine bir class, Car sýnýfýnýn Engine sýnýfý 
türünden bir öðesi var. Þu þekilde de olabilir, her Car nesnesi hayata geldiðinde onun constructor'ý
dinamik bir Engine nesnesi hayata getirse, Car sýnýfýnýn destructor'ý da constructor tarafýndan hayata
getirilen dinamik Engine nesnesini destroy etse yine ömürsel bir birliktelik saðlanmýþ olur. Composition
denildiðinde sadece bir sýnýfýn baþka bir sýnýf türünden veri öðesine sahip olmasý düþünülmemeli.

String sýnýfý composition iliþkisinin en çok kullanýldýðý sýnýflardan. Birçok sýnýfýn öz niteliklerinden
bir veya birden fazlasý yazý biçiminde ifade edilecek öz niteliklerden, örnek olarak Employee sýnýfýnda,
isim, soyisim, adres kullanýlmasý. Bu gibi sýnýflara tipik olarak string sýnýfý türünden öðe veya
öðeler konur. Bir sýnýfýn baþka sýnýf türünden öðe veya öðelere sahip olmasý çok tipik. 
Örnek olarak bir projede Student sýnýfýný oluþturduk, öðrencinin doðum tarihi, kayýt tarihi gibi bilgiler
Date sýnýfý türünden öðelerde tutulabilir.

C++ dilinin sentaks kurallarý burada dikkat edilmezse problemlere yol açabilir. Ýlk düþünülmesi gerekenler
access control ve scope. Bir nesne baþka bir nesnenin sahibiyse o nesne hayata geldiðinde diðer nesne de
hayata gelir, C++'da bir nesne hayata gelmiþse, nesne için mutlaka constructor çaðýrýlmýþtýr peki nasýl
çaðýrýlýr, kim çaðýracak ve ne þekilde çaðýrýlacak ? 

/////////////////////////////////////////////////////////////////////
/// engine.h ///
class Engine {
public:
	void start();
	void stop();
	void run();
};

/// car.h ///
//#include "engine.h"
class Car {
	Engine eng;
public:
};
/////////////////////////////////////////////////////////////////////
Bu kodun legal olabilmesi için non-statik data member olan türün yani Engine türünün complete olmasý
gerekir. Derleyicinin Engine sýnýfýnýn tanýmýný görmesi gerekir. Eðer pimple idiyomu kullanýlmayacaksa
bu tür durumlarda her zaman memberlarýn baþlýk dosyasýný, owner(sahip olan sýnýf) include edecek
çünkü incomplete olarak bir forward declaration ile bunu yapmanýn imkaný yok.


Statik veri elemaný ile karýþtýrýlmamalý, statik veri elemanýndan bir tane var global deðiþken gibi ve 
bir sýnýfýn statik veri elemanýna sahip olabilmesi için sýnýfýn incomplete olmasý yeterli, forward
declaration ile yapýlabilir.
/////////////////////////////////////////////////////////////////////
class Engine;

/// car.h ///
class Car {
	static Engine eng;
public:
};
/////////////////////////////////////////////////////////////////////
Kod legal, eðer ki Engine sýnýfý türünden eng nesnesi statik olmasaydý sentaks hatasý olurdu çünkü o 
durumda incomplete type'a izin verilmez ancak incomplete tpye tatik veri elemaný olabilir.


Madem her Car nesnesinin bir Engine'i var, fiziksel olarak da bir Car nesnesi içinde gerçekten bir
Engine sýnýfý türünden nesne var. Böyle nesnelere member object denir. Bu tabi sizeof'a da yansýr.
Car nesnesinin sizeof deðeri, içinde Engine sýnýfý türünden nesne varken ve yokken incelendiðinde,
Car nesnesinin içinde fiziksel olarak da Engine sýnýfý türünden nesnenin var olduðu görülür.


Bir sýnýfýn baþka bir sýnýf türünden elemana sahip olmasý, eleman olan sýnýfýn private veya protected
bölümüne eriþim hakký vermez. 
/////////////////////////////////////////////////////////////////////
/// engine.h ///
class Engine {
	int x, y;
	int getCode()const;
public:
	void start();
	void stop();
	void run();
};

/// car.h ///
//#include "engine.h"
class Car {
	Engine eng;
public:
	void func()
	{
		eng.start();  //geçerli
		eng.getCode(); //geçersiz
	}
};
/////////////////////////////////////////////////////////////////////
Car sýnýfý içinde, Engine sýnýfýnýn private bölümüne ait bir fonksiyonun çaðýrýlmasý geçeriz.
Derleyici diðer sentaks engellerini aþsa bile, sýnýfýn private bölümüne eriþimin geçersiz olmasýna dair
hata mesajý verir. Sahip olunan sýnýfýn private ve protected bölümü sahip olan sýnýfa kapalý.
Tabi friendlik bildirimi ile eðer gerekiyorsa bu koruma engeli kaldýrýlabilir. 


Bir Car nesnesi hayata geldiðinde, onun içindeki Engine nesnesi de hayata gelir. Ýlk önce hayata gelen
tabi ki Engine nesnesi. Bir nesnesnin önce öðeleri hayata gelir, öðeleri hayata geldikten sonra
sýnýfýn constructor'ýnýn ana bloðuna yazýlmýþ olan kod çalýþýr ve bu kod çalýþtýktan sonra o nesne
hayata gelmiþ olur. Run-time'da programýn akýþý Car sýnýfýnýn constructor'ýna geldiðinde artýk sýnýfa
ait tüm öðeler hayata gelmiþtir. Öðelerin hayata gelmesi ile ilgili bir problem olsaydý o zaman programýn
akýþý zaten Car sýnýfýnýn ctor'una gelmezdi. Sýnýfýn öðeleri(sahip olunan), sýnýfýn constructor'ýna 
girilmeden hayata gelmiþtir. Özel bir önlem alýnmadýysa derleyici her zaman memberlarý default constructor
ile hayata getirecek þekilde kod üretir.
/////////////////////////////////////////////////////////////////////

class Engine {
	int x, y;
public:
	Engine()
	{
		std::cout << "Engine::Engine()" << endl;
	}
};
class Car {
	Engine eng;
public:
	Car()
	{
		std::cout << "Car::Car()" << endl;
	}
};
int main()
{
	Car mycar;
}
/////////////////////////////////////////////////////////////////////
Hiçbir müdahalede bulunulmuyor ise Engine sýnýfý türünden olan eng nesnesi default constructor ile 
hayata gelir. Burada önce Engine nesnesi hayata geldiðinden önce onun constructor'ýnýn içindeki
yazý çýkar ondan sonra Car sýnýfýnýn ctor'unun içindeki deyim çalýþýr.


Bir sýnýf, birden fazla sýnýf türünden nesneye de sahip olabilir. Bu örnekte bir Car nesnesi hayata
geldiðinde hem Engine hem de GearBox hayata gelecek. Hayata gelme sýralarý ise, bildirimdeki sýra.
Bu dil tarafýndan garanti altýna alýnan bir özellik.
/////////////////////////////////////////////////////////////////////
class GearBox {
public:
	GearBox()
	{
		std::cout << "GearBox::GearBox()" << endl;
	}
};
class Engine {
public:
	Engine()
	{
		std::cout << "Engine::Engine()" << endl;
	}
};
class Car {
	GearBox gbx;
	Engine eng;
public:
	Car()
	{
		std::cout << "Car::Car()" << endl;
	}
};
int main()
{
	Car mycar;
}
/////////////////////////////////////////////////////////////////////


Eðer programcý bu iþi kendi aþaðýdaki örnekte olduðu gibi yapsaydý, sýnýf nesnelerinin hayata
gelme sýralarý MIL sentaksýndaki sýraya göre deðil, sýnýfýn tanýmý içindeki sýraya göre.
/////////////////////////////////////////////////////////////////////
class Car {
	Engine eng;
	GearBox gbx;
public:
	Car() : gbx{}, eng{}
	{
		std::cout << "Car::Car()" << endl;
	}
};
/////////////////////////////////////////////////////////////////////


Birçok durumda, sahip olunan sýnýflar için tercih default constructor'ýn çaðrýlmasý olmaz veya 
zaten bu sýnýflarýn çaðýrýlabilir bir default constructor'ý olmaz. Bu durumda zaten programcý
koda müdahale etmek durumunda, aksi sentaks hatasý. 
/////////////////////////////////////////////////////////////////////
class Engine {
public:
	Engine(int) 
	{
		std::cout << "Engine::Engine(int)" << endl;
	}
};
class Car {
	Engine eng;
	GearBox gbx;
public:
	Car() //geçersiz
	{
		std::cout << "Car::Car()" << endl;
	}
};
/////////////////////////////////////////////////////////////////////
Burada olduðu gibi Engine nesnesinin yalnýzca int parametreli constructoru varsa ve Car sýnýfýnýn
kodu içinde herhangi bir deðiþiklik yapýlmadýðýnda henüz Car sýnýfý türünden bir nesne yaratýlmadan
zaten sentaks hatasý. Sentaks hatasýnýn sebebi Car sýnýfý türünden bir nesnenin oluþturulamýyor
olmasý deðil. Derleyicinin Car sýnýfý için bir görevi var, sýnýfýn tüm ctorlarýnda eðer Engine sýnýfýný
hayata getirecek bir kod göremezse kendisi bu kodu ekler. Kendisinin eklediði kod ise Engine sýnýfýnýn
default ctor'unun çaðrýlmasý yönünde ancak derleyici Engine sýnýfýnýn default ctor'unu görmediðinde bu
sentaks hatasýna yol açar. Derleyici bu fonksiyonun olmamasýna sentaks hatasý verir. Bu durumda artýk
MIL sentaksý ile Engine sýnýfýnýn constructor'ýný çaðýrmak programcýnýn görevi. Bu durumda Car sýnýfý
için constructor;

/////////////////////////////////////////////////////////////////////
Car() : eng{4} 
{
	std::cout << "Car::Car()" << endl; 
}

/////////////////////////////////////////////////////////////////////
þeklinde yazýlmalý.



Öðe olarak alýnan sýnýfýn constructor'ýna geçilecek deðeri Car sýnýfýnýn constructor'ý dýþarýdan
aldýðý parametre ile de yapabilir. Car sýnýfýnýn constructor'ýnýn da parametreleri vardýr, bu
parametrelerden bir veya daha fazlasýný argüman olarak öðelerini construct ederken kullanýr.
/////////////////////////////////////////////////////////////////////
Car(int x, int y) : eng{x} 
{
	std::cout << "Car::Car()" << endl; 
}

/////////////////////////////////////////////////////////////////////


Ýkinci tipik pattern ise, sahip olunan sýnýfýn bir default constructor'ý vardýr ancak bu sahip
olan sýnýfýn istediði fonksiyon deðildir. Sahip olunan sýnýfýn n tane constructor'ýndan özellikle
bir tanesinin çaðýrýlmasý da istenebilir. Yine bu durumda bu constructor'ý çaðýracak olan programcýnýn
yazmýþ olduðu koddur.
Trader sýnýfýna bir ctor yazýlmazsa veya Trader sýnýfýnýn ctor'u yazýlýp, m_name'i construct edecek
MIL sentaksýna bir ekleme yapýlmazsa derleyici m_name'i default construct eder. m_name default 
construct edildðinde uzunluðu sýfýr olan bir yazý olur. Eðer istenen Trader'ýn isminin, Trader'i 
yaratan koddan almasý ise:
/////////////////////////////////////////////////////////////////////
class Trader {
	std::string m_name;
public:
	Trader(size_t n) : m_name(n, 'x')
	{

	}
};
/////////////////////////////////////////////////////////////////////
Bu durumda Trader nesnesi yaratýldýðýnda, oluþturan kod constructor'a bir tamsayý argüman geçer, 
Trader da bu tamsayý argümaný öðesi olan string türünden m_name'i construct ederken constructor'ýn
istediði parametrelerden biri olarak kullanýr.


/////////////////////////////////////////////////////////////////////
class Student {
	Date bdate;
	std::string name;
public:
	Student(int no, int dept)
	{

	}
};
/////////////////////////////////////////////////////////////////////
Student sýnýfýnýn constructor'ýnda student nesneleri için no ve dept parametreli alýnýr.
Sýnýfýn ayný zamanda Date sýnýfý türünden bdate nesnesi de var. Date sýnýfýnýn default constructor'ý
herhangi bir parametre almadýðýnda, bugünün tarihini tarih olarak belirler. Bu durumda bir Student
nesnesi hayata geldiðinde, constructor'ýna parametre olarak geçilen no ve dept deðerlerini alýr.
bdate nesnesinin burada öðrencinin doðum tarihini temsil ediyor olsun, bu durumda derleyici bdate
için Date sýnýfýnýn default constructor'ýný çaðýrýr. Eðer bu istenen bir durum deðilse, bu durumda
Student sýnýfýnýn constructor'ý içinde bdate için de gereken deðerler alýnmalý, bundan Student sýnýfýný
yazan programcý sorumlu aksi halde derleyici otomatik olarak bdate için Date sýnýfýnýn default 
constructor'ýný çaðýrýr. Ýkinci olarak öðrencinin ismini tutacak bir string nesnesi de olsun, bu durumda
string nesnesi default construct edilirse name nesnesi boþ yazý ile hayata gelir, bu sentaks olarak bir
yanlýþ olmasa da lojik açýdan bir hata. Sýnýfý yazan programcý Student sýnýfýnýn constructor'ýnda bu
name nesnesine ilgili deðeri geçmeli.
 Ýlgili çaðrý þu þekilde yapýlabilir:
/////////////////////////////////////////////////////////////////////
	Student(int no, int dept, int y) : bdate{1, 1, y}, name{nm}
	{

	}
};
/////////////////////////////////////////////////////////////////////
Baþka sýnýf türünden veri öðeleri alýndýysa, bu derleyiciye býrakýlmamalý, default constructor edilmesi
isteniyor olsa dahi bu programý yazan tarafýndan o sýnýf nesnesinin default ctor'ý yazýlacak þekilde kod
yazýlmalý. Tabi ilgili sýnýf nesnesi için default ctor tanýmlanmamýþsa zaten sentaks hatasý.

Ne zaman bir owner nesnesi hayata gelir, onun için de bir member hayata gelir, birden fazla member 
varsa tüm memberlar hayata gelir. Bir nesnesnin varlýðý söz konusu ise her zaman constructor çaðýrýlýr.
Hayata gelmiþ her nesne için hayatý biterken destructor'ý çaðýrýlacak. Sýnýflarýn memberlarý varsa
nasýl construct oluyorlar ise sahip olan nesnenin hayatý bittiðinde bunlarýn da hayatý biter. Hayata
daha sonra gelen hayata daha erken veda eder.

Her Car sýnýfý türünden nesne hayata geldiðinde onun içindeki Engine nesnesinin de hayatý baþlar.
Car sýnýf nesnesi için destructor çaðýrýldýðýnda elemanlarýn destructor'ý çaðýrýlýr.
Constructor söz konusu olduðunda programýn akýþý constructor'ýn ana bloðuna girmesi için memberlarýn
hayata gelmiþ olmasý gerekir ancak destructor da durum böyle deðil.
Örneðin Car sýnýfýnýn destructorý yazýldýðýnda, eleman olan Engine'in destroy edilmesine yönelik kodu
derleyici Car sýnýfýnýn destructor'ý bloðu içine yerleþtirir. Derleyici Engine sýnýfý türünden member
nesnenin destructor'ýný sahibi olan Car sýnýfýnýn destructor'ý içinde çaðýrýr. Eðer Car sýnýfýnýn
destructor'ý içinde baþka kodlar varsa önce o kodlar çalýþýr ardýndan member nesne destroy edilir.
Bu durum pseudo code olarak þöyle ifade edilebilir.
~Car()
{
	//////
	eng.~Engine();
}

Member sýnýf türünden olan nesnenin destructor'ýnýn sahip olan sýnýfýn destructor'ý içindeki kodlardan
sonra çaðýrýlmasýnýn sebebi, orada çalýþan kodlar o sýnýf türünden member nesneyi kullanýyor olabilir.
Tabi bunu programcý yazmayacak, derleyici burada memberlarý destroy edecek kodlarý yazacak. Sýra yine
garanti altýnda, hayata önce gelen daha sonra destroy edilir.


/////////////////////////////////////////////////////////////////////
class Engine {
	int x, y, z;
public:
	Engine(int cyl)
	{
		std::cout << "Engine::Engine(int)" << endl;
	}
	~Engine()
	{
		std::cout << "Engine::~Engine()" << std::endl;
	}
};
class Car {
	Engine eng;
public:
	Car() : eng{5}
	{
		std::cout << "Car::Car()" << std::endl;
	}
	~Car()
	{
		std::cout << "Car::~Car()" << std::endl;
	}
};
int main()
{
	Car mycar;

	return 0;
}
/////////////////////////////////////////////////////////////////////
Önce Car nesnesi hayata gelirken onun Engine nesnesi hayata gelir ardýndan programýn akýþý Car
sýnýfýnýn ana bloðunun içine girer, ana bloðun kodu tamamlandýktan sonra artýk bir Car nesnesi hayata
gelmiþtir. Hayata veda etme durumunda ise, programýn akýþý Car sýnýfýnýn destructor'ýnýn kodunun ana
bloðu içine girdikten sonra ise, oradaki bütün kodlar çalýþýr ardýndan sýnýfýn memberlarý destroy
edilir.

Composition'da öðe olarak alýnan sýnýfýn interface'i, o öðeye sahip olan sýnýfýn interface'ine eklenmiyor.
Yani composition, interface'i devralma iliþkisi deðil. Car sýnýfýnýn, Engine sýnýfý türünden bir öðesinin
olmasý, Car sýnýfýnýn clientlarýnýn Engine sýnýfýnýn interface'ini doðrudan kullanabileceði anlamýna gelmez.
Engine sýnýfýnýn, start, stop adlý fonksiyonlarý var, Car sýnýfýnýn Engine sýnýfý türünden bir öðeye
sahip olmasý Car sýnýfýnýn da start, stop fonksiyonlarýnýn olduðu anlamýna gelmez. Ancak kalýtým söz 
konusu olduðunda durum böyle, kalýtým bir interface devralma iliþkisi, composition ise bir interface
devralma iliþkisi deðil. Eðer var olan bir sýnýfýn interface'i doðrudan devralýnmak isteniyorsa kalýtým
kullanýlmalý. Bir sýnýfýn interface'i daraltarak veya biçimlendirilerek client'lara verilmek isteniyorsa
bu durumda composition kullanýlmalý.


Stack sýnýfýnýn vektor sýnýfý türünden bir öðesi var. Stack sýnýfýnýn genel iþleyiþini saðlamak için
vektör sýnýfý türünden nesne kullanýlýr. Stack nesnesi hayata geldiðinde member öðesi olan mvec'de 
hayata gelir yine ayný þekilde, Stack nesnesinin hayatý sonlandýðýnda, mvec nesnesinin de hayatý 
sonlanýr. Ancak mvec sýnýfýnýn interface'i devralýnmýyor, yani eðer bu interface tamamen devralýnmýþ
olsaydý örnek olarak Stack sýnýfý türünden olan st nesnesi için st. ifadesi yazýldýðýnda eleman olan 
vektör sýnýfýnýn bir fonksiyonunu client tarafýndan çaðýrýlabilirdi. Client mesela burada vektör sýnýfýnýn
birtakým fonksiyonlarýný çaðýrarak Stack sýnýfýnýn tüm iþleyiþini bozabilirdi. Stack sýnýfýnýn kodunu 
yazarken, mvec. ifadesi yazýldýðýnda vektör sýnýfýnýn birçok fonksiyonu olduðu görülür ancak Stack sýnýfý
yazýlýrken vektör sýnýfýnýn belli bazý fonksiyonlarý kullanýldý. 
/////////////////////////////////////////////////////////////////////
/// istack.h ///
#pragma once

#include <vector>
#include <iostream>

class Stack {
	std::vector<int> mvec;
public:
	void push(int val)
	{
		mvec.push_back(val);
	}
	void pop()
	{
		if (mvec.empty()) {
			std::cout << "bos yigindan pop hatasi" << std::endl;
			exit(EXIT_FAILURE);
		}
		//mvec.erase(prev(mvec.end())); 
		mvec.pop_back();
	}
	int &top()
	{
		if (mvec.empty()) {
			std::cout << "bos yigindan top hatasi" << std::endl;
			exit(EXIT_FAILURE);
		}
		
		return mvec.back();
	}
	bool empty()const
	{
		return mvec.empty();
	}
	size_t size()
	{
		return mvec.size();
	}
	void clear()
	{
		mvec.clear();
	}
};
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
#include "istack.h"
#include "nutility.h"
int main()
{
	randomize();
	
	Stack st;

	for (int k = 0; k < 10; ++k){
		int val = rand();
		cout << val << endl;
		st.push(val);
	}

	cout << endl;
	cout << "size : " << st.size() << endl;

	while (!st.empty()) {
		cout << st.top() << " ";
		st.pop();
	}
	/////

	cout << endl;
	return 0;
}
/////////////////////////////////////////////////////////////////////


Stack sýnýfý, stack içinde int tutulacaðýna göre yazýldý ancak bu durum gerçekçi deðil, hemen her tür
için Stack sýnýfý gerekebilir. Sadece primitif türler deðil, user defined türler için de stack gerekebilir.
Eðer bu C'de yapýlmaya çalýþýlsaydý generic bir Stack oluþturmak için void pointerlar kullanýlýrdý.
Genel bir interface verilir, interface'de herþey void pointer olur.
C++'da ise böyle sýnýflarýn kodlarý derleyiciye yazdýrýlabilir, derleyici kodu compile time'da yazar.
Þablondan hareketle derleyici farklý sýnýflarýn kodunu yazabilir.
Stack sýnýfý þu þekilde bir sýnýf þablonu þeklinde yazýlabilirdi:
Burada stack içinde tutulan öðenin türü template tür haline getirilmeli.
/////////////////////////////////////////////////////////////////////
/// istack.h ///
#pragma once

#include <vector>
#include <iostream>

template<typename T>
class Stack {
	std::vector<T> mvec;
public:
	void push(const T &val)
	{
		mvec.push_back(val);
	}
	void pop()
	{
		if (mvec.empty()) {
			std::cout << "bos yigindan pop hatasi" << std::endl;
			exit(EXIT_FAILURE);
		}
		//mvec.erase(prev(mvec.end())); 
		mvec.pop_back();
	}
	T &top()
	{
		if (mvec.empty()) {
			std::cout << "bos yigindan top hatasi" << std::endl;
			exit(EXIT_FAILURE);
		}
		
		return mvec.back();
	}
	bool empty()const
	{
		return mvec.empty();
	}
	size_t size()
	{
		return mvec.size();
	}
	void clear()
	{
		mvec.clear();
	}
};
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
int main()
{
	Stack<string> st;

	st.push("Murat");
	st.push("Huseyin");
	st.push("Aykut");
	st.push("Kardelen");
	st.push("Sinan");
	st.push("Poyraz");

	cout << "size = " << st.size() << endl;

	while (!st.empty()) {
		cout << st.top() << " ";
		st.pop();
	}

	cout << endl;
	return 0;
}
/////////////////////////////////////////////////////////////////////
Tabi bu sadece bir örnek, STL'in zaten stack baþlýk dosyasýnda yazýlmýþ bir stack sýnýfý var.
stack<string> st; þeklinde STL'in stack sýnýfý türünden bir nesne oluþturulabilir.


13_01_2018_CUMARTESÝ

Bir sýnýfýn eleman olarak non-statik data memberi olarak baþka bir sýnýf türünden öðeye sahip olmasý
compositiona örnek.	Ancak kendi sýnýfýndan öðeye sahip olamaz, kendi sýnýfýndan statik öðeye sahip 
olabilir. Eðer non-statik öðeye sahip olacaksa complete type olmasý gerekir, A sýnýfýnýn B sýnýfý türünden
bir öðesi olacaksa A sýnýfýnýn tanýmýný derleyicinin legalize etmesi için o noktada B sýnýfýnýn da tanýmýný
görmesi gerekir. Pimple idiyomu kullanýlmamýþsa pratikte bir sýnýf baþka sýnýf türünden öðeye sahipse o 
sýnýfýn baþlýk dosyasý diðer sýnýfýn baþlýk dosyasýný include etmeli. Eðer öðe pointer veya referans olsaydý
o zaman incomplete type ile de bu yapýlabilirdi. Bir sýnýf nesnesi hayata geldiðinde o sýnýf nesnesi içindeki
diðer sýnýf türünden nesneler de hayata gelir onlarýn da constructor'ý çaðýrýlýr. Önce öðeler hayata gelir
ardýndan programýn akýþý ctor'ýn ana bloðuna girer. Bir sýnýfýn ctorunun ana bloðuna programýn akýþý gelmiþse
o sýnýfa ait tüm öðeler hayata gelmiþ demektir. Sýra her zaman bildirimdeki sýra, MIL sentaksý ile initialization
yapýlýrsa, MIL sentaksýndaki sýra ile memberlarýn bildirimdeki sýralarý birbirinden farklý ise asýl olan memberlarýn
bildirimdeki sýrasý. Bu sebeple genelde aksi bir durum yoksa bildirimdeki sýra ile MIL sentaksýndaki sýra ayný 
yapýlabilir. 

Eðer koda herhangi bir müdahale edilmezse ki bu müdahalelerden biri C++11 öncesinde de olan member initializer list'i
kullanarak istenen ctor öðe için seçilebilir. Eðer bu kullanýlmazsa derleyici memberlar için default ctor çaðýrýr.
Eðer memberlar için çaðýrýlacak bir default ctor yoksa veya öyle bir ctor vardýr ancak çaðýrýlmasý baþka nedenlerden
dolayý mümkün deðildir bu durumda derleyici sentaks hatasý verir. C++11 ile gelen seçenek olarak ise in-class initializer
da kullanýlabilir.

/////////////////////////////////////////////////////////////////////
class Game{
	std::vector<int> mvec;
	std::vector<int> m1vec{2, 3, 5, 7, 11}; //C++11'den itibaren
public:
}
/////////////////////////////////////////////////////////////////////
Game sýnýfýna constructor yazýlmasa veya yazýlsa ancak member initializer list ile initialize edilmese derleyici eleman
olan bu vektörü	default construct eder. Vektör sýnýfýnýn default ctor'u size'ý 0 olan henüz bir öðe tutmayan bir vektör
oluþturmak. Eðer belirli deðerler ile hayata gelen bir vektör isteniyorsa, eskiden olmayan C++11 ile gelen bir sentaks 
aracý ile doðrudan in-class initializer kullanýlabilir. Sýnýfa default constructor yazýlmasa bile derleyici kendi yazdýðý
default ctor ile bu öðe için gereken kodu yazar ve vektor sýnýfýnýn ilgili ctorunu çaðýrýr.

Baþka bir sýnýf türünden öðeye sahip olmak o membera iliþkin sýnýfýn private bölümüne eriþim hakký vermez tabi friendlik
verilmediði sürece.
Programýn akýþý owner nesnenin destructor'ýnýn kodunun içine girdiðinde, ana bloktaki bütün kodlar yapýlýr ondan sonra 
memberlarýn destructor kodlarý çalýþýr, bu da sondan baþa doðru, en son hayata gelen member ilk hayata veda eder.

Composition'da Copy Constructor'ýn Durumu:  

Car bir owner nesne, engine ise sahip olunan nesne, her arabanýn bir motoru var örneði. Elimizde bir car nesnesi var ve
kopyalama yoluyla yeni bir car nesnesi oluþturulmak isteniyor. Car c1 = c2; gibi bir ifadede bu yapýlabilir.
Dilin kurallarýna göre eðer car sýnýfý için bir copy ctor yazýlmamýþsa veya copy ctor programcý tarafýndan yazýlmýþ ancak
MIL sentaksý ile bir müdahalede bulunulmamýþsa derleyici car içindeki engine'i, engine sýnýfýnýn copy ctor'unu çaðýrarak diðer 
nesnenin engine'inden oluþturur. 
Eðer Car sýnýfý için copy ctoru programcý olarak biz kendimiz yazýyorsak ancak bu copy ctora müdahale etmiyorsak bu durumda
derleyici copy ctor'u çaðýrmaz, default constructor'ý çaðýrýr. Copy ctor'u derleyici yazarsa elemaný copy construct eder ancak
programcý yazýp herhangi bir müdahalede bulunmazsa derleyici bu durumda default construct eder. 


/////////////////////////////////////////////////////////////////////
class Engine {
public:
	Engine() = default; //C++11 ile 
	Engine(const Engine &c)
	{
		std::cout << "Engine::Copy Constructor" << std::endl;
	}
};

class Car {
	Engine e;
public:

};

int main()
{
	Car c1;
	
	Car c2{ c1 }; //copy ctor'un çaðrýlmasý gereken durumlardan biri
	
}
/////////////////////////////////////////////////////////////////////
Car sýnýfýnýn copy constructor'ýný derleyicinin kendisi yazdý. Sýnýflarýn copy ctor'u olmak zorunda.
Derleyici karþýlýklý bütün öðeleri copy construct edecek þekilde bir copy ctor yazar.
Derleyici aslýnda þöyle bir copy ctor yazar;
Car(const Car &c) : e{c.e}, ..... {}
Program çalýþtýrýldýðýnda Engine::Copy Constructor yazýsý çýkar. 


/////////////////////////////////////////////////////////////////////
class Engine {
public:
	Engine()
	{
		std::cout << "Engine::Default Constructor" << std::endl;
	}
	Engine(const Engine &c)
	{
		std::cout << "Engine::Copy Constructor" << std::endl;
	}
};
class Car {
	Engine e;
public:

};

int main()
{
	Car c1;
	
	Car c2{ c1 };
	
}
/////////////////////////////////////////////////////////////////////
Önce Engine::Default Constructor yazýsý çýkar, bunun sebebi Car sýnýfý türünden yaratýlmýþ olan c1 nesnesi 
içinde Engine sýnýfý türünden e nesnesinin hayata gelmiþ olmasý.
Ardýndan ise Engine::Copy Constructor yazýsý çýkar, bunun sebebi ise c2 nesnesinin içindeki Engine sýnýfý
türünden e nesnesinin copy construct edilmesi.


/////////////////////////////////////////////////////////////////////
class Engine {
public:
	Engine()
	{
		std::cout << "Engine::Default Constructor" << std::endl;
	}
	Engine(const Engine &c)
	{
		std::cout << "Engine::Copy Constructor" << std::endl;
	}
};
class Car {
	Engine e;
public:
	Car() = default;
	Car(const Car &c)
	{
		std::cout << "Car::Copy Constructor" << std::endl;
	}
};

int main()
{
	Car c1;
	
	Car c2{ c1 };
	
}
/////////////////////////////////////////////////////////////////////
Burada ise Car sýnýfý için sýnýfýn copy constructor'ý programcý tarafýndan yazýldý ancak MIL sentaksý ile
herhangi bir kod yazýlmadý.
Kod çalýþtýrýldýðýnda iki kez Engine::Default Constructor yazýsý çýktýðý görülür, ilki yine c1 nesnesi 
içindeki Engine sýnýfý türünden e nesnesi için. Ancak ikincisi ise c2'nin içindeki Engine nesnesi için
çýkmýþtýr, o da default construct edilmiþtir.

/////////////////////////////////////////////////////////////////////
class CryptoTrader {
	std::string mname;
	Date mbdate;
public:
	CryptoTrader(const std::string &name, const Date &d) : mname{name}, mbdate{d} {}
	void display()const {
		std::cout << "(" << mname << ", " << mbdate << ")" << std::endl;
	}
};
int main()
{
	CryptoTrader ctp{ "Aykut Ercan", Date{4, 7, 1990} };

	ctp.display();

	CryptoTrader ctp2{ ctp };

	ctp2.display();
	
}
/////////////////////////////////////////////////////////////////////
Kopyalama semantiðine göre ctp2 ile ctp ayný olmalý. CryptoTrader'in derleyici tarafýndan
yazýlmýþ bir copy ctoru var. Derleyici yazdýðý copy ctorda bildirimdeki ayný sýrayla copy 
construct etti. ctp2'nin displayi çaðýrýldýðýnda ayný isim ve ayný tarihlerle hayata geldiði
de görülür.



/////////////////////////////////////////////////////////////////////
class CryptoTrader {
	std::string mname;
	Date mbdate;
public:
	CryptoTrader(const std::string &name, const Date &d) : mname{name}, mbdate{d} {}
	CryptoTrader(const CryptoTrader &c)
	{
		/////
	}
	void display()const {
		std::cout << "(" << mname << ", " << mbdate << ")" << std::endl;
	}
};
int main()
{
	CryptoTrader ctp{ "Aykut Ercan", Date{4, 7, 1990} };

	ctp.display();

	CryptoTrader ctp2{ ctp };

	ctp2.display();
	
}
/////////////////////////////////////////////////////////////////////
Sýnýfý yazan programcý, sýnýfa bir copy ctor yazmýþtýr. Yazarken MIL sentaksý için
herhangi birþey yazmamýþtýr. Copy ctor'un ana bloðu içine ise istediði kodlarý yazmýþ olduðu
düþünülsün. Bu durumda sentaks hatasý yok. Burada genel beklenti sanki derleyicinin gereken
kopyalamalarý sanki copy ctoru derleyici yazmýþ gibi yapacak olmasý ardýndan copy ctorun bloðu
içinde programcýnýn yazmýþ olduðu kodlarýn yürütülmesi. Bu durumda copy ctor programcý 
tarafýndan yazýldýðýndan, derleyici string türünden mname'i ve Date türünden mbdate'i
default construct eder. String'in default constructor'ý boþ string oluþturur, Date sýnýfýnýn
default ctor'u ise bugünün tarihi ile deðer verir.

Bir sýnýf için bir nedenden dolayý copy constructor yazýlýyor ise, istisnasýz bütün öðeleri copy
construct etmek(eðer istenilen buysa) programý yazanýn sorumluluðunda. Bir veya birden fazla öðe
Member Initializer List kullanýlarak copy construct edilmezse, derleyici onlar için default ctor'u
çaðýrýr. Eðer bu default constructorlardan biri yoksa, private ise error oluþur.


Pair, C++'nýn utility isimli baþlýk dosyasýnda tanýmlanan bir template class. Hatta bir structure,
yani default bölümü public. Pair'in varlýk nedeni, iki tane ayrý deðeri tek bir deðer olarak paket-
lemek. Template tür parametreleri, tutacak deðerlerin türünü göstermeli.

/////////////////////////////////////////////////////////////////////
template<typename T, typename U>
std::ostream &operator<<(std::ostream &os, std::pair<T, U> &p)
{
	return os << "(" << p.first << ", " << p.second << ")";
}
int main()
{
	pair<int, int> x;
	pair<int, int> y{ 23, 65 };
	
	cout << x << endl;
	cout << y << endl;
}
/////////////////////////////////////////////////////////////////////
Eðer default ctor kullanýlýrsa, yapýnýn first ve second elemanlarý 0 ile initialize
edilir.

/////////////////////////////////////////////////////////////////////
int main() 
{
	pair<Date, Fraction> x;
	pair<Date, Fraction> y{ Date{12, 05, 1987}, Fraction{3, 5} };

	cout << x << endl;
	cout << y << endl;
	
}
/////////////////////////////////////////////////////////////////////
Pair'in öðeleri user defined typelerdan da olabilir. x nesnes için  Date ve Fraction
öðeleri default construct edilir.

Genel Notlar:

Taþýma Semantiði ile Ýlgili Not: Her þey vektör sýnýfýnýn optimizasyonu ile baþladý. Bir vektörün 
anatomisi basitleþtirilmiþ þekilde þu þekilde: vektör nesnesi memberlarýnda vektörün yönetimini 
saðlayacak öðeleri tutar. Bu öðelerden biri, dinamik bellek bloðunun adresi yani begin deðeri,
bir diðeri end diðeri ise capacity deðeri. Yani en basit anlamda vektör iki tane adres bir de 
kapasite deðerini tutar. Adreslerden biri dinamik bellek bloðunun adresi, diðeri ise sondan ekleme
ile yazýlacak adres. Vektör nesneleri için kopyalamada, dinamik bellek alanýndaki öðeler birbirine
kopyalanýr(deep copy), taþýmada ise sadece pointerlar kopyalanýr, kaynak olan vektör nesnesinin
öðeleri ise nullpointera çekilir. Move ctor'ýn parametresi r-value reference. 

Özel Üye Fonksiyonar:
default constructor  X();
destructor			 ~X();
copy constructor   	 X(const X &);	
copy assignment		 X& operator=(const X &);
move constructor	 X(X &&);
move assignment		 X& operator=(X &&);

Özel üye fonksiyonlar; not declared olabililr yani hiç bildirilmeyebilir, bir sýnýf yazýlýyor ve sýnýfa copy
constructor hiç bildirilmiyor. Implicitly declared olabilir, açýk açýk bildirilmiyor ancak dilin kurallarýna 
göre bildirilmiþ kabul ediliyor. User declared de olabilir, bu durumda programcý tarafýndan açýk açýk bildirimi
yapýlmýþtýr. Implicitly declared olduðunda iki alt kategori mevcut: default ederek implicitly declared da 
edilmiþ olabilir, delete ederek de implicitly declare edilebilir.

Örnek olarak default constructor ele alýnmýþ olsun
class Myclass
{
	//Burada default ctor: implicity declared, defaulted
}
class Myclass
{
	Myclass() = default; //user declared, defaulted
}
class MYclass
{
	Myclass() = delete; //user declared, deleted
}
class Myclass
{
	Myclass();			//user declared, defined
}

User declared olduðunda ise deleted, defaulted ve user-defined olabilir.
Dilin kurallarýna göre neler user declared kabul edilir:
struct X
{
	X() {}			//user-declared, ctor bildirilmiþ ve sýnýf içinde inline olarak tanýmý yapýlmýþ
	X();			//user-declared, ctor bildirilmiþ ancak tanýmý burada yok
	X() = default;	//user-declared, ctor bildiriliyor ve default ediliyor
	X() = delete;	//user-declared, ctor bildiriliyor ve delete ediliyor
}

Peki not-declared ile deleted durumlarý arasýnda fark nedir, yani bildirilmemiþ olmasý ile delete edilmiþ
olma durumlarý arasýndaki fark nedir ? Delete edilmiþ olmasý ona yok muamelesi yapmaz, function overloading
resolutiona katýlýr. Deleted olan var ama silinmiþ kabul ediliyor, not-declared ise doðrudan mevcut deðil.
Deleted olan function overloadinge katýlýr.
Deleted members participate in overload resolution.
Members not-declared do not participate in overload resolution.

Hangi Durumlarda Compiler Programcý için bu özel fonksiyonlarý synthesize eder ?
Eðer programcý, bu altý fonksiyondan hiçbirini ve herhangi bir constructor yazmazsa derleyici bu özel
fonksiyonlarýn altýsýný da default olarak yazar.

Eðer programcý, özel üye iþlev olmayan herhangi bir constructor tanýmlarsa, derleyici default ctor'u kendisi
yazmaz. Ancak geriye kalan diðer özel üye iþlevlerin hepsi derleyici tarafundan yine default olarak yazýlýr. 
Yani örnek olarak bir sýnýfa int parametreli bir ctor yazýlýrsa, derleyici bu sýnýf için default ctor'u
yazmaz ancak diðerlerinin tümünü yazar.

Eðer programcý, default constructorý kendisi yazarsa derleyici diðer özel üye iþlevlerin tümünü yine kendisi 
yazar. 

Eðer programcý sýnýfa bir destructor yazar ise artýk derleyici programcý için move öðelerini bildirmez.
Yani derleyici bir move ctor ve move assignment bildirmez, bu ikisi artýk not declared durumunda olur.
Tabi default constructor yine derleyici tarafýndan yazýlýr.
Sýnýfa bir destructor yazýldýðýnda derleyici bizim için copy constructor ve copy assignmentý yine yazar.
Ancak aslýnda bu doðru deðil, yani bir sýnýfa destructor yazýlmýþsa çoðu durumda sýnýf için copy ctor ve 
copy assignment'in da yazýlmasý gerekir. Bu durumda bu ikisini derleyicinin kendisinin yazmasý lojik açýdan
programcýya hiçbir fayda saðlamaz hatta çoðu zaman zarar getirir. Bu yüzden yeni standarlara göre her ne 
kadar halen geçmiþten gelen kural korunsa da bu deprecated ilan edilmiþtir. 
Yani bir sýnýfa destructor yazýlmýþsa derleyici move üyeleri zaten yazmaz, copy üyeleri ise default olarak
yazar ancak bu da deprecated durumda yani copy'leri yazmasa aslýnda daha da iyi.

Eðer programcý sýnýfa bir copy constructor yazmýþsa derleyici default constructor'ý yazmaz. Ayný zamanda 
move memberlarý da  yine yazmaz. Destructor ve copy assignment'i yazar ancak copy assignment'ý yazmasý yine
deprecate edilmiþtir.


14_01_2018_PAZAR

Elimizde Neco sýnýfý olsun, Neco sýnýfýnýn da Fethi sýnýfý türünden bir öðesi olsun ancak Fethi sýnýfýnýn
constructor'ý private olsun. Bu durumda eðer Neco için bir constrcutor'ý derleyici yazarsa mecbur Fethi'nin
de default ctor'unu çaðýracak peki Fethi'nin default ctor'u private ise ne olacak ? Bu durumda çaðýrýlmasý
mümkün olmaz. Bu durumda derleyici Neco sýnýfýnýn bu fonksiyonunu deleted kabul eder. Bir fonksiyonu yazma
görevi derleyiciye býrakýlmýþsa fakat derleyicinin bu fonksiyonu kurallara göre yazmasý durumunda bir nedenden
dolayý sentaks hatasý oluþuyor ise(private fonksiyonu çaðýramamak, bir sýnýfýn default ctoruna çaðrý yapýlacak
ama o sýnýfýn bir default ctor'u yok gibi) bu durumda derleyici açýsýndan bu fonksiyonlar deleted kabul edilir. 


/////////////////////////////////////////////////////////////////////
class A {
	A(); //A sýnýfýnýn default ctoru, A sýnýfýnýn private bölümünde
};
class B {
	A ma;
};

int main() 
{
	B bx; // sentaks hatasý, B'nin default ctor'u derleyici tarafýndan delete edildi.

}
/////////////////////////////////////////////////////////////////////
Derleyicinin verdiði hata mesajý:
the default constructor of "B" cannot be referenced -- it is a deleted function
Buradaki hatanýn sebebi, delete edilmiþ bir fonksiyona çaðrý yapmak.
Yani default edilmiþ bir özel iþlev derleyicinin bu iþlevi yazamamasý durumunda derleyicinin delete
ettiði bir iþleve dönüþür. 

https://www.slideshare.net/ripplelabs/howard-hinnant-accu2014
http://plepa.com/2017/03/15/siniflarin-ozel-islevlerinin-derleyici-tarafindan-yazilmasi/

Eðer programcý sýnýfa move constructor yazarsa derleyici sadece sýnýfýn destructor'ýný default eder.
Bu durumda sýnýfýn kopyalayan iþlevleri derleyici tarafýndan delete edilir.
("defaulted" can mean "deleted" if the defaulted special member would have to do something illegal,
such as call another function)

Derleyici kurallar gereði move constructor ve move assignment'i yazabilir, derleyici örneðin bu
move ctor'u yazdý ancak bunu yazmasý sentaks hatasý durumuna düþtü. Bu durumda yukarýdaki örnek 
durumda olduðu gibi delete edilmesi beklenir ancak burada özel bir kural mevcut. Derleyici bir
move member'ý yazma sürecinde sentaks hatasý oluþacaðý için move member'ý delete ederse bu move
member, not declared olarak kabul edilir. Sýnýfýn taþýyan kurucu iþlevi veya taþýyan atama iþlevi
derleyici tarafýndan yazýlamadýðý için delete edilirse, hiç bildirilmemiþ olarak ele alýnýr.

/////////////////////////////////////////////////////////////////////
class Member {
	Member(Member &&) {}
public:
	Member() {}
	Member(const Member &) { cout << "Member Copy Ctor\n"; }
};

class A {
	Member m;
};

int main()
{
	A a1;
	A a2(move(a1));
}
/////////////////////////////////////////////////////////////////////
Normalde az önceki senaryolara göre A sýnýfýnýn tüm özel fonksiyonlarýný derleyici yazar, buna move ctor
da dahil. Derleyici move ctor'u yazarsa error olacak çünkü move ctor'un yazýlma kurallarýna göre 
derleyicinin elemanlarý için de move ctor'u çaðýrmasý gerekir oysa A sýnýfýnýn elemaný olan Member türünün
move ctor'u private. Derleyici þimdi A için move ctor yazarsa net error olacak. Ýþte bu durumda move ctor
delete edilmiþ kabul edilir, eðer derleyicinin yazdýðý taþýma fonksiyonlarý delete edilme durumuna düþerse
hiç bildirilmemiþ muamelesi görür. Kod derlendiðinde bir sentaks hatasý olmaz ancak tabi move ctor'un 
çaðýrýlmasý gereken yerde move ctor çaðýrýlmaz.

6 özel üye iþlevi derleyicinin yazmasý durumunda derleyici bu kodlarý nasýl yazar?
Default Ctor: Derleyici içi boþ bir constructor yazar.
Destructor: Yine içi boþ bir iþlev yazýlýr.
Copy Constructor: *this'in tüm memberlarýný parametre olan ayný türden sýnýf nesnesinin memberlarý ile copy
construct eder.
Atama Operatör Fonksiyonu: Derleyicinin atama operatör fonksiyonunu yazmasýnýn tek bir yolu var, *this'in
bütün öðelerine atama operatörü ile diðer nesnenin öðelerini atar. *this ile geri döner.
Move Constructor: Tüm öðeler için move constructorý çaðýrýr. Tüm öðeleri move etmesi gerekir. Yukarýdaki
örnekte deleted duruma düþmesinin sebebi de derleyicinin A sýnýfýna move ctor yazmasý gerekiyor bu durumda
da tüm öðeleri move etmesi gerekiyor ancak sýnýfýn öðesi olan m'nin move constructor'ý private olduðundan
ona yapýlan çaðrý sentaks hatasý durumuna düþer.
Move Atama: Bütün öðeler için move atamayý çaðýrýr. 

Ancak unutulmamalý ki o öðelerin move ctoru yoksa onlarýn yerine copy ctor çaðýrýlýr, yine o öðelerin move 
atamasý yoksa copy atama çaðýrýlýr. Bu yüzden sýnýflarýn her zaman olmasý gereken iki fonksiyonu copy ctor ve
copy atama fonksiyonu çünkü move fonksiyonlarýnýn yerine bunlar çaðýrýlýr.

Eðer sýnýfa move constructor veya move assignment yazýlýrsa derleyici, copy constructor ile copy assignment'ý
delete edilmiþ kabul eder. Sýnýfa move ctor ve move assignment yazýlýp, copy ctor ve copy assignment yazýlmazsa
derleyici copy fonksiyonlarý delete eder.

Sýnýfa destructor yazýlýyor ise copy constructor'ý derleyiciye yazdýrmakla doðru yapýlmýþ olmaz. Çünkü muhtemelen
zaten derleyicinin yazdýðý copy ctor programcýnýn iþine gelmeyecek.

Derleyici Move Constructor'ý yazarken, sýnýfýn elemanlarý varsa, elemanlara sahip sýnýf için derleyici move ctor
yazýyorsa elemanlarý da move ctor ile construct eder. 
Programcý da move ctor'u kendisi yazarken, derleyicinin yazdýðý gibi yazar. Elemanlar move constructor ile 
oluþturulur. 

Ýki sýnýf nesnesi birbirine atandýðýnda bu atama sýnýfýn kopyalayan atama operatör fonksiyonu ile yapýlýr.
Atamanýn sað tarafýndaki ifade bir r-value olsaydý, sýnýfýn kopyalayan atama operatör fonskiyonu deðil taþýyan
atama operatör fonksiyonu çaðýrýlýr.

/////////////////////////////////////////////////////////////////////
class Member {
public:
	Member &operator=(const Member &m)
	{
		std::cout << "Member::Copy Assignment Function\n";
		return *this;
	}
};
class A {
	Member m;
public:

};

int main()
{
	A a1, a2;

	a1 = a2;
}
/////////////////////////////////////////////////////////////////////
Fonksiyon çaðýrýldýðýnda a1 = a2 ifadesi için, A sýnýfýnýn memberi olan m nesnesi için kopyalayan atama 
operatör fonksiyonu çaðýrýlýr. Aslýnda görünürde olayýn Member sýnýfý ile bir alakasý yok, A sýnýfýndan iki
öðe birbirine atanýyor ancak derlenip çalýþtýrýldýðýnda Member'ýn copy assignment'ýnýn çaðýrýldýðý görülür.


Eðer sýnýfýn kopyalayan atama operatör fonksiyonu programcý tarafýndan yazýlacaksa:
Bu durumda öðelerin birbirine atanmasýndan programcýnýn yazdýðý fonksiyon sorumlu.

/////////////////////////////////////////////////////////////////////
class Member {
public:
	Member &operator=(const Member &m)
	{
		std::cout << "Member::Copy Assignment Function\n";
		return *this;
	}
};
class A {
	Member m;
public:
	A &operator=(const A &r)
	{
		std::cout << "A::Copy Assignment Function\n";
		m = r.m;
		return *this;
	}
};

int main()
{
	A a1, a2;

	a1 = move(a2);
}
/////////////////////////////////////////////////////////////////////

Bir sýnýf tasarlanýyorsa programcýnýn ilk görevi constructor yazmak. Default constructor sýnýf türü için 
anlamlýysa yazýlmalý. Ancak eðer sýnýf nesnesi için dýþarýdan bir deðer almadan bir nesnesnin hayata gel-
mesi anlamlý deðilse default constructor'ýn olmasý anlamlý olmaz. 
Bir sýnýfa çoðu durumda constructor dýþýndaki özel üye iþlevlerin yazýlmasý gerekmez çünkü derleyicinin
yazdýðý kodlar çoðu zaman programcýnýn ihtiyacýný zaten karþýlar. Büyük 5lideki fonksiyonlarý yazmak için
derleyicinin yazdýðý fonksiyonlarýn programcýnýn iþine gelmiyor olmasý gerekir. Eðer sýnýf nesnesi hayata
baþladýðýnda bir kaynak ediniyorsa o zaman bu fonksiyonlarýn yazýlmasý gerekir, sýnýfýn pointer veya 
referans elemaný var mý diye de bakýlýr. Eðer sýnýfýn elemanlarý baþka sýnýflar türündense yazýlmasýna 
gerek yok.

/////////////////////////////////////////////////////////////////////
class Weapon {
	std::string wname;	

}; 
/////////////////////////////////////////////////////////////////////
Weapon sýnýfýnýn, string sýnýfý türünden bir elemaný mevcut. Bu sýnýf için özel fonksiyonlarý yazmanýn bir
gereði yok. Derleyiciye býrakýlmasý durumunda derleyici bu stringleri birbirine kopyalar, birbirine atar,
birbirine taþýr. String sýnýfýnýn bu faaliyetlere yönelik kodlarý zaten var. O zaman herhangi bir þekilde bu
fonksiyonlarýn yazýlmasýna gerek yok.

Sýnýf üyelerinin dinamik bellek yönetimi ile bir ilgisi yoksa, kaynak kullanýmý ile bir ilgisi yoksa bu
fonksiyonlarýn yazýlmasýna gerek yok. String sýnýfý türünden veya sýnýfta kullanýlan Date sýnýfý türünden
öðeler varsa bu fonksiyonlarýn derleyicinin yazmýþ olduðu fonksiyonlar olmasý zaten yeterli.

Sýnýfýn herhangi bir sýnýf türünden bir pointer öðesi varsa, bu sýnýfa iliþkin copy ctor, copy assignment gibi 
fonksiyonlarýn yazýlmasý derleyiciye býrakýlýrsa, derleyici pointerlarý birbirine kopyalar. Bu pointer veya
pointerlar da kaynaklarý iþaret ediyorsa o zaman kaynaklar paylaþýlmýþ olur. Ýstenen gerçekten de kaynaklarýn
paylaþýlmasý olabilir ancak bu þekilde yapmak doðru deðil. Bu þekilde yapýldýðýnda kaynaklar paylaþýlýr ancak
örnek olarak 10 tane nesne ayný kaynaðý paylaþýyor ise bir tanesi destruct edildiðinde kaynaklarý geri verir, 
hayatta olan nesnelerin de kaynaklarý yok olmuþ olur onlarý kullanmak run time hatasýna yol açar. 
Sýnýfýn veri elemaný pointersa büyük ihtimalle copy ctor ve copy assignment'ý programcýnýn yazmasý gerekecek.

Peki move constructor ve move assignment ne zaman yazýlýr?
Birçok durumda bu iki özel üye iþlev programcý tarafýndan yazýlýr. Eðer copy ctor'ý programcýnýn yazmasýnýn
nedeni kaynaðý paylaþmak yerine her nesne kendi kaynaðýný edinsin, diðer nesnenin kaynaðýndan kopyalama yapsýn
ise yani deep copy ise burada bir dezavantaj oluþur. Hayatý bitmek üzere olan bir nesneden kopyalama yapýldýðýnda 
veya atama yapýldýðýnda yine kopyalama yapýlacak ancak buradaki kopyalama maliyet artýþý demek. Move constructor ve
move assignment'ý yazarak gerekmeyen yerde bu kopyalamanýn yapýlmasý engellenir. Ancak bunlar yazýlmazsa gerekse de 
gerekmese de her yerde kopyalama yapýlýr. Örnek olarak vektör sýnýfý biz yazýyor olsaydýk; copy ctor, destructor,
atama operatör fonksiyonunu yazacaktýk çünkü her vektör için ayrý bir bellek alaný gerekiyor. Move'larý yazmasak 
herhangi bir hata, run time hatasý olmaz ancak aslýnda taþýma ile maliyetin azaltýlabileceði her yerde gereksiz 
kopyalama yapýlmýþ olur. 

Eskiden smart pointer sýnýflarý yoktu, þimdi birçok durumda da copy ctor, move ctor vs, bunlarý yazma zorunluluðu
ortadan kalkýyor çünkü pointer yerine smart pointer member alýndýðýnda her durumda olmasa da birçok durumda özel 
iþlevleri yazma zorunluluðu ortadan kalkýyor.

Eðer sýnýfýn öðesi baþka bir sýnýf türünden yapýlýrsa composition implemente edilmiþ olur, burada artýk ömürsel bir
birliktelik olmak zorunda. Yaþamýnýn baþlangýcýnda deðil de, belirli bir kesitinde bir öðeye sahip olarak o öðeyle iþ 
yapma durumu varsa bu durumda doðrudan composition iþimize gelmez. Ýþte bu durumda dinamik bellek yönetimi ve dinamik
nesne kullanýmý artýk bir zorunluluk haline gelir, o nesneye ne zaman ihtiyaç duyulacaðý programýn çalýþma zamanýnda
belirli olacaðýndan tamamiyle ömürsel bir birliktelik kullanmak doðru olmaz.

Fonksiyonlarýn delete edilmesi özel fonksiyonlar için getirilmiþ bir kural. Örnek olarak bir sýnýfýn kopyalamaya karþý
tamamen kapatýlmasý isteniyorsa eskiden fonksiyonlarýn delete edilmesi gibi bir araç olmadýðýndan yapýlabilecek en iyi
þey fonksiyonlarý private yapmaktý ama private fonksiyonu her ne kadar biz çaðýramýyor olsak da sýnýfýn kendi 
kodlarýnýn çaðýrabiliyor olmasý da bu konseptin problemli kýsmýydý. Bu durumda sýnýfýn kendi kodlarýnýn o sýnýf türünden
nesnelerin kopyalanmasýna izin vermesini engellemez. 
Bir diðer yöntem ise bildirip tanýmlamamaktý. Yani private olarak bildirip tanýmýný yapmamaktý böylece sýnýfýn kendi kodlarý
bir kopyalamaya neden olsa dahi linker hata verirdi. 
Bu sebeplerle delete aslýnda çok önemli bir çözüm. Bir sýnýfýn herhangi bir özel fonksiyonu bir nedenden dolayý kapatýlmak
isteniyorsa kullanýlýr. Kopyalamaya karþý kapatmak için fonksiyon delete edilir.
Yani fonksiyonlarýn delete edilmesi aslýnda özel iþlevlerin delete edilebilmesi için ortaya çýkmýþ bir ihtiyacýn karþýlýðý.
Fakat default'dan farklý bir þekilde(global fonksiyonlar default edilemez, sadece özel fonksiyonlar default edilebilir,
sýnýfýn herhangi bir üye iþlevi de default edilemez) delete sadece özel üye iþlevler ile sýnýrlý deðil.

Madem bir fonksiyonu delete etmek sentaksa aykýrý deðil o zaman global bir fonksiyonu veya bir sýnýfýn bir üye fonksiyonu
delete edilirse, function overload resolutiona açýk. Yani bir fonksiyonu delete etmekle belirli bir türden argüman için
çaðýrýlmasý yasaklanabilir. Mesela func isimli bir fonksiyon var ve kesinlikle int türden bir parametre ile çaðýrýlmasý 
istenmiyor bu durumda derleyicinin henüz compile time'da hata vermesi için delete kullanýlabilir.

/////////////////////////////////////////////////////////////////////
void func(double);
void func(char);
void func(int) = delete;

int main()
{
	func(12);
}
/////////////////////////////////////////////////////////////////////
int parametreli func fonksiyonu function overload resolutiona katýlýr. Dolayýsýyla resolution kurallarýna göre int 
parametreli olan çaðýrýlýr ancak delete edilmiþ olduðundan sentaks hatasý.


Bir fonksiyonun salt belirli bir türden argüman ile çaðrýlabilir onun dýþýnda hiçbir argüman ile çaðrýlamayacak
þekilde olmasý için de bir tane template olmayan gerçek bir fonksiyon yazýlýr bir de fonksiyon þablonu yazýlýr.
Dilin kuralýna göre bir fonksiyon þablonu ile ayný isimi paylaþan gerçek bir fonksiyon bir arada bulunduðunda
eðer bu isimde bir fonksiyon çaðrýsý yapýlýrsa dilin kuralýna göre argüman ile gerçek fonksiyonun parametresi 
exact match ise derleyici fonksiyon þablonundan fonksiyon yazmaz. Ancak parametrenin türünün farklý olduðu her
durumda derleyici buradan fonksiyon yazar.

/////////////////////////////////////////////////////////////////////
template<typename T>
void func(T)
{
	cout << "template function type T is " << typeid(T).name() << endl;
}

void func(int)
{
	cout << "real function func(int) " << endl;
}

int main()
{
	func(2.6);
}
/////////////////////////////////////////////////////////////////////
Burada fonksiyonun int dýþýnda bir parametre ile çaðýrýlmasý durumunda derleyici kod yazar ve function template'e
çaðrý yapýlýr. Ancak func fonksiyonu int parametre ile çaðýrýlýrsa dilin kurallarýna göre int parametreli olan
func fonksiyonu çaðýrýlýr, þablon olan deðil.


Function templateler de delete edilebildiðinden, derleyici fonksiyon yazmasý gerektiði yerde fonksiyon yazmaya
çalýþacak ancak o da delete edildiðinden ona yapýlan çaðrý sentaks hatasý olacak.
int dýþýnda herhangi bir türden deðer ile fonksiyona çaðrý yapýldýðýnda sentaks hatasý.
/////////////////////////////////////////////////////////////////////
template<typename T>
void func(T) = delete;
void func(int)
{
	cout << "real function func(int) " << endl;
}

int main()
{
	func(2.6);
}
/////////////////////////////////////////////////////////////////////
  
Þablon kod, diðer kodlar ile karýþtýrýlmamalý. Derleyicinin þablon kod için yaptýðý sentaks kontrolleri çok daha sýnýrlý.

Sýnýf kopyalamaya karþý kapatýldýðý zaman containerlarda tutma þansýmýz da büyük ölçüde azalýr.
/////////////////////////////////////////////////////////////////////
class Myclass {
public:
	Myclass(int);
	Myclass(const Myclass &) = delete;
};
int main()
{
	vector<Myclass> vec;
	Myclass m1{ 23 };

	vec.push_back(m1);

}
/////////////////////////////////////////////////////////////////////
Bütün STL containerlarý default olarak kopyalama semantiði ile çalýþýr yani vektöre konulan m1 nesnesinin
kendisi deðil. Vektöre bir nesne koymak istendiðinde bunun bir kopyasý çýkartýlýr ve vektöre o kopya konur.
Bu iþlemin yapýlmasý için ilgili sýnýfýn copy constructorý gerekiyor ancak Myclass sýnýfýnýn copy ctor'ý yok.
Eðer halen kopyalamaya karþý kapatmak ancak containerda da tutabilmek isteniyorsa bazý baþka teknikler 
kullanýlabilir.(Containera nesne koyulmaz, pointerlar veya smart pointerlar konabilir veya kopyalamaya kapalý
ama taþýmaya karþý açýk olur containera koyarken taþýyarak koyulur) 
Bu tür durumlarda vektörün pointer açýlýmý yerine, smart pointerlarýn avantajlarý olmasý sebebiyle 
vektörün smart pointer açýlýmý kullanýlýr.



Bir sýnýf bazen sadece bir iþi yapmak için bir sýnýfý kullanýyor, o iþ yapýlmazsa o sýnýfla da baþka bir 
alakasý yok, dependency iliþkiþi. Bu C++'da kod tarafýna bakýldýðýnda, koddaki yansýmasý bir sýnýfýn üye 
fonksiyonunun parametresinin baþka bir sýnýf türünden olmasý veya bir sýnýfýn bir üye fonksiyonunun yerel
deðiþkenlerinden birinin baþka bir sýnýf türünden olmasý. 

Associaton, aggregation, compositionda bir iþin yapýlmasý için iki sýnýf nesnesi iþ birliði halinde çalýþýr.
O iþin yapýlmasý için, o iki nesnenin olmasý gerekiyor ve bir kereliðine mahsus deðil, bu nesnelerin bu 
çalýþma düzeni için hep birbirine ihtiyacý var. Eðer burada biri sahip durumunda, biri diðerini yöneterek 
bu iþi yapýyorsa buna aggregation, ikisinin ömürsel birlikteliði varsa ise composition.
Composition popüler olarak "has a ?" iliþkisi.


KALITIM(INHERITANCE)

Popüler olarak "is a ?" iliþkisi de denir. Her Mercedes bir arabadýr. Mercedes tanýmlanýrken, mercedes'in
tanýmýnda araba kullanýlýr, yani her mercedes bir arabadýr. Is a iliþkisi bir sýnýfýn ayný zamanda baþka 
bir sýnýfýn interface'ine tamamen sahip olduðunu dolayýsýyla o sýnýftanmýþ gibi diðer sýnýfýn nesnelerinin
kullanabileceðini anlatýyor. Ýþin yapýlmasý için bir araba gerektiðinden, Mercedes de bir araba olduðundan
mercedes gönderilebilir ayný þekilde Dacia da bir araba olduðundan Dacia da gönderilebilir.
Is a iliþkisi bir sýnýfýn, yeri geldiðinde sanki baþka bir sýnýf türündenmiþ gibi kullanýlabilir olduðuna
iþaret eden bir iliþki biçimi. Böylece aslýnda farklý farklý sýnýflar olmasýna raðmen hepsi ortak bir 
arayüzü desteklediðinden, o ortak arayüze baðlý olarak yazýlmýþ kodlar o sýnýflardan herhangi birini kullanabilir.
Kalýtýmda tipik olarak olaya konu iki sýnýf var, biri zaten var olan interface'ini devir almak istediðimiz 
sýnýf. Bir de bu interface'i, kendi interface'ine katacak bir sýnýf, mesela araba sýnýfýndan kalýtým yolu
ile bmw sýnýfý elde edilir. Bmw sýnýfý artýk otomatik olarak araba sýnýfýnýn interface'ini kendi interface'ine
katar. Araba sýnýfýnýn clientlarý, araba sýnýfýnýn public fonksiyonlarýna çaðrý yapabiliyorsa, BMW sýnýfýnýn
clientlarý da halen araba sýnýfýnýn o interface'indeki public fonksiyonlarý çaðýrabilecekler.

Composition'dan farklý olarak bir interface devralma iliþkisi mevcut.
Compositinda yaptýðýmýz Car, Engine örneðini düþündüðümüzde, Car sýnýfýnýn Engine sýnýfýndan bir öðeye sahip
olmasý demek, Car sýnýfýnýn Engine sýnýfýnýn public interface'ini devralmasý anlamýna gelmez. Eðer öyle olsaydý
Car sýnýfý türünden nesneler, doðrudan Engine sýnýfýnýn public üye fonksiyonlarýný da çaðýrabilirdi ancak bu
mümkün deðil.
Kalýtýmda ise durum gerçekten de böyle yani Engine sýnýfýndan kalýtým yoluyla bir sýnýf elde edilmiþ olsa, yeni
sýnýfýn public bölümüne bir tane bile fonksiyon konulmasa, Engine sýnýfýnýn interface'i olduðu gibi yeni sýnýfýn
interfaceine eklenir.

Öncelikle kalýtým, nesne yönelimli programlamaya destek veren programlama dillerinin hiçbirinde selektif bir 
interface devralma iliþkisi deðil. Bir nedenden dolayý mesela bir sýnýfýn interfaceinin tamamý deðil de belirli
bir kýsmý hariç interface'i isteniyorsa bu durumda kalýtým uygun deðil. Örnek olarak Car diye bir sýnýf var
interfaceinde ise opensunroof diye bir fonksiyon var, programcý Opel sýnýfýnda ise opensunroof fonksiyonunu
istemiyor bu durumda kalýtým yolu ile Car sýnýfýndan Opel sýnýfýný elde etmek iyi bir çözüm deðil.
Interface'in hepsinin deðil belirli bir kýsmý alýnmak isteniyorsa yine akla gelen Composition olmalý böylece
interface kontrollü olarak istenen sýnýfýn interfaceine katýlýr.
Kalýtým dendiði zaman her zaman istisnasýz interfaci olduðu gibi devralmak akla gelmeli.

Nesne yönelimli programlamanýn uyulmasý gereken çok temel bazý ilkeleri var.(S.O.L.I.D ilkeleri)

Kalýtým bir interface devralma iliþkisi olduðu için zaten "is a ?" iliþkisi deniyor.
Buradaki temel hedef bir nesneyi o nesnenin desteklediði interface ile baþka bir türdenmiþ gibi kullanabilmek
böylece farklý fakrlý türden nesneleri ayný türdenmiþ gibi ele almak.

Kalýtým ile yeni tanýþan programcýlarýn çoðu baþlangýçta kalýtýmý bir code re-use olarak düþünüyor, yani kodun
tekrar kullanýlmasý. Kalýtýmda tabi ki kodun tekrar kullanýlmasý durumu var ancak kesinlikle kalýtýmýn temel
avantajý bu deðil, faydalarýndan biri. Kalýtýmýn temel amaçlarýndan biri eski kodlarýn yeni kodlarý kullanabilmesi,
yani daha önceden yazýlmýþ kodlarýn daha sonradan yazýlmýþ kodlarý kullanabilmesi. Bir kod sisteminde var olan
kodlarý hiç deðiþtirmeden kod ekleyerek sistemin çalýþmasý tamamen deðiþtirilebilir bu ancak kalýtým denilen 
mekanizmasý ile mümkün.

Kalýtýmda olaya konu alan iki tane sýnýf var, bunlardan biri var olan sýnýf yani interface'i devralýnacak olan sýnýf
diðeri ise o interface'i devralarak oluþturulan yeni sýnýf. Bu sýnýflar verilen bazý teknik terimler mevcut. Bu
terimlerin bazýlarý OOP terminolojisi bazýlarý ise C++ terminolojisi. Nesne yönelimli programlamada interface'i
devralýnan sýnýfa "Parent Class" denir, bir baþka terminolojide "Super Class" da denir. Her Mercedes bir arabadýr,
zaten bir Araba sýnýf var, Araba sýnýfýnýn interface'ini devralan bir Mercedes sýnýfý oluþturulmak isteniyorsa 
burada kalýtýma konu olan Araba sýnýfýna Parent Class denir. Kalýtým yoluyla, parent class'ýn veya super class'ýn
interface'ini devralmýþ belki de eklemeler yapýlmýþ olan sýnýfa da "Child Class" veya "Sub Class" demek çok yaygýn.

Her Smart Telefon bir Elektronik Cihazdýr. Smart Telefon, Elektronik Cihaz sýnýfýndan kalýtým yoluyla elde edilebilir.
Burada Elektronik Cihaz, parent class; Smart Telefon ise child class.

C++'da inheritance teriminin dýþýnda bir de C++'a özgü derivation ve derive terimi var. C++'da türetme yerine
derive fiili kullanýlýr. C++'da Super Class için daha çok Base Class terimi kullanýlýr. Child Class içinse
daha çok Derived Class terimi kullanýlýr. C++'da olayý daha karmaþýk hale getiren bazý faktörler var. C#, Java
gibi dillerde kalýtýmýn bir türü yok, kalýtým kalýtýmdýr, her zaman is a iliþkisidir. C++'da ise 3 ayrý kalýtým
aracý var, public inheritance, protected inheritance ve private inheritance. Her ne kadar terimlerde üçünde de
inheritance geçiyor ise de, nesne yönelimli programlamadaki kalýtým anlamýndaki kalýtým C++'daki public
inheritance. Yani private ve protected inheritance'ýn interface devralma iliþkisi ile bir ilgisi yok. Private 
inheritance ve protected inheritance compositiona bir alternatif. Yani private ve protected inheritance'ýn
nesne yönelimli programlamadaki kalýtým ile ilgisi yok, isimleri kalýtým ancak kendileri compoisitona denk.
Kalýtým denildiðinde, public inheritance kastediliyor.

C#, Java gibi dillerin doðrudan bir araçla desteklemediði, C++'ya özgü multiple inheritance(çoklu kalýtým)
denilen bir araç da var. Diðer diller multiple inheritance aracýný doðrudan sunmaz. Multiple Inheritance'da bir 
defada birden fazla sýnýfýn interface'i devralýnýr. Ýki tane ayrý sýnýf olduðu düþünülsün, Fax ve Modem sýnýflarý.
Bu iki sýnýfýn ayrý interfaceleri mevcut, öyle bir sýnýf oluþturulmak isteniyor ki, bu sýnýfýn interface'ine
hem Fax sýnýfýnýn hem de Modem sýnýfýnýn interface'i dahil olacak. C++'da multiple inheritance denilen araçla
tek bir iþlem ile birden fazla sýnýfýn interface'i devralýnabilir. 
Bu durum kalýtým hiyerarþisi ile karýþtýrýlmamalý. Örnek olarak Car sýnýfýndan BMW sýnýfý, BMW sýnýfýndan da
SportBMW sýnýfý türetilebilir. Bu yukarýdan aþaðýya hiyerarþik bir düzen içerisinde gerçekleþir. Multiple
Inheritance ise bu deðil, tek bir iþlem ile birden fazla sýnýfýn interfaceini baþka bir sýnýfýn interfaceine
katmak.

Kalýtým asýl gücünü runtime polymorphism, çalýþma zamaný çok biçimliliði denilen araç ile kendisini gösterir.
Kalýtýmda bu dillerde, Super Class'ýn interface'i devralýnýyor, iþte interface'i devralýnan bu sýnýflarýn
operasyonlarý üç temel kategoriye ayrýlýyor. Bu üç temel kategori birbirinden iyi bir þekilde ayrýlmalý, bu 
C++'a özgü deðil nesne yönelimli programlamaya ait genel bir özellik. Super Class'ýn operasyonlarý nesne 
yönelimli programlamada üç kategoride: 
Birinci kategori: Kendisinden kalýtým yoluyla elde edilecek sýnýflara hem interface veriyor hem de 
implementasyon veriyor, implementasyon kod demek. Yani bu super class'lar kendilerinden kalýtým yolu ile 
elde edilecek sýnýflara interface'i verir, ve verdiði bu interface'in yine super class'ýn verdiði kodlarý 
kullanmasýný söyler. Mesela Airplane bir superclass olsa, ve fly(uçaðýn uçmasýný saðlayan interface veya metot)
bu denilen kategoride olsa, örneðin bu Airplane'den Tesla kalýtým yolu ile elde edildiðinde Tesla'da Airplane'in
verdiði kodla uçacak. Burada bir seçim hakký yok, verilen interface ile verilen implementasyon kullanýlmak zorunda.
Ýkinci kategori: Superclass'ýn öyle bir operasyonu var ki, kalýtým yolu ile elde edilecek sýnýflar yine bu 
interface'i alacaklar yalnýz Superclass default bir kod verecek, bu kodu kullanýp kullanmamayý diðer sýnýfa 
býrakacak. Mesela fly eðer bu kategoride bir fonksiyon olsaydý, her Tesla uçar çünkü Tesla da bir Airplane'dir
ama ister Airplane'in saðladýðý kod ile uçar ister bunun için kendisi ayrý bir kod oluþturur. Bu kategoride seçim
hakký kalýtým yolu ile elde edilecek sýnýfa býrakýlýr. Bu sýnýfý tasarlayan ister Airplane'in kodunu seçer ister
kendi kodunu kendi saðlar. Interface veriyor ve default implementasyon veriyor.
Üçüncü kategori: Bu kategoride ise Superclass interface'i kalýtým yolu ile diðer sýnýflara verir ancak implementasyon
vermez. Kalýtým yolu ile elde edilen sýnýflar kendileri kod saðlamak zorundalar. fly interface'i kalýtým yolu
ile verilir ancak kodu kalýtým yolu ile elde edilen sýnýf yazmak zorunda. Kalýtým ile elde edilen sýnýf kod yazmaya
zorlanýyor.

Eðer bir sýnýfýn ikinci kategoride en az bir fonksiyonu varsa, böyle sýnýflara nesne yönelimli programlamada 
polimorfik sýnýf denir. Yani kalýtým yolu ile elde edilen sýnýf için temin etme hakký tanýnan Superclass'ýn en
az bir tane fonksiyonu varsa böyle sýnýflara polimorfik sýnýf denir, en az bir tane böyle operasyon olmak zorunda.

Kalýtýmla birlikte gelen bir terim daha var, bu terim override. Overload ile karýþtýrýlmamalý. Ezme fiili tercih
edilebilir. Ýkinci kategori düþünüldüðünde yani interface ile birlikte default implementasyon veren yani kod temin
etmenin kalýtým ile elde edilen sýnýfa býrakýldýðý durumlarda o kodu temin etmeye o operasyonu override etmek denir.
Mesela her Airplane uçar, isted Airplane'in verdiði kod ile uçar isterse de kalýtým yolu ile elde edilen sýnýfýn
saðlayacaðý kod ile uçar. Eðer bu hak kullanýlýyorsa, uçma iþi kalýtým ile elde edilen sýnýfýn kendi kodu ile 
saðlanýyorsa bunun teknik söylemi o operasyonun override edilmesi.

Üçüncü kategori düþünüldüðünde de yine verilen interface'e saðlanan implementasyon için de override terimi kullanýlr.



20_01_2018_CUMARTESÝ

Aslýnda soyutlandýklarý zaman ayný türdenmiþ gibi kabul edilebilecek fakat implementasyonlarý farklý olabilecek sýnýflar
ayný türdenmiþ gibi manipüle edilebiliyor. Kalýtým mekanizmasýnýn özü, eski kodlarýn yeni kodlarý kullanabiliyor
hale gelmesi ve sistemde bir deðiþiklik yapmak için eski kodlarý deðiþtirmek yerine kod ilave ederek bu deðiþikliði
gerçekleþtirmek.

Modelleme dillerinde kalýtým iliþkisi, sýnýf diagramlarýnda kalýtým ile elde edilmiþ sýnýftan yani child classdan
(sub classdan), parent classa doðru bir çizgi ve bu çizginin ucunda bir ok ile gösterilir.

C++'daki public inheritance "is a ?" iliþkisini modelleyen kalýtým türü iken private inheritance ve protected
inheritance "has a ?" iliþkisini modelleyen kalýtým türü.
C++'da kalýtým ile elde edilen sýnýfa Derived class, kalýtým ile kendisinden interface devralýnan sýnýfa ise Base
Class denir.

Kalýtým bir sýnýf ile sýnýrlý kalmak zorunda deðil örnek olarak Car sýnýfýndan Mercedes sýnýfýný, Mercedes sýnýfýndan
Mercedes Coupe sýnýfý, Mercedes Coupe sýnýfýndan da baþka bir sýnýf türetilebilir. Çoðunlukla kullanýlan kütüphaneler 
de kalýtýma yönelik olanlar da böyle bir hiyerarþi içerisinde olurlar. Burada kullanýlan terim de sýnýf veya kalýtým
hiyerarþisi. Kalýtým bir hiyerarþi dahilinde söz konsusu. 
Diðer dillerde olmayan C++'da olan bir diðer araç ise Multiple Inheritance. Multiple Inheritance, tek bir kalýtým
iþlemi ile ayný zamanda birden fazla sýnýfýn public interface'ini devralarak yeni bir sýnýfý oluþturmak üzere.

Hangi programlama dili kullanýlýyor olursa olsun, Super Classýn operasyonlarý(C++'daki karþýlýðý member functionlar)
tipik olarak 3 kategoriye ayrýlýyor, interface veren ayný zamanda implementasyonda veren, interface veren ama 
default implementasyon veren, sadece interface veren.
Ýkinci kategoride override edip etmemek, derived class'ýn elinde.,
Eðer bir sýnýfýn ikinci kategoride en az bir sýnýfý varsa böyle sýnýflara polimorfik class denir.(çok biçimli sýnýflar)
Üçüncü kategoride derived classlara implementasyon zorunlu tutulur, interfaceleri verilen operasyonlar override
edilmek zorunda. Eðer bir sýnýf bu kategoride en az bir fonksiyona sahipse veya bu kategorideki en az bir fonksiyona
sahip bir sýnýftan kalýtým yolu ile elde edilmiþ ise fakat fonksiyonlarý override etmemiþse böyle sýnýflara popüler
olarak soyut sýnýflar(abstract class) denir.
C++'da ve diðer dillerde tipik olarak bir sýnýf ya soyuttur ya da somuttur(concrete).
Concrete sýnýflar türünden nesneler oluþturulabilir, yani o sýnýf türünden instantlar oluþturulabilir.
Ancak soyut sýnýflar türünden nesneler oluþturmak dilin kurallarýnca geçersiz kabul edilir.

Kalýtýma kadar sýnýflarýn eriþim kontrolleri ile ilgili public ve private bölümler konuþuldu, protected bölümün
ancak kalýtým ile önem kazanaðýndan bahsedildi. Base sýnýfýndan Der isimli sýnýf kalýtým yolu ile elde edildiðinde,
Der sýnýfý Base'in private bölümüne eriþemez ancak Base'in clientlarýndan farklý olarak Der sýnýfý Base'in protected
bölümüne eriþebilecek. Yani sýnýflarýn protected bölümleri kendi clientlarýna kapalý ama o sýnýflardan kalýtým yolu
ile elde edilecek sýnýflara açýlmýþ bölüm. Bir sýnýfýn protected interface'inin muhattabý o sýnýftan kalýtým yolu ile 
elde edilecek sýnýflar. Bir sýnýfýn protected bölümü varsa, o sýnýfýn kalýtým amaçlý kullanýlacaðý vurgusu da verilmiþ 
olur yoksa protected bölümünün olmasýnýn bir anlamý yok.
Her sýnýf kalýtým yolu ile kullaným için tasarlanmaz, kalýtým yolu ile kullaýným için tasarlanan sýnýflar C++'da belirli
niteliklere sahip olmak zorunda. Protected bölümü olmak zorunda deðil ancak eðer varsa bu açýk açýk kalýtým yolu ile 
kullanýlabileceðinin göstergesi.


C++'da kalýtýmda Super Class olarak kullanýlacak sýnýfýn kesinlikle complete type olmasý gerekiyor. Yani incomplete type'dan
türetme yapýlamaz. Sýnýflarýn definitionlarý tipik olarak baþlýk dosyalarýnda, örneðin Mercedes sýnýfýnýn definitionu 
Mercedes.h gibi bir baþlýk dosyasýnda. Bu durumda kalýtým yolu ile elde edildiðine göre Super Class'ýn da complete
olmasý gerektiðine göre bu durumda bir baþlýk dosyasý baþka bir baþlýk dosyasýný include edecek. Yani Mercedes.h, Car.h'yý
include edecek.
/////////////////////////////////////////////////////////////////////
class Base;

class Der : public Base { //Geçersiz, Inccomplete typelardan türetme yapýlamaz.

};
/////////////////////////////////////////////////////////////////////


Sentaks aslýnda oldukça basit, normal bir sýnýf tanýmlanýyormuþ gibi class anahtar sözcüðü kullanýlýr sonrasýnda ise
sýnýfa verilen isim yazýlýr. Ardýndan iki nokta üstüste atomu kullanýlýr, bu atomdan sonra türetme belirteci denilen
public, private veya protected sözcüklerinden biri kullanýlýr. Hangi keyword kullanýlýrsa o keyworde dair kalýtým
yapýlmýþ olur. Burada herhangi bir keyword kullanýlmadýðý zaman defaultu private.
Çoðu zaman istenilen public türetme olduðundan burada public anahtar sözcüðü kullanýlmak zorunda.
Bunun da bir istisnasý var, C'deki structlar C++'da class. struct anahtar sözcüðü kullanýlýp classlarýn tüm
sentaksýndan faydalanýlabilir. Struct anahtar sözcüðü kullanmanýn sonuçlarýndan biri, classlarýn default eriþim
bölgesi private iken, structlarýn default eriþim bölgesi public. Ýkinci farklýlýk ise kalýtýmda, struct anahtar
sözcüðü ile sýnýf oluþturulup, kalýtým yapýldýðýnda bu durumda public anahtar sözcüðü kullanýlmasa da default 
kalýtým modeli public. 

/////////////////////////////////////////////////////////////////////
class Base {
public:
	void func(int);
	void foo(int, int);
};

class Der : public Base {

};
/////////////////////////////////////////////////////////////////////
Burada Der sýnýfý, Base sýnýfýndan public türetmesi ile elde edilmiþtir. Bu iþte "is a ?" iliþkisi.
Burada her Base kullanýlan her yerde Der de kullanýlabilir.

Public kalýtýmda taban sýnýfýn public interface'i doðrudan türetilen sýnýfýn public interface'ine katýlýr.
Türetme yolu ile elde edilen sýnýfýn clientleri, taban sýnýftan alýnan interface'i türetilen sýnýfýn interface'i
gibi doðrudan nokta ve ok operatörü ile kullanabilirler.


/////////////////////////////////////////////////////////////////////
class Base {
public:
	void func() {};
	void foo() {};
};

struct Der : Base {

};

int main()
{
	Der myder;
	myder.foo();
	myder.func();

}
/////////////////////////////////////////////////////////////////////
class anahtar sözcüðü yerine struct anahtar sözcüðü kullanýldýðýnda, türetme belirteci sözcüklerinden herhangi biri
kullanýlmamasýna raðmen kalýtým public kalýtým oldu.

Türemiþ sýnýf türünden bir nesne oluþturulduðunda o nesnenin içinde fiziksel olarak bir taban sýnýf alt nesnesi var 
ve bir türemiþ sýnýf nesnesinin construct olmasý demek onun içindeki taban sýnýf nesnesinin de construct olmasý demek.


Kalýtým daha önce öðrenmiþ olduðumuz isim arama kurallarýný kesinlikle deðiþtiriyor, isim arama kurallarý kalýtým aracý
ile farklý anlam kazanmakta. Class scope düþünüldüðünde, bir isim, nokta operatörü ve ok operatörünün saðýnda kullanýlmýþsa
ve çözünürlük operatörünün saðýnda kullanýlmýþsa bu isim bir class scope içinde aranýr.
Eðer bir sýnýf içinde isim bulunamazsa normalde sentaks hatasý ancak kalýtýmda eðer bir sýnýf içinde isim bulunmazsa 
derleyici isim aramayý þöyle devam ettirir: bu sefer sýnýfýn taban sýnýflarýna bakar, isimi taban sýnýflar içinde arar.

 	
Örnek olarak A, B, C, D sýnýflarý olsun. Türetme hiyerarþisi açýsýndandan da ayný sýra gözetilsin yani, B sýnýfý A'dan, C 
sýnýfý B'den, D sýnýfý da A'dan türetilmiþ olsun. Bu durumda A sýnýfý D sýnýfýnýn base classýdýr, B sýnýfý da D sýnýfýnýn
base classýdýr. Ancak C ve D düþünüldüðünde, C ve D arasýnda þöyle bir farklýlýk var, bu hiyerarþiye göre D sýnýfý doðrudan C 
sýnýfýndan türetilmiþtir burada C sýnýfý için D'nin direct base classý veya immediate base class terimi kullanýlýr. 
A ve B sýnýflarý da D'nin base classlarý ancak onlar indirect base class.(D için düþünüldüðünde, A ve B dolaylý taban sýnýf
iken, C doðrudan taban sýnýf)

Yine yukarýdaki hiyerarþi düþünüldüðünde, nokta, ok veya çözünürlük operatörünün sol tarafýndaki tür D türünden olsun.
myd, D sýnýfý türünden bir nesne olduðunda, myd.x ifadesi için x ismi önce D sýnýfýnda aranýr ve bulunursa isim arama biter.
Unutulmamalý ki C++'da isim arama bir kez yapýlýr, aranan isim bulunduðunda isim arama sonra erer, sentaks kontrolü isim
bulunduktan sonra yapýlýr. Eðer x ismi D'de bulunamazsa sýrasý ile önce C'de orada da bulunamazsa B'de yine bulunamazsa da 
A sýnýfýnda aranýr orada da bulunamazsa error olur.

Türemiþ sýnýf nesneleri ile taban sýnýftaki nesneler kullanýlabilir. Ýsmin aranýp bulunmasý ile o ismin kullanýmýnýn doðru veya
yanlýþ olmasý farklý durumlar. Mesela x ismi B sýnýfýnýn private bölümünde bu durumda x ismi bulunur ancak x'e eriþim geçersiz.

Bu contextde isimler arasýnda bir maskeleme iliþkisi de mevcut örnek olarak A'daki bir isim B'deki bir isim ile çakýþýrsa ve bu
isim B'ye baðlý olarak kullanýlýrsa A'daki isim maskelenmiþ olur. Türemiþ sýnýf ve taban sýnýfta ayný isimler kullanýlýrsa eðer bu
isim türemiþ sýnýfa baðlý olarak aratýlýyorsa, önce türemiþ sýnýfa bakýlacaðýndan taban sýnýf görülmeyecek.
Taban sýnýfýn ayný isimli fonksiyonu ile türemiþ sýnýfýn ayný isimli fonksiyonu birbirini overload etmez çünkü scope'larý ayný deðil.

/////////////////////////////////////////////////////////////////////
class Base {
public:
	void func(int);
};

class Der : public Base{
	void func();
};
/////////////////////////////////////////////////////////////////////

int main()
{
	Der myder;

	myder.func(23); //sentaks hatasý
	myder.func(); //geçerli, türemiþ sýnýfýn fonksiyonu çaðýrýlýr.
	//myder.Der::func(); //çaðrý bu þekilde de yapýlabilirdi ama burada buna gerek yok.

	myder.Base::func(10); //isim taban sýnýfýn scopeunda aranýr.
}
/////////////////////////////////////////////////////////////////////
Öncelikle function overloading yok.
Sentaks hatasý olmasýnýn sebebi ise, func bir isim, func ismi türemiþ sýnýf içinde aranýr, isim bulunur artýk isim arama biter.
Derleyici bu noktada Base'in func ismine bakmaz bile. Türemiþ sýnýfýn func fonksiyonunun parametresi yok ancak fonksiyon argüan
ile çaðýrýlýyor, sentaks hatasýnýn sebebi bu.
Base'in func fonksiyonunu çaðýrmak mümkün, bu durumda derleyiciye isim aramayý çözünürlük operatörü kullanarak yaptýrmak gerekir.



/////////////////////////////////////////////////////////////////////
class Base {
public:
	void func(int);
};

class Der : public Base{
	void func(int);
public:

};
/////////////////////////////////////////////////////////////////////

int main()
{
	Der myder;

	myder.func(23);
}
/////////////////////////////////////////////////////////////////////
Derleyici myder.func(23) ifadesinde func ismini arar, ismi türemiþ sýnýf içerisinde bulur ve isim arama sonlanýr.
Ýsim bulundaktan sonra yapýlan eriþim kontrolü sonucunda ise, func fonksiyonu Der sýnýfýnýn private bölümünde 
olduðundan ona eriþim sentaks hatasý. Eriþim kontrolü isim arama yapýldýktan sonra yapýlýr.


Taban ve türemiþ sýnýflarda ayný isimli fonksiyon olmasý function overloading deðil maskeleme. Ancak gerçekten de 
function overloading mekanizmasý çalýþtýrýlmak isteniyorsa bu etkiyi yapacak bir kod yazmak mümkün ancak doðrudan
ayný iki isim ve farklý imzalara sahip fonksiyonlarýn taban ve türetilmiþ sýnýflarda olmasý function overloadinge 
yol açmaz. Doðrudan bir function overloading yok ancak kod yazarak dolaylý bir function overloading oluþturulabilir.


Üye fonksiyonun içinde isim arama ise þu þekilde yapýlýr: Türemiþ sýnýfýn bir üye fonksiyonunun içinde x isminde bir 
deðiþlken kullanýlýyor. Derleyici bu ismi þöyle arar, isim önce blokta aranýr, bulunursa isim arama biter. Aranan 
isim blokta bulunamazsa kapsayan bloklarda ismin kullanýldýðý yere kadar aranýr. Orada da bulunamazsa türemiþ Der 
sýnýfýnýn class scope'unda aranýr eðer burada da bulunamazsa yine benzer þekilde Base sýnýflarda aranmaya devam eder.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	void foo();
};

class Der : public Base{
	//void foo(); // eðer Base'in de foo isimli fonksiyonu olursa, çaðrýlan bu olur.
	void func(double)
	{
		x = 20;
		foo();
	}
public:

};
/////////////////////////////////////////////////////////////////////
func iþlevi içinde, foo fonksiyonunun çaðýrýlmasý geçerli. foo ismi sýrasýyla blok, kapsayan bloklar ve Der sýnýfýnýn
scope'u içinde aranýr ve bulunamaz. Ardýndan Base içinde aranýr ve bulunur. Eðer ki Der sýnýfýnýn da foo isminde bir 
fonksiyonu olsaydý bu durumda Der sýnýfýnýn func fonksiyonu çaðrýlýrdý çünkü isim arama kurallarý gereði ilk o görüleceðinden
çaðrýlan da o olur. Bu durumda taban sýnýfýn foo ismi türemiþ sýnýf için gizlenmiþ olurdu. Ancak bu durumda taban sýnýfýn
foo fonksiyonu da çaðýrýlabilir, bu çaðrýyý gerçekleþtirmek için çözünürlük operatörü kullanýlýr.
Base::foo(); ifadesi ile derleyicinin foo ismini Base'in scope'u içinde aramasý saðlanýr.

/////////////////////////////////////////////////////////////////////
void SpeedFighter::kill()
{
	/////
	shoot();
}
/////////////////////////////////////////////////////////////////////
Bu kodu geçerli kýlacak birçok farklý durum olabilir: shoot yerel bir isim olabilir, konulan yorum satýrýndan önce belki
tanýmlanmýþ bir lambda olabilir o lambda ile çaðrý yapýlmýþ olabilir. SpeedFighter sýnýfýnýn bir member function'ý olabilir.
Belki de SpeedFighter kalýtým hiyerarþisi içindeki sýnýflardan biri, SpeedFighter'ýn immediate base class'ý olan bir sýnýfýn
üye fonksiyonu olabilir veya hiyerarþideki en tepedeki taban sýnýfýn üye fonksiyonu olabilir. Belki de global bir fonksiyon
olabilir. Birçok programcý global fonksiyonlara çaðrý yaptýðýnda unary çözünürlük operatörünü kullanýr, yani eðer shoot global
bir fonksiyon ise ::shoot(); ifadesi yazýlabilir. Eðer statik bir fonksiyon ise fonksiyonu sýnýfýn ismi ile nitelemek de 
kullanýlan konvensiyonlardan biri. Ancak dilin sentaksýna göre tüm bu durumlar geçerli olabilir.


Fiziksel olarak kalýtýmda bir sýnýfýn içinde baþka bir sýnýf türünden nesne var. 
/////////////////////////////////////////////////////////////////////
class Base {
	int mx, my, mz, mt;
public:

};

class Der : public Base{
public:

};

int main()
{
	cout << "sizeof(Base) = " << sizeof(Base) << endl;
	cout << "sizeof(Der) = " << sizeof(Der) << endl;
}
/////////////////////////////////////////////////////////////////////
Base sýnýfýnýn sizeof deðeri 16 byte. Ayný zamanda Der sýnýfýnýn da sizeof deðeri 16 byte çünkü Der sýnýfý
Base'i içeriyor. Der sýnýfýnýn int türden bir veri elemaný olsaydý bu durumda Der sýnýfýnýn sizeof deðeri
20 byte olurdu. 

Aslýnda composition olsaydý bu durum deðiþmeyecekti. B sýnýfýnýn A sýnýfý türünden bir öðesi olabilir yani
composition söz konusudur. B sýnýfý A sýnýfýndan kalýtým yolu ile elde edilmiþtir. Bu her iki durumda da 
B'nin içinde bir A olmuþ olur ancak terminoloji farklý. Composition olmasý durumunda yani B'nin A sýnýfý türünden
bir öðesi varsa popüler olarak B'nin içindeki A'ya popüler olarak embedded object denir. Ancak kalýtýmda B'nin
içindeki A'ya base class object denir. Ýkisi arasýnda fiziksel bir fark yok ancak kalýtýmda A'nýn interface'i 
B sýnýfýna eklenir compositionda ise A'nýn interfaceinin B'ye eklenmesi gibi bir durum yok. 
Ancak bazý ortak durumlarda mevcut örnek olarak bir B nesnesi hayata geldiðinde önce onun içindeki A hayata gelir.
B'nin her constructor'ý A'nýn her ctor'una çaðrý yapmak zorunda. Fiziksel olarak ayný ama temsil ettikleri
interfaceler farklý.
Kalýtým mý compoisiton mi kararý verilemiyor ise composition tercih edilebilir. Composition çoðu zaman kalýtýma 
tercih edilir, mecbur kalýndýðýnda kalýtým uygulanýr.

C++'da dilin kurallarý public kalýtýmý söz konusu olduðunda "is a ? " iliþkisini sonuna kadar destekler, yani her
Mercedes bir arabadýr soyutlamasý sonuna kadar dilin sentaksý tarafýndan desteklenir. Dönüþüm yaparak bu destek
dil tarafýndan saðlanýr. Eðer B, A'dan kalýtým yoluyla elde edilmiþse dilin kurallarý A'ya B'nin atanmasýna;
A pointerýnýn B nesnesini göstermesine, A referansýnýn B nesnesinin isminin yerine geçmesine herhangi bir engel 
koymaz. Ancak bunlar kalýtým iliþkisi dýþýndaki sýnýflar olsaydý bu tür dönüþümler dilin sentaks engeline taklýlýrdý.

C++'da public inheritance söz konusu olduðunda derived class türü, ayný zamanda base class türündenmiþ gibi ele
alýnýr ve tür dönüþtürme operatörü kullanmadan derived class'dan base class'a doðru otomatik tür dönüþümü
gerçekleþtirilir. Türemiþ sýnýftan, taban sýnýfa doðru yapýlan dönüþümlere popüler olarak upcasting denir.
(yukarý doðru dönüþüm) Mesela Mercedes'ten Car sýnýfýna doðru yapýlan dönüþüm. Madem her Der nesnesi bir Base,
o zaman Base gereken yerde Der kullanýlabilir yani Base'e, Der atanabilir. 
Her B'nin bir A olmasý; her A'nýn da bir B olduðu anlamýna gelmez yani Mercedes gereken yerde her araba 
kullanýlamaz. Dilin kurallarý bu konuda belirleyici, herhangi bir tür dönüþümü yapmadan asla A'dan B'ye
atama, aktarým veya kopyalama yapýlamaz. Bir nedenden dolayý A'dan B'ye dönüþüm yapýlmak isteniyorsa buna 
popüler olarak downcasting(aþaðý doðru dönüþüm) denir. Taban sýnýftan türemiþ sýnýfa doðru yapýlan dönüþümler.

Taban sýnýfýn private bölümü her durumda diðer sýnýflara kapalý. Yani bir B sýnýfý A sýnýfýndan hangi yol ile
türetilirse türetilsin B sýnýfýnýn A sýnýfýnýn private bölümüne eriþmesi mümkün deðil. Ancak protected ve
public bölümlerine eriþebilir. Public kalýtýmýnda taban sýnýfýn public interface'i bizim public interfacemize
eklenir, taban sýnýfýn private bölümü tamamen kapalý, taban sýnýfýn protected bölümü ise eriþimimize açýk.
Eðer bizim sýnýfýmýzdan tekrar bir türetme yapýlýrsa örneðin B'den de C sýnýfý türetildiðinde dolayýsýyla B 
sýnýfýnýn public bölümü de C sýnýfýna açýk olduðu için C sýnýfý B'nin ve A'nýn public bölümüne eriþebilir.
Taban sýnýfýn protected bölümü ise bizim protected bölümümüz gibi ele alýnacaðýndan yine B'den yeni bir 
sýnýf türetildiðinde o sýnýf hem bizim protected bölümümüze hem de bizim sýnýfýmýzýn taban sýnýfýnýn
protected bölümünden kendi sýnýfýmýzýn protected bölümüne aktardýðýmýz öðelere eriþebilir. Private bölüm her
zaman kapalý.


Türemiþ sýnýf açýsýndan bakýldýðýnda taban sýnýfýn protected bölümü, türemiþ sýnýfýn protected bölümü olur.
Türemiþ sýnýfýn protected bölümü ise clientlarýna kapalý. Yani myder nesnesi ile, Der'in clientlarý ancak
Der sýnýfýnýn public bölümüne eriþebilir. Der'in public bölümü de, kendi public bölümünü ve kendisinden 
türediði taban sýnýfýn public bölümünü içerir. Bu yüzden myder.pub_func(); çaðrýsý geçerli bir çaðrý.

/////////////////////////////////////////////////////////////////////
class Base {
private:
	void pri_func() {}
protected: 
	void pro_func() {}
public:
	void pub_func() {}
};

class Der : public Base {
public:

};


int main()
{
	Der myder;

	myder.pub_func();
	myder.pro_func(); // geçersiz
	myder.pri_func(); // geçersiz
}
/////////////////////////////////////////////////////////////////////

Durum türemiþ Der sýnýfýnýn kendi implementasyonunda deðiþir.
/////////////////////////////////////////////////////////////////////
class Base {
private:
	void pri_func() {}
protected: 
	void pro_func() {}
public:
	void pub_func() {}
};

class Der : public Base {
public:
	void derfoo()
	{
		pri_func(); // geçersiz
		pro_func(); // geçerli
		pub_func();
	}

};
/////////////////////////////////////////////////////////////////////
Der sýnýfý içinde, taban sýnýfýn private fonksiyonunun çaðýrýlmasý geçersiz, access engeline takýlýr.
Ancak Der sýnýfý içinde pro_func() fonksiyonu çaðýrýlabilir, taban sýnýfýn protected bölümü türemiþ sýnýflarýn
implementasyonlarýna açýk.
Taban sýnýfýn public bölümüne zaten eriþilebiliyor.
Gerek kalýtým yoluyla elde edilmiþ sýnýf için gerekse de clientlar için her zaman taban sýnýfýn private bölümü
kalýtýmýn biçimi de ne olursa olsun eriþime kapalý.


Der ve Base sýnýfý aralarýnda hiçbir iliþki olmayan iki sýnýf olsun.
Ýster kopyalama, ister atama veya taþýma yolu ile mybase'e özel bir fonksiyon yoksa yani bir user defined
conversion function yoksa mybase = myder ifadesi sentaks hatasý.
/////////////////////////////////////////////////////////////////////
class Base {
public:

};

class Der {
public:

};


int main()
{
	Base mybase;
	Der myder;

	mybase = myder; //sentaks hatasý
}
/////////////////////////////////////////////////////////////////////


Burada ise Der sýnýfý, türetme yolu ile Base sýnýfýndan türetildi.
Bu durumda mybase = myder atamasý geçerli.
Sadece bu deðil bunun yanýnda pointer veya referans yolu ile yapýlan atamalar da geçerli.
Burada tür dönüþtürme operatörü de kullanýlabilir ancak zaten bu konsept geçerli ve doðru olduðundan operatör
kullanýmýna gerek yok.
Aþaðýdan yukarýya dönüþüm(upcasting): Türemiþ sýnýf nesnesi madem ayný zamanda taban sýnýf nesnesi olarak
görülüyor o zaman bir türemiþ sýnýf nesnesi taban sýnýf pointerýna adres yoluyla, referans yoluyla veya nesne
yoluyla aktarýlabilir. 
Her ne kadar nesnelerin birbirine atanmasý geçerli olsa da, bu bizim her zaman tercih ettiðimiz bir durum deðil.
Yani C++'da mybase = myder þeklinde bir atama pek görülmez. Atamalar daha çok pointer ve referans yolu ile yapýlýr.
mybase = myder þeklinde yapýlan atamalar için object slicing terimi kullanýlýr.(nesne dilimlenmesi)
Türemiþ sýnýftan taban sýnýfa doðru dönüþüm upcasting, legal, otomatik böyle bir dönüþüm var ancak down casting;
kesinlikle tür dönüþtürme operatörü olmadan legal deðil ki tür dönüþtürme operatörü olduðunda da her zaman doðru
deðil, olabilir de olmayabilir de.
/////////////////////////////////////////////////////////////////////
class Base {
public:

};

class Der : public Base {
public:

};


int main()
{
	Base mybase;
	Der myder;

	mybase = myder; //geçerli, upcasting

	Base *baseptr = &myder; //geçerli, upcasting

	Base &baseref = myder; //geçerli, upcasting

	/************************************************/
	
	Base mybs;
	Der mydr;

	mdyr = mybs;  //geçersiz, downcasting

	Der *drptr = &mybs; //geçersiz, downcasting

	Der &drref = mybs; //geçersiz, downcasting
}
/////////////////////////////////////////////////////////////////////


Türemiþ sýnýf nesnesi ile Taban sýnýfýn fonksiyonu çaðýrýlabilir, peki derleyici bunun için nasýl bir kod üretir?
Base ve Der sýnýflarý düþünüldüðünde, her Der sýnýfýnýn içinde bir Base sýnýf nesnesi var. 
Base sýnýfýnýn setbase isimli fonksiyonunun bir this pointeri var, setbase non-statik bir üye fonksiyon yani bir
Base nesnesinin adresi ile çaðýrýlýr. Bu fonksiyona çaðrý yapan kod aslýnda bu fonksiyonunun görünmeyen this
parametresine üstünde iþlem yapýlacak Base nesnesinin adresini geçer. 
Main içinde ise Der sýnýfý türünden myder isimli nesne için setbase fonksiyonu çaðýrýldý. setbase için bir
this adresi gerekir. Derleyici bu durumda, setbase fonksiyonunun this parametresine myder nesnesinin içindeki
Base nesnesinin adresini gönderir this adresi olarak.
Yani bir türemiþ sýnýf nesnesi ile, taban sýnýfýn bir üye fonksiyonuna çaðrý yapýldýðýnda myder.setbase()
dendiðinde this pointer olarak myder'in adresi kullanýlmaz, myder'in içindeki Base'in adresi kullanýlýr.
Aslýnda derleyici türemiþ sýnýf nesnesinin içindeki taban sýnýf alt nesnesini kullanýr. 
C++'nýn standartlarý taban sýnýf alt nesnesinin, sayýsal olarak türemiþ sýnýf nesnesinin hemen baþlangýç kýsmýnda
olmasý konusunda bir garanti içermez. 
Taban sýnýfýn bir üye fonksiyonu her zaman bir taban sýnýf nesnesi adresi ile çaðýrýlýr, bir this pointeri ile.
Ancak türemiþ sýnýf nesnesi ile fonksiyona çaðrý yapýldýðýnda derleyici isim arama kurallarý ile taban sýnýfýn
ilgili fonksiyonunu çaðýrmasý gerektiðini anlar ama this adresi olarak türemiþ sýnýf türünden nesnenin kendi
adresini deðil, türemiþ sýnýf nesnesi içindeki taban objesinin adresini kullanýr.
/////////////////////////////////////////////////////////////////////
class Base {
	int mx, my;
public:
	void setbase(int x, int y)
	{
		mx = x;
		my = y;
	}
};

class Der : public Base {
	double ma;
public:
	void func()
	{
		setbase(20, 50);
	}
};

int main()
{
	Der myder;
	
	myder.setbase(10, 20);	

}
/////////////////////////////////////////////////////////////////////
Der sýnýfýnýn non-statik func isminde bir üye fonksiyonu olduðunda ve fonksiyonun içinde setBase fonksiyonu
çaðýrýlmýþ olsaydý bu durumda func'ýn da bir this pointeri var. Bu this pointerinin gösterdiði Der nesnesinin
içindeki Base nesnesinin adresi ile setBase fonksiyonu çaðýrýlýr.

baseptr = derptr; bu atama ne þekilde yapýlýrsa yapýlsýn aslýnda baseptr'ye atanan fiziksel olarak derptr nesnesinin
adresi deðil, fiziksel olarak derleyicinin ürettiði kod: derptr'nin içindeki base nesnesinin adresini atamak. 
Derleyici bunu compile time'da yapar. 

Mesela buradaki Base yerine Car sýnýfý olsun, taban sýnýf olarak. Car, bir araba yarýþý programýndaki en tepedeki
taban sýnýf olsun. Eðer elimizde global bir :
void carGame(Car *ptr); gibi bir fonksiyon varsa, bu fonksiyon Car sýnýfý hiyerarþisi içindeki herhangi bir 
nesne adresi ile çaðýrýlabilir. Bu kod yazýldýðýnda belki Dacia diye bir sýnýf yoktu, carGame fonksiyonu ve Car
sýnýfýnýn fonksiyonlarý daha önce yazýlmýþtý sonradan ise bir kalýtým daha yapýldý ve Car sýnýfýndan Dacia
sýnýfý türetildi, daha önceden yazýlmýþ bu fonksiyona artýk bir Dacia nesnesinin adresi de gönderilebilir.
Fonksiyonun içinde pointerda Car sýnýfýna ait olmayan bir isim kullanýlamaz. Ok operatörü ve nokta operatörü ile
bir isim kullanýldýðýnda isim her zaman o pointerin ait olduðu sýnýfýn interface'inde aranýr.
Bu fonksiyon Car sýnýfýndan doðrudan veya dolaylý yoldan türetilmiþ bütün sýnýf nesnelerinin adresleri ile 
çaðýrýlabilir. Pointer semantiði yerine referans semantiði de kullanýlabilir:
void carGame(Car &ref);

C++'da, Java ve C#'dan farklý olarak, monolitic hiyerarþi yok yani ortak bir base sýnýf yok(object sýnýfý gibi).
C++'da Garbage collector yok.
C++'da nesneler dinamik olmak zorunda deðil. Nesneleri global, statik yerel, otomatik yerel ve dinamik olabilir.
Diðer dillerde tüm sýnýflar polimorfik, dilin tasarýmý öyle. C++'da sýnýflarýn polimorfik olma koþulu yok.
 	
Kalýtýmda Özel Ýþlevlerin Ýncelenmesi:
Kalýtým da olsa composition da olsa, bir sýnýf nesnesinin içinde baþka bir sýnýf nesnesi var.
A taban sýnýf, B ise türetilmiþ sýnýf olmak üzere; Öncelikle A sýnýfý hayata gelir, B nesnesinin hayata gelmesi
için önce A'nýn hayata gelmiþ olmasý gerekir. Kodun B'nin ctor'unun ana bloðunun içine girmesi için, zaten A'nýn
hayata gelmiþ olmasý gerekir. A hayata gelmeden programýn akýþý B'nin ctor'unun içine gitmez. 
Önce taban sýnýf alt nesnesi hayata gelir ondan sonra türemiþ sýnýf nesnesinin ctor'unun ana bloðuna girilir.
Taban sýnýf alt nesnesinin hayata gelmesi daha önce. Composition'da da benzer bir durum vardý, önce eleman
hayata geliyordu, elemanlar hayata geldikten sonra nesnemiz hayata geliyordu. Hatta ikisi beraber olduðunda
önce taban sýnýf alt nesnesi hayata gelir, ondan sonra memberlar hayata gelmeye baþlar, tüm bunlar dilin garantisi
altýnda. Eðer A taban sýnýf alt nesnesinin nasýl construct edileceði ile ilgili bir talimat verilmezse, derleyici
bu nesneyi her zaman default construct etmeye çalýþýr, iþ derleyiciye býrakýlýrsa derleyici her zaman taban sýnýf
alt nesnesini default construct etmeye çalýþýr. Ancak taban sýnýfýn	bir default consturctor'ý yoksa veya default
ctor'u varsa ancak bizim tercihimiz deðilse yani B'nin içindeki A'nýn sýnýfýn parametreli baþka bir constructor'ý
tarafýndan hayata getirilmesi isteniyorsa, MIL sentaksý ile türemiþ sýnýfýn ctor'una bunu gerçekleyecek bir kod
yazýlýr. Aksi halde programcý istese de istemese de, iþ derleyiciye býrakýldýðýnda derleyici her zaman taban 
sýnýfýn default constrcutor'ýný çaðýrýr.


/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}

};

class Der : public Base {
public:
};

int main()
{
	Der myder;
}
/////////////////////////////////////////////////////////////////////
Base taban sýnýfýndan türemiþ Der sýnýfý türünden bir nesne için Base sýnýfýnýn default constructor'ý çaðrýldý.
Derleyici Der sýnýfý için bir default constructor yazdý, derleyicinin yazmýþ olduðu bu default ctor'da Base'in
default constructor'ýný çaðýrdý.


/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}

};

class Der : public Base {
public:
	Der() {
		std::cout << "Der::Der()\n";
	}
};

int main()
{
	Der myder;
}
/////////////////////////////////////////////////////////////////////
Der sýnýfýna kendimiz bir constructor yazdýðýmýzda, myder nesnesi hayata gelirken programýn akýþý henüz Der 
sýnýfýnýn constructor'ýnýn ana bloðunun içine girmeden, Der'in içindeki Base nesnesinin default constructor'ýna
çaðrý yapar. Önce Base'in ctor'u çalýþýr ondan sonra Der'in ctor'unun ana bloðu içine girilir.
Eðer bu fiilen programý yazan tarafýndan yapýlmak istense o zaman Der sýnýfýnýn constructor'ý için þöyle bir
deðiþiklik yapýlýr:
Der() : Base() {
	std::cout << "Der::Der()\n";
}
Burada da : Base() yazmak yerine C++11 ile beraber burada da uniform initializer kullanýlabilir.



Örnekte derleyici, Der sýnýfýna default constrcutor yazar. Der sýnýfýna yazmýþ olduðu constrcutorda Base sýnýfýnýn
default ctoruna çaðrý yapar ancak Base sýnýfýnýn default constructoru olmadýðýndan çaðrý geçersiz olur.
Bu durumda eðer kendimiz bir kod yazmazsak Der sýnýfý türünden bir nesne oluþturma imkanýmýz yok çünkü bunu
default construct etme i mkanýmýz yok.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base(int) {
		std::cout << "Base::Base(int)\n";
	}

};

class Der : public Base {
public:
};

int main()
{
	Der myder; //geçersiz
}
///////////////////////////////////////////////////////////////////// 

Önceki örnekte olduðu gibi Der sýnýfýna bir constructor yazýp, MIL sentaksý ile Base sýnýfýnýn parametreli 
constructorýna çaðrý yaparak çözüm getirilebilir. Bu durumda, Der sýnýfý þekildeki gibi olur.
Burada 10 deðeri, sadece fonksiyona geçilen bir argüman.
///////////////////////////////////////////////////////////////////// 
class Base {
public:
	Base(int) {
		std::cout << "Base::Base(int)\n";
		std::cout "x = " << x << std::endl;
	}

};
class Der : public Base {
public:
	Der() : Base{ 10 }
	{
		std::cout << "Der::Der()\n";
	}
};
int main()
{
	Der myder; //geçersiz
}
///////////////////////////////////////////////////////////////////// 


Taban sýnýfýn birden fazla constructor'ý da olabilir. Taban sýnýftan türeyen farklý türemiþ sýnýflarýn
constuctorlarý içinde bu base sýnýf ctorlarýndan biri konsepte göre kullanýlýr.
Programcý müdahale etmezse taban sýnýfýn default constructor'ý çaðýrýlýr. Default constructor yok veya 
delete edilmiþse bu durumda sentaks hatasý.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}
	Base(int x) {
		std::cout << "Base::Base(int)\n";
		std::cout << "x = " << x << std::endl;
	}
	Base(double x) {
		std::cout << "Base::Base(double)\n";
		std::cout << "x = " << x << std::endl;
	}
	Base(int x, int y) {
		std::cout << "Base::Base(int, int)\n";
		std::cout << "x = " << x << std::endl;
		std::cout << "y = " << y << std::endl;
	}

};

class Der1 : public Base {
public:

};
class Der2 : public Base {
public:
	Der2() : Base{ 0 }
	{

	}
};
class Der3 : public Base {
public:
	Der3() : Base{ 3, 5 }
	{

	}
};

int main()
{
	Der1 der1;
	Der2 der2;
	Der3 der3;
}
/////////////////////////////////////////////////////////////////////


Destructor söz konusu olduðunda yine Composition'daki gibi bir sýnýf nesnesinin hayata baþlamasý durumunda, nasýl
onun içindeki taban sýnýf nesnesi hayata geliyor ise bir sýnýf nesnesinin hayatý bittiðinde onun içindeki taban
sýnýf nesnesinin de hayatý biter, destroy edilir bunun için yine taban sýnýfýn derstructor'ý çaðýrýlýr.
Destructorda iþ constructorda olduðunun tam tersi. Programýn akýþý önce türemiþ sýnýfýn destructor'ýnýn içine 
girer, burada destructor'ýn bütün kodu yürütüldükten sonra derleyici oraya taban sýnýf nesnelerinin destructor
çaðrýlarýný ekler. Önce türemiþ sýnýftan gelen kýsým destroy edilir ardýndan taban sýnýf alt nesnesi destroy 
edilir. Bunun sebebi ise bir türemiþ sýnýf nesnesi, taban sýnýf alt nesnesini kullanabilir bu durumda türemiþ
sýnýf nesnesi destroy edildiðinde, türemiþ sýnýfýn destructor'ý da taban sýnýf alt nesnesini kullanýyor olabilir,
bu durumda taban sýnýf alt nesnesinin daha önce yok edilmemiþ olmasý gerekir.



/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}
	~Base() {
		std::cout << "~Base::Base()\n";
	}
};
class Der : public Base {
public:
	Der()
	{
		std::cout << "Der::Der()\n";
	}
	~Der() {
		std::cout << "~Der::Der()\n";
	}

};
int main()
{
	Der myder;
}
/////////////////////////////////////////////////////////////////////
Önce Base'in ardýndan Der'in constructor'ý çaðýrýlýr. Konu destructor olduðunda ise önce Der'in sonra Base'in
destructor'ý çaðýrýlýr. Programýn akýþý Der'in destructor'ý içine geldiðinde oradaki bütün kodlar yürütüldükten
sonra Base'in destructor'ýna çaðrý yapýlýr.


Der sýnýfý Base sýnýfýndan türetme yolu ile elde edilmiþ bir sýnýf. Der sýnýfýnýn ayný zamanda Member sýnýfý
türünden de bir memberi mevcut. Bu durumda hayata gelme sýralarý göz önüne alýndýðýnda önce Der'in Base'i 
oluþur, ondan sonra memberlar oluþur. Destruct olurken de bu sýranýn tam tersi gerçekleþir.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}
	~Base() {
		std::cout << "~Base::Base()\n";
	}
};

class Member {
public:
	Member() {
		std::cout << "Member::Member()\n";
	}
	~Member() {
		std::cout << "~Member::Member()\n";
	}
};

class Der : public Base {
	Member m;
public:
	Der() {
		std::cout << "Der::Der()\n";
	}
	~Der() {
	std::cout << "~Der::Der()\n";
	}
};

int main()
{
	Der myder;
}
/////////////////////////////////////////////////////////////////////


Yine bir A ve B sýnýfý olduðu düþünülsün, B sýnýfý A sýnýfýndan türetme yolu ile elde edilmiþ bir sýnýf olsun.
Hayata gelecek bir B nesnesi, hayata bir baþka nesnesinden deðerini alarak, kopyalama yolu ile hayata gelecek,
yani copy constructor ile hayata gelecek.
B'nin copy constructor'ý derleyiciye býrakýlýrsa derleyici B için yazdýðý copy constructor'da taban sýnýf alt
nesnelerini de copy constructor yolu ile kurar. Yani B'nin içindeki taban sýnýf alt nesnesi de, taban sýnýfýn
copy constructor'ý yoluyla hayata gelir. Derleyici bu durumda her zaman ayný patterni kullanýr.
Eðer türemiþ sýnýf nesnesinin copy constructor'ýný biz yazýyorsak artýk taban sýnýf alt nesnesinin copy
construct edilmesinden de biz sorumluyuz. Taban sýnýf nesnesini copy construct edecek member initializer list
sentaksý kullanýlmazsa, taban sýnýf alt nesnesi default construct edilir.

myder2'nin copy construct edilmesi gerekiyor. Der sýnýfý için copy constructor'ý derleyici yazar. Derleyici
copy constructor'ý yazdýðýnda taban sýnýf alt nesnesi için taban sýnýfýn Copy constructor'ýný çaðýrdý.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}
	Base(const Base &r) {
		std::cout << "Base::Base(const Base &r)\n";
	}
};

class Der : public Base {
public:

};

int main()
{
	Der myder1;
	Der myder2{ myder1 };
}
/////////////////////////////////////////////////////////////////////


Der sýnýfýnýn default constructor'ý default edildi. Der sýnýfýna yazýlan copy constructor'da ise MIL sentaksý
kullanýlmadý. Yalnýzca copy ctor'un çaðýrýldýðýna yönelik bir yazý eklendi. Artýk derleyicinin yazdýðý copy
constructordan farklý olarak bizim yazdýðýmýz copy constructorda biz Base alt nesnesi için herhangi bir iþlem
önermediðimizden derleyici sýnýfýn default constructor'ýný çaðýrdý, Base sýnýfýnýn copy constructor'ý çaðrýlmadý.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base() {
		std::cout << "Base::Base()\n";
	}
	Base(const Base &r) {
		std::cout << "Base::Base(const Base &r)\n";
	}
};

class Der : public Base {
public:
	Der() = default;
	Der(const Der &r) {
		std::cout << "Der::Der(const Base &r)\n";
	}
};

int main()
{
	Der myder1;
	Der myder2{ myder1 };
}
/////////////////////////////////////////////////////////////////////

Copy constructor'ýn çaðýrýlmasý için, copy constructor þöyle yazýlýr.
MIL sentaksýna eklenen kod ile bu yapýlýr.
Sonuçta taban sýnýfýn, copy ctorunun parametresi const Base & olduðundan, bu da türemiþ sýnýf türünden
olduðuna göre yine upcasting kurallarý burada da geçerli.
/////////////////////////////////////////////////////////////////////
class Der : public Base {
public:
	Der() = default;
	Der(const Der &r) : Base{r} {
		std::cout << "Der::Der(const Base &r)\n";
	}
};
/////////////////////////////////////////////////////////////////////


A sýnýfýndan türetme yolu ile elde edilmiþ B türemiþ sýnýfý türünden iki tane x ve y nesnesi hayata getirilmiþ 
olsun. Programcý x = y; gibi bir atama yapmýþ olabilir. Bu durumda B sýnýfýnýn atama operatör fonksiyonu(copy
assignment operator function) çalýþýr. Eðer B'nin bu atama operatör fonksiyonunu derleyici yazmýþsa, derleyici
x'in bütün öðelerine y'nin karþýlýklý bütün öðelerini, bu öðelerin ait olduklarý sýnýflarýn kopyalayan atama
operatör fonksiyonlarýna çaðrý yaparak yerleþtirir, atar.
Yine benzer þekilde türemiþ sýnýfýn atama operatör fonksiyonu programcý tarafýndan yazýlýyorsa artýk taban
sýnýf alt nesnelerinin birbirine atanmasýndan da programcý sorumlu. Eðer taban sýnýf alt nesneleri birbirine
atanmazsa, taban sýnýf alt nesnesi atanmamýþ olarak eski deðerinde kalýr.

/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base &operator=(const Base &r)
	{
		std::cout << "Base::operator=(const Base &r)\n";
		return *this;
	}
};

class Der : public Base {
public:
	
};

int main()
{
	Der myder1;
	Der myder2;

	myder1 = myder2;
}
/////////////////////////////////////////////////////////////////////
Burada Der sýnýfý için derleyicinin yazdýðý atama operatör fonksiyonu çalýþýr o da taban sýnýf alt nesnelerinin
birbirine atanmasý için taban sýnýfýn atama operatör fonksiyonuna çaðrý yapar.



/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base &operator=(const Base &r)
	{
		std::cout << "Base::operator=(const Base &r)\n";
		return *this;
	}
};

class Der : public Base {
public:
	Der &operator=(const Der &r)
	{
		std::cout << "Der::Der=(const Der &r)\n";
		return *this;
	}
};

int main()
{
	Der myder1;
	Der myder2;

	myder1 = myder2;
}
/////////////////////////////////////////////////////////////////////
Burada ise Der sýnýfýnýn atama operatör fonskyionu programcý tarafýndan yazdýldý ancak taban sýnýf alt nesneleri
için taban sýnýfýnýn atama operatör fonksiyonu çaðrýlmadý. Bu durumda taban sýnýf alt nesnelerini birbirine 
atayacak fonksiyon çaðýrýlmaz. Derleyici atama operatör fonksiyonlarýna asla kod eklemez.

Türemiþ Der sýnýfý içindeki atama operatör fonksiyonunda, taban sýnýf alt nesneleri için Base sýnýfýn atama
operatör fonksiyonunun çaðýrýlmasý için Der sýnýfý atama operatör fonksiyonu bu þekilde yazýlabilir:
Derleyici öncelikle Base::operator fonksiyonunu çaðýrýr, Base'in operatör atama fonksiyonunun parametresi
const Base &, ona Der türünden r nesnesi gönderildiðinde upcasting kurallarýna göre r'nin içindeki Base 
kullanýlmýþ olur böylece *this'in Base alt nesnesine diðer nesnenin Base alt nesnesi atanmýþ olur.
/////////////////////////////////////////////////////////////////////
class Der : public Base {
public:
	Der &operator=(const Der &r)
	{
		std::cout << "Der::Der=(const Der &r)\n";

		Base::operator=(r);
		//(static_cast<Base *>(this))->operator=(r); //böyle de yazýlabilir
	
		return *this;
	}
};
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
class Car {
public:
	virtual void start()
	{
		std::cout << "Car engine is starting..\n";
	}
	virtual void run()
	{
		std::cout << "Car is running..\n";
	}
	virtual void stop()
	{
		std::cout << "Car has just stopped..\n";
	}
};

class Mercedes : public Car {
public:
	void start()
	{
		std::cout << "Mercedes engine is starting..\n";
	}
	void run()
	{
		std::cout << "Mercedes is running..\n";
	}
	void stop()
	{
		std::cout << "Mercedes has just stopped..\n";
	}
};

class Audi : public Car {
public:
	void start()
	{
		std::cout << "Audi engine is starting..\n";
	}
	void run()
	{
		std::cout << "Audi is running..\n";
	}
	void stop()
	{
		std::cout << "Audi has just stopped..\n";
	}
};

class Opel : public Car {
public:
	void start()
	{
		std::cout << "Opel engine is starting..\n";
	}
	void run()
	{
		std::cout << "Opel is running..\n";
	}
	void stop()
	{
		std::cout << "Opel has just stopped..\n";
	}
};

void carGame(Car *ptr)
{
	ptr->start();
	ptr->run();
	ptr->stop();
}

int main()
{
	srand((unsigned)time(nullptr));

	for (;;)
	{
		switch (rand() % 3) {
		case 0: std::cout << "Mercedes\n"; carGame(new Mercedes); break;
		case 1: std::cout << "Audi\n";	   carGame(new Audi); break;
		case 2: std::cout << "Opel\n";	   carGame(new Opel); break;
		}
		getchar();
	}
}
/////////////////////////////////////////////////////////////////////
Car taban sýnýfýndan türetilmiþ olan 3 tane, Mercedes, Audi ve Opel sýnýflarý var. Tüm sýnýflarýn Car sýnýfý ile
ayný isimli fonksiyonlarý mevcut. Döngü içerisinde Mercedes, Audi veya Opel sýnýfý türünden dinamik bir nesne
yaratýlýp, bu nesne için carGame global fonksiyonu çaðýrýlýyor. Program çalýþtýðýnda görülen hep Car, taban 
sýnýfýnýn fonksiyonlarýnýn çaðýrýldýðý. Derleyici compile time'da carGame fonksiyonu içerisinde ptr'nin türünün
Car * olduðunu görür isim aramayý ona göre yapar, fonksiyonlar Car sýnýfýnýn fonksiyonu olmuþ olur.

Ancak Car sýnýfýnýn tüm fonksiyonlarý C++'nýn bir anahtar sözcüðü olan virtual sözcüðü ile nitelenirse ve 
kodda baþka bir deðiþiklik yapýlmazsa, hangi case'e girilip, carGame fonksiyonu hangi türden türemiþ sýnýf
nesnesi için çaðýrýlýrsa o türe ait fonksiyonlarýn çaðýrýldýðý görülür. Yani artýk Car sýnýfýnýn deðil, 
fonksiyon hangi türden sýnýf nesnesi ile çaðýrýlmýþsa onun fonksiyonlarý çaðýrýlýr.
Bu run time'da belli olur. Daha önce C'de hiç deneyimlemediðimiz bir durum. Derleyici compile time'da hangi
türün üretilip fonksiyona gönderileceðini bilemez. Tamamen run time'a yönelik mekanizma, run time polymorphism.
Hangi fonksiyonlarýn çaðýrýlmasý gerektiði run time'da belli olur.
Bu ayný zamanda ikinci kategoriyi gösteren konsept, Car sýnýfý default implementasyon verdi ancak türemiþ
sýnýflar ayný isimli fonksiyonlarý tanýmlamakla override etmiþ oldu, kendi kodlarýný kendileri yazmýþ oldu
/////////////////////////////////////////////////////////////////////
class Car {
public:
	virtual void start()
	{
		std::cout << "Car engine is starting..\n";
	}
	virtual void run()
	{
		std::cout << "Car is running..\n";
	}
	virtual void stop()
	{
		std::cout << "Car has just stopped..\n";
	}
}; 
/////////////////////////////////////////////////////////////////////

21_OCAK_2018_PAZAR

virtual anahtar sözcüðünü kullanmak ile kullanmamak arasýnda büyük bir fark var, aslýnda run time polymorphism
kabaca böyle.
Bir önceki örnekteki carGame fonksiyonunda çaðrý yapýlan, start, run, stop fonksiyonlarý karþýlýðýnda hangi
sýnýfýn bu 3 fonksiyonunun çaðýrýlacaðý kesinlikle run time'da anlaþýýlýyor. Programlamada çok önemli bir araç.
Koda bakýldýðýnda bir fonksiyon çaðrýsý var ancak hangi fonksiyonun çaðýrýlacaðý derleyici tarafýndan compile
time içinde fonksiyonun ismi ile bilinmiyor, run time'da bazý kodlarýn çalýþmasý ile belli oluyor.
Erken baðlama(early binding), Geç baðlama(late binding), Statik baðlama(static binding), Dinamik baðlama(dynamic
binding)
Derleyici hangi fonksiyonun çaðýrýlacaðýný compile time'da anlýyorsa ve ona göre fonksiyon çaðrýsýný o fonksiyon
ile iliþkilendiriyorsa buna erkan baðlama veya statik baðlama denir.
Ancak hangi fonksiyonun çaðýrýldýðý programýn çalýþma zamanýnda belirleniyorsa buna dinamik baðlama veya geç 
baðlama denir.
Örnekte virtual keywordu koyulmadýðý zaman çaðýrýlan hep Car sýnýfýnýn fonksiyonlarý oldu, virtual eklendiðinde
ise geç baðlama olayý gerçekleþti. Fonksiyona hangi nesnenin adresinin geldiði run time'da bir þekilde anlaþýldý
ve ona ait sýnýfýn fonksiyonu çaðýrýldý.
Nihayetinde fonksiyona tek bir pointer, bir nesnenin adresi gönderiliyor.
Birinci kategori hem interface veren hem de implementasyon verendi, ikinci kategori ise interface ve default
implementasyon verendi. C++'da ikinci kategorinin sentaksý böyle.
Taban sýnýf içinde bir fonksiyonun bildiriminde, bildirimin baþýnda virtual anahtar sözcüðü olursa bu bizim
için ikinci kategori demek. Virtual anahtar sözcüðü görüldüðünde, taban sýnýfýn interface ile ayný zamanda
default implementasyon verdiði ancak eðer dilersek kendimize özel bir implementasyon saðlayabileceðimizi anlarýz.
Yeni oluþturduðumuz sýnýfta kendimize özel implementasyon saðladýðýmýzda ilgili fonksiyonu override etmiþ oluruz.
Örnekte Car sýnýfýn; start, run ve stop fonksiyonlarý virtual functions(sanal iþlevler), ikinci kategoriye
karþýlýk gelir.

Kýsa Not: Üçüncü kategoride ise virtual anahtar sözcüðü yine kullanýlýr ancak fonksiyon tanýmlanmaz, fonksiyonun 
bildiriminde "= 0" yazýlýr. Bu kategori bazý programlama dillerinde abstract keywordu ile belirlenir. Burada 
verilen bir interface var ancak bir implementasyon yok. Yazdýðýmýz türetilmiþ sýnýfýn concrete olabilmesi için 
bu fonksiyonlarýn override edilmesi gerekir. Bu tür fonksiyonlara yani diðer dillerde abstract olanlara C++ 
terminolojisinde pure virtual function (saf sanal fonksiyon)denir.

Taban sýnýfýn virtual anahtar sözcüðü ile bildirilen veya tanýmlanan fonksiyonlarýna taban sýnýfýn sanal 
fonksiyonlarý denir. C++'da super class'ýn(base class) fonksiyonlarýnýn kategorizasonu þöyle:
Eðer þimdiye kadar bildiðimiz fonksiyon bildirim sentaksý ile bildirilmiþse bu kategori 1. Burada interface
de var implementasyon da var, türemiþ sýnýflar taban sýnýflarýn fonksiyonlarýný olduðu gibi kullanýr.
Taban sýnýfýn virtual anahtar sözcüðü ile tanýmlanan, bildirilen sanal fonksiyonlarý ise ikinci kategori.
Burada taban sýnýf yine implementasyon saðlar, taban sýnýfýn fonksiyon için saðladýðý implementasyon kabul
edilebilir böylece Base gereken bir yerde türemiþ sýnýf türünden bir nesne geldiðinde Base'in implementasyonunu
verdiði kod çalýþýr veya bunun yerine türemiþ sýnýf bu ilgili fonksiyonu override edebilir bu durumda default
implementasyon deðil türemiþ sýnýfýn implementasyonu run time içinde çalýþýr. Burada sanallýk mekanizmasý
devreye girer ve run time'daki baðlama iþlemi devreye girer.
Üçüncü kategori ise yine virtual keywordu var ama "= 0" yazýlýr, buna pure virtual function denir.
virtual override etme imkaný verir ancak zorunlu tutmaz(kategori 2)
pure virtual ise override etmeye mecbur býrakýr çünkü default bir implementasyon vermez.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	void f1();
	virtual void f2(); //virtual
	virtual void f3() = 0; //pure virtual
};
/////////////////////////////////////////////////////////////////////


Türemiþ sýnýf içinde bir taban sýnýfýn üye fonksiyonu ile ayný isimli, ayný veya farklý imzalý bir fonksiyon
bildirilmesini engelleyen bir kural yok.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	void f1();
};
class Der : public Base {
public:
	void f1();
};
/////////////////////////////////////////////////////////////////////
Taban sýnýftaki fonksiyonun ayný isimli bir fonksiyonu var, bu function overloading deðil, overriding de 
deðil olsa olsa maskeleme söz konusu. Ýmzasý ayný veya farklý olabilir. Derleyicinin bu konuda bir kontrol
zorunluluðu yok.


Ancak eðer taban sýnýf fonksiyonu virtual ise durum farklýlaþýr.
Artýk türemiþ sýnýf içinde ayný parametrik yapýda ve ayný isimde fonksiyon bildirilmesi tamamen farklý bir 
durum oluþturur, taban sýnýfýn fonksiyonu override edilmiþ olur. Override etmenin yolu zaten bu, ayný isim ve
parametrik yapýda fonksiyon bildirmek.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int);
};
class Der : public Base {
public:
	void vfunc(int); //override Base's vfunc
};
/////////////////////////////////////////////////////////////////////



Eðer taban sýnýfýn sanal fonksiyonu ile ayný isimde ama farklý parametrik yapýda bir fonksiyon bildirilirse bu
yine ne overload ne de override, yeni bir fonksiyon bildirilmiþ olur. Dilin sentaksýna göre legal.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int);
};
class Der : public Base {
public:
	void vfunc(int, int); //Der'in kendi vfunc'ý
};
/////////////////////////////////////////////////////////////////////


Sanal olmasaydý legal olacak ancak sanal olduðu için illegal olacak bir durum var.
Eðer imza ayný, geri dönüþ deðeri farklý bir fonksiyon bildirilirse bu sentaks hatasý.
Fonksiyon sanal olmasaydý yine geçerli olurdu.
Taban sýnýfýn sanal fonksiyonu ile ayný geri dönüþ deðeri ve ayný imzada fonksiyon bildirilirse, fonksiyon
override edilmiþ olur ancak imza ayný kalmakla birlikte geri dönüþ deðeri türü farklý olursa override olmadýðý
gibi bir de sentaks hatasý olur.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int);
};
class Der : public Base {
public:
	int vfunc(int); //sentaks hatasý
};
/////////////////////////////////////////////////////////////////////



Eðer bir taban sýnýf pointeri veya taban sýnýf referansý yoluyla taban sýnýfýn bir sanal fonksiyonu çaðýrýlýrsa
sanallýk mekanizmasý devreye girer. Eðer o noktada programýn çalýþma zamanýnda taban sýnýf pointerý hangi 
türemiþ sýnýf türünden nesneyi gösteriyorsa o sýnýfýn override'ý çaðýrýlýr(override edilmiþse tabi)
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int x)
	{
		cout << "void Base::vfunc(int)" << endl;
	}
};
class Der : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der::vfunc(int)" << endl;
	}
};
int main()
{
	Der myder;
	Base *bptr = &myder;

	bptr->vfunc(23); // çaðýrýlan Der sýnýfýnýn fonksiyonu
}
/////////////////////////////////////////////////////////////////////

Bu hiyerarþide kaç tane sýnýf olursa olsun geçerli.
Run time'da nesnenin türü neyse, onun override'ý çalýþýr.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int x)
	{
		cout << "void Base::vfunc(int)" << endl;
	}
};
class Der1 : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der1::vfunc(int)" << endl;
	}
};
class Der2 : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der2::vfunc(int)" << endl;
	}
};
int main()
{
	Base *bptr;
	Der1 der1;
	Der2 der2;

	for (;;) {
		if (rand() % 2) {
			cout << "Der1" << endl;
			bptr = new Der1;
		}
		else {
			cout << "Der2" << endl;
			bptr = new Der2;
		}
		bptr->vfunc(10);
		getchar();
	}
	
}
/////////////////////////////////////////////////////////////////////


Sanallýk mekanizmasýnýn devreye girmesi için çaðrýnýn referans veya pointer yolu ile yapýlmasý gerekir.
Çaðrý referans semantiði ile yapýldýðýndan, sanallýk mekanizmasý yine devreye girer.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int x)
	{
		cout << "void Base::vfunc(int)" << endl;
	}
};
class Der1 : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der1::vfunc(int)" << endl;
	}
};
class Der2 : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der2::vfunc(int)" << endl;
	}
};

void func(Base &r)
{
	r.vfunc(10);
}

int main()
{

	for (;;) {
		if (rand() % 2) {
			cout << "Der1" << endl;
			func(*new Der1);
		}
		else {
			cout << "Der2" << endl;
			func(*new Der2);
		}
		getchar();
	}
}
/////////////////////////////////////////////////////////////////////


Taban sýnýf nesnesine türemiþ nesnesi atanabilir, bu legal ancak legal olmasý tercih edilen bir iþlem olduðu
anlamýna gelmez. Buna object slicing denir. Object slicing durumunda sanallýk mekanizmasý devreye girmez.
Programcý üstteki örnek için yanlýþlýkla global func fonksiyonunun parametresinde referans deklaratörünü
silmiþ olsun, bu durumda object slicing durumuna düþtü. Parametre deðiþkeni için copy constructor çaðýrýlýr.
Artýk sanallýk mekanizmasý devreye girmez, çaðrý eðer bir taban sýnýf nesnesi ile yapýlmýþsa her zaman Base'in
fonksiyonu çaðýrýlýr. Sanallýk mekanizmasý için çaðrýnýn mutlaka taban sýnýf referansý veya pointeri ile 
yapýlmasý gerekiyor, çaðrý bir sýnýf nesnesi ile yapýlýrsa object slicing durum ortaya çýkar ve sanallýk mekanizmasý
devreye girmez.


Türemiþ sýnýf taban sýnýfýn bir sanal fonksiyonunu override ettiðinde, türemiþ sýnýfýn fonksiyonunun bildiriminde
virtual anahtar sözcüðünü kullanýlmasa da türemiþ sýnýfýn fonksiyonu sanaldýr.
Sanal fonksiyon: Kendinden kalýtýlan sýnýflara default implementasyon verir veya fonksiyonu override etme hakký
verir.
vfunc, taban sýnýfýn sanal fonksiyonunu override ettiði sürece kendisi de sanaldýr.
Yani Der sýnýfýndan da bir sýnýf türetilse, sanallýk mekanizmasýndan bu türetilen sýnýf da faydalanýr.
Ayný hak Der'den kalýtým yolu ile elde edilecek sýnýflara da tanýnýr.
Der sýnýfýnýn vfunc fonksiyonu için virtual anahtar sözcüðü yazýlsa da yazýlmasa da bu durum geçerli.
Virtual yazýlmasa da override edildiði için zaten, fonksiyon virtual.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int x)
	{
		cout << "void Base::vfunc(int)" << endl;
	}
};
class Der : public Base {
public:
	void vfunc(int x)
	{
		cout << "void Der::vfunc(int)" << endl;
	}
};
/////////////////////////////////////////////////////////////////////



SDer sýnýfý da Der sýnýfýndan türetme yolu ile elde edildi. Der, SDer'in taban sýnýfý; Base de Der'in taban sýnýfý
dolayýsýyla Base de SDer'in taban sýnýfý. Ancak Der, SDer'in direct taban sýnýfý(immediate base class)
SDer de kendi taban sýnýfý olan Der sýnýfýnýn sanal fonksiyonunu override ediyor.
SSDer sýnýfý da SDer sýnýfýndan türetme yolu ile elde ediliyor, ayný kurallar SSDer için de geçerli.
Ayný þekilde SDer'in fonksiyonu da her ne kadar virtual keywordu kullanýlmasa da sanal bir fonksiyon çünkü o da
Der sýnýfýnýn fonksiyonunu override ediyor.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc()
	{
		cout << "void Base::vfunc()" << endl;
	}
};
class Der : public Base {
public:
	void vfunc()
	{
		cout << "void Der::vfunc()" << endl;
	}
};
class SDer : public Der {
public:
	void vfunc()
	{
		cout << "void SDer::vfunc()" << endl;
	}
};
class SSDer : public Der {
public:
	void vfunc()
	{
		cout << "void SSDer::vfunc()" << endl;
	}
};
void foo(Base *p)
{
	p->vfunc();
}

int main()
{
	srand((unsigned)time(nullptr));

	for (;;) {
		switch (rand() % 3) {
		case 0: cout << "Der" << endl; foo(new Der); break;
		case 1: cout << "SDer" << endl; foo(new SDer); break;
		case 2: cout << "SSDer" << endl; foo(new SSDer); break;
		}
		getchar();
	}

}
/////////////////////////////////////////////////////////////////////

Override ederken virtual anahtar sözcüðünün yazýlmama eðilimi daha fazla.



Kalýtýmla oluþturuluacak bir sýnýf yazdýðýmýzý düþünelim ve taban sýnýfýn bir fonksiyonunu override etmek
istiyoruz. Ancak override ederken türemiþ sýnýftaki fonksiyona yanlýþlýkla farklý bir imza verdik.
/////////////////////////////////////////////////////////////////////
class Base {
public:
	virtual void vfunc(int)
	{
		cout << "void Base::vfunc(int)" << endl;
	}
};
class Der : public Base {
public:
	void vfunc(double)
	{

	}
};
/////////////////////////////////////////////////////////////////////
Eðer override etmiþ olsaydýk Der'in vfunc'ýnýn parametresinin de int olmasý gerekirdi. Override edilirken
yanlýþlýkla parametre olarak int yerine double yazýldýðý düþünülsün. Bu farklýlýk sadece primitif türler
için deðil, user defined türler için de benzer þekilde olabillir. 
Low level constluðun da bir imza farký olduðu unutulmamalý. Kimi durumlarda programcý taban sýnýfýn;
virtual void vfunc(const Myclass &); yapýsýndaki bir üye fonksiyonunu türemiþ sýnýflarda override etmek isterken;
virtual void vfunc(Myclass &); yanlýþlýkla bu parametrik yapýyý kullanýr. Bu override olmadýðý gibi sentaks
hatasý da deðil, geçerli bir kod. Ancak programcý override ettiðini sanýyor, bunun farkedilmesi de proje 
büyüdükçe zor olabilir. Bu durumda sanallýk mekanizmasý devrye girmez.
Türemiþ sýnýftaki bu fonksiyon, sanal bir fonksiyon da deðil hele bir de, aslýnda bu sanal olmayan fonksiyon
için programcý sanal olduðunu düþünüp bir de virtual anahtar sözcüðünü yazmýþsa problem daha da büyük.
Bu sýnýftan türetme yolu ile elde edilecek sýnýflara bu aslýnda sanal olmayan fonksiyonun override edilmesi
imkaný verilir. 



/////////////////////////////////////////////////////////////////////
class Myclass{};
class Base {
public:
	void vfunc(const Myclass &);
};
class Der : public Base {
public:
	void vfunc(Myclass &);
};
/////////////////////////////////////////////////////////////////////
Bazen de yanlýþlýkla sanal olmayan bir fonksiyon, sanal zannedilebiliyor. 
Birinci kategoride olan bir fonksiyonun sanal zannedilmesi durumu.
Programcý, vfunc fonksiyonunun sanal olmadýðýný görmedi ve fonksiyonu override etmeye çalýþtý ancak bu override
olmadýðýndan ki zaten fonksiyon sanal deðil override olamaz. Bu ancak gizlemeye neden olabilir. Bir de burada
kendi fonksiyonu için virtal anahtar sözcüðünü kullanmýþ olsa, sanal olmayan bir fonksiyonu override edeyim 
derken kendisi kendi basamaðýndan itibaren bir sanallýk zinciri oluþturmuþ olacaktý.



Bir projede kalýtým hiyerarþisindeki sýnýflarýn Car sýnýfýnýn ilgili fonksiyonunu override ettiði düþünülsün.
100 küsür sýnýf olsun ve hepsi bu fonksiyonu override etmiþ olsun ardýndan projede yapýlan bir deðiþiklik ile 
Car sýnýfýnýn bu fonksiyonunun parametrik yapýsý deðiþtirilsin. Kaç sýnýf bu fonksiyonu override etmiþse
onlarýn hepsinin yeniden derlenmesi gerekir. Tüm sýnýflarýn bu fonksiyonu yeni imza ile bildirmeleri gerekir.
Hangi sýnýflarýn bu fonksiyonu override ettiði, hangi sýnýflarýn kodunun deðiþmesi gerektiðini bulmak oldukça
zor, sentaks hatasý yok.
/////////////////////////////////////////////////////////////////////
class Car {
public:
	virtual void collide(int);
};
/////////////////////////////////////////////////////////////////////


Yukarýdaki tüm bu problemli durumlarýn çözümü, C++11 ile gelen yeni baðlamsal anahtar sözcük.
Bir fonksiyon override edilmek isteniyorsa, bildiriminin sonunda override anahtar sözcüðü yazýlýr. Böylece
derleyicinin yeni kurallara göre kontrol etme yükümlülüðü var. Kendi taban sýnýfýnýn override edebileceði 
bir fonksiyonu yoksa error vermek zorunda böylece bu problemler çözülmüþ olur. 
/////////////////////////////////////////////////////////////////////
class Car {
public:
	virtual void collide(int);
	void start(int);
};
 
class Mercedes : public Car {
public:
	void collide(unsigned int)override; //sentaks hatasý
	void start(int)override; // sentaks hatasý
};
/////////////////////////////////////////////////////////////////////


C++11 öncesinde ise override bir anahtar sözcük deðildi. Dile daha önce olmayan bir statü eklendi. Eski kodlar
override'ý bir fonksiyonun ismi, bir deðiþkenin ismi olarak kullanmýþlarsa sentaks hatasý olur. Bu sebeple
contextual keyword isimli bir statü dile eklendi. Baðlamsal anahtar sözcük denilebilir. Belirli bir baðlamda
kullanýldýðýnda keyword muamelesi görüyor onun dýþýnda ise keyword özelliði yok yani identifier olmasýnda bir
sakýnca yok.
/////////////////////////////////////////////////////////////////////
void override(int x) // tanýmlama geçerli, çünkü buradaki override bir keyword deðil.

{

} 
int main()
{
	int override = 0; // geçerli

}
/////////////////////////////////////////////////////////////////////

Bu statüde bir anahtar sözcük daha var, final anahtar sözcüðü; ileride ele alýnacak.


Sanallýk mekanýzmasýnýn devreye girdiði ve devreye girmediði durumlar:
1)Taban sýnýf pointerý yolu ile sanal fonksiyona çaðrý yapýldýðýnda sanallýk mekanizmasý devreye girer yine ayný
þekilde referans yolu ile çaðrý yapýldýðýnda da sanallýk mekanizmasý devreye girer. Ancak nesne yoluyla çaðrý
yapýldýðýnda sanallýk mekanizmasý devreye girmez. Referans deklaratörünü unutmak burada yapýlan sýk hatalardan,
böylece hem gereksiz yere copy constructor çaðýrýlýr hem de daha önemlisi yapýlan sanal fonksiyon çaðrýlarý
sanallýða baðlanmamýþ olur.

2)Yanlýþlýktan ziyade eðer gerçekten de özellikle sanallýk mekanizmasýnýn devreye girmesi istenmiyorsa bu durumda
sanal fonksiyonlar çözünürlük operatörü ile çaðýrýlýr.  

 
 /////////////////////////////////////////////////////////////////////

class Base {
public:
	virtual void vfunc()
	{
		cout << "void Base::vfunc()" << endl;
	}
};

class Der : public Base {
public:
	void vfunc()override
	{
		cout << "void Der::vfunc()" << endl;
	}
};

void foo(Base *p)
{
	p->vfunc(); //sanallýk mekanizmasý devreye girer.
	p->Base::vfunc(); //sanallýk mekanizmasý devreye girmez

}

int main()
{
	foo(new Der);

}
/////////////////////////////////////////////////////////////////////
foo fonksiyonunun çaðýrýlmasý ile, birinci çaðrýda Der'in vfunc'ý çaðýrýlýr çünkü foo fonksiyonu Der sýnýfý
türünden bir nesne adresi ile çaðýrýldý ve sanallýk mekanizmasý devreye girdi. Ýkinci çaðrýda ise çözünürlük
operatörü kullanýldýðýndan sanallýk mekanizmasý devreye girmez ve Base sýnýfýnýn fonksiyonu çaðýrýlýr.
Bazý durumlarda gerçekten de sanallýk mekanizmasýnýn devreye girmesi istenmez. Mesela foo fonksiyonu içinde
gerçekten de taban sýnýf fonksiyonunun çaðýrýlmasý istenebilir bu gibi durumlarda çözünürlük operatörü 
kullanýlýr.


Bir kalýtým hiyerarþisi olduðu düþünülsün. Yukarýdan aþaðýya A-B-C-D sýnýflarý olsun.(A taban sýnýf diðerleri
yukarýdan aþaðýya birbirlerinden türetilerek oluþturulmuþ sýnýflar). A sýnýfýnýn bir sanal fonksiyonu olsun,
fonksiyonun adý yine vfunc olsun. A'dan türemiþ B sýnýfý bu fonksiyonu override etmemiþ olsun ancak B'den 
türemiþ C sýnýfý bu fonksiyonu override edebilir. Her ne kadar B sýnýfý bu fonksiyonu override etmemiþ olsa da,
A'nýn interface'ini devraldýðýndan B'nin interface'inin bir parçasý da A'nýn interface'i olmuþ olur bu durumda
fonksiyon orada sanal olmaya devam eder, herhangi bir kademede fonksiyon override edilebilir.
Yine ayný hiyerarþide bu defa, B'nin A'nýn saðladýðý fonksiyonu override ettiði düþünülsün, C ise fonksiyonu
override etmesin. Bu durumda C nesnesi bir fonksiyona gönderilse ve fonksiyon A pointeri ile veya A türünden
referans ile çaðýrýlsa, B'nin fonksiyonu çaðýrýlýr. C'nin kendi taban sýnýfýnýn override'ý çaðýrýlýr.
override edilmediði zaman sýnýfýn kendi taban sýnýfýnki çaðýrýlýr. O taban sýnýf da override etmemiþse bu sefer
o taban sýnýfýn kendi taban sýnýfýnýn default implementasyonunu alýr, zincirleme bir durum oluþur.


Sýnýfýn sanal olmayan bir üye fonksiyonu, ayný sýnýfýn sanal olan bir üye fonksiyonunu çaðýrabilir.
Örnekte Base sýnýfýnýn foo isimli fonksiyonu, sýnýfýn sanal olmayan bir üye fonksiyonu ancak bu fonksiyon
sýnýfýn sanal fonksiyonu olan vfunc fonksiyonuna çaðrý yapýyor. main içinde Der3 sýnýfý türünden bir d3
nesnesi oluþturuluyor. Bu d3 nesnesi ile, taban sýnýfýn interface'i içinde olan sanal olmayan foo fonksiyonu
çaðýrýlýyor. Burada yine sanallýk mekanizmasý devreye girer.
Base sýnýfýnýn foo fonksiyonunun gizli parametresi var, bu parametre Base *. 
d3.foo(); çaðrýsýnda bu fonksiyona Base * yerine Der3 * gönderiliyor. foo fonksiyonunun içindeki vfunc çaðrýsý
aslýnda gizli this parametresi ile yapýlýyor. Taban sýnýf pointerý ile yapýlan çaðrýlarda sanallýk mekanizmasý
devreye girer burada da bir fark yok.  
Taban sýnýf pointeri ile sanal bir fonksiyona çaðrý yapýldýðýnda o noktada taban sýnýf pointerý hangi türemiþ
sýnýf nesnesini fiilen gösteriyorsa onunki çaðýrýlýr.
/////////////////////////////////////////////////////////////////////

class Base {
public:
	virtual void vfunc()
	{
		cout << "void Base::vfunc()" << endl;
	}
	void foo()
	{
		cout << "void Base::foo()" << endl;
		vfunc();
	}
};

class Der1 : public Base {
public:
	void vfunc()override
	{
		cout << "void Der1::vfunc()" << endl;
	}
};

class Der2 : public Der1 {
public:
	void vfunc()override
	{
		cout << "void Der2::vfunc()" << endl;
	}
};

class Der3 : public Der2 {
public:
	void vfunc()override
	{
		cout << "void Der3::vfunc()" << endl;
	}
};

int main()
{
	Der3 d3;

	d3.foo();

}
/////////////////////////////////////////////////////////////////////

Not: Sanallýk mekanizmasý tamamen non-statik üyef fonksiyonlara ait, statik fonksiyonlar sanal olamaz.
Global bir fonksiyon için de benzer durum geçerli, sanal olamazlar.

Sanallýk mekanizmasýnýn devreye girmediði durumlar:
1)Object Slicing, nesne semantiði ile çaðrý yapýldýðýnda sanallýk mekanizmasý devreye girmez, sanal iþleve yapýlan
çaðrýnýn taban sýnýf nesnesi ile yapýlmasý durumu.
2)Sanal iþleve çaðrý çözünürlük operatörü ile çaðrý yapýldýðýnda da sanallýk mekanizmasý devreye girmez.
(Burada dikkat edilmesi gereken, bu fonksiyonlar non-statik member function olduklarýndan Myclass.vfunc() gibi
bir çaðrý olamaz ancak p->Myclass::vfunc() gibi veya referans yolu ile de BaseRef.Myclass::bir çaðrý geçerli olur)
3)Sanal iþleve çaðrý taban sýnýf constructor'ý içinde yapýlýrsa da sanallýk mekanizmasý devreye girmez.
4)Sanal iþleve çaðrý taban sýnýf destructor'ý içinde yapýlýrsa da sanallýk mekanizmasý devreye girmez.

/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base()
	{
		cout << "Base::Base()" << endl;
		vfunc();
	}
	virtual void vfunc()
	{
		cout << "void Base::vfunc()" << endl;
	}
};

class Der : public Base {
public:
	void vfunc()override
	{
		cout << "void Der::vfunc()" << endl;
	}
};


int main()
{
	Der myder;

}
/////////////////////////////////////////////////////////////////////
myder nesnesi hayata geldiðinde onun içindeki Base nesnesi de hayata gelecek. Burada normal koþullar altýnda
sanallýk mekanizmasýnýn devreye girmesi beklenir çünkü myder'in içindeki Base için, Base sýnýfýnýn constructor
çaðrýlýr, o da bir üye fonksiyon olduðundan this pointeri var dolayýsýyla aslýnda this->vfunc() gibi bir
çaðrý yapýlmýþ olur. this->vfunc() çaðrýsýnda, this'in türü Base *, buraya gelen adres ise türemiþ sýnýf
nesnesinin adresi bu sebeple sanallýk mekanizmasýnýn devreye girmesi bekleniyor. Ancak burada bir istisna
var, sanallýk mekanizmasý devreye girmez. Eðer burada istisna olmasa, sanallýk mekanizmasý devreye girse bu
iyi bir durum olmazdý. Türemiþ sýnýf nesnesi hayat geldiðinde önce onun içindeki taban sýnýf nesnesi hayata
gelir. Dolayýsýyla programýn akýþý taban sýnýfýn ctor'u içindeyken daha türemiþ sýnýfýn mesela ilave ettiði
memberlar henüz hayata gelmedi ki. Önce taban sýnýf alt nesnesi hayata geliyor, ondan sonra memberlar hayata
gelir. Ýþte this->vfunc()'da bu sanal fonksiyon override'ý memberlarý kullanarak bir iþ yapýyorsa, memberlar
henüz hayata gelmemiþ olacak ancak fonksiyon sanallýk mekanizmasý devreye girdiði için hayata gelmemiþ
memberlarý kullanma giriþiminde bulunacak bu da tabi run time hatasý.
C++'da ctor fonksiyonlar içinde sýnýfýn sanal fonksiyonuna this pointeri ile yapýlan çaðrýlar sanallýk 
mekanizmasýna baðlanmaz bu bir istisna durumdur. Normalde bir üye fonksiyon bir sanal fonksiyonu çaðýrdýðýnda
sanallýk mekanizmasý devreye girer ancak constructor içinde bir sanal fonksiyona yapýlan çaðrý sanallýk
mekanizmasýna baðlanmaz.

Destructor için de benzer bir durum söz konusu, destructor içinde de sanallýk mekanizmasý devreye girmez.
Türemiþ sýnýf nesnesinin hayatý bittiðinde türemiþ sýnýfýn destructor'ý çaðýrýlýr. Türemiþ sýnýfýn destructor'ýnýn
kodunun sonunda taban sýnýf alt nesnesinin destructor'ýna çaðrý yapýlýr. Eðer taban sýnýf destructor'ý içinde
sanallýk mekanizmasý devreye girmiþ olsaydý bu durumda taban sýnýf destructor'ý türemiþ sýnýf nesnesinin öðelerini
hayata veda ettikten sonra veya kaynaklar iade edildikten sonra kullanma giriþimindi bulunmuþ olurdu. 
Yani aslýnda bu istisna constructor'a göre tam tersi nedenden dolayý mevcut. Constructor için böyle bir istisna
olmasýnýn sebebi hayata gelmeden kullanma veya kaynaklarý henüz edinmeden kaynaklarý kullanma giriþimi yüzünden
burada ise kaynaklar geri verilmiþ olabileceðinden.

Statik üye fonksiyonlar zaten sanal olamaz. Sanallýk C++'da ancak ve ancak sýnýfýn non-statik üye fonksiyonlarýna
tanýnan bir hak. Ancak nesne oluþturmaya yönelik tasarým kalýplarýnýn çoðunda ihtiyaç olan bir durum var. Bu 
duruma kavramsal olarak sanal constructor deniyor. C++'nýn sentaksý constructor'ýn sanal olmasýna müsade etmez.
Constructor her ne kadar sýnýflarýn non-statik üye fonksiyonlarý olsa da sanallýk mekanizma geçerli deðil.
Yani aslýnda C++'da ctor dýþýndaki non-statik üye fonksiyonlar için sanallýk mekanizmasý kullanýlabilir.
Sanal constructor ihtiyacý çok sýk bir ihtiyaç, çünkü birçok tasarým kalýbýnda buna mecbur kalýnýyor.
Biz þimdiye kadar hangi türden nesne oluþturmak istediðimizi hep compile time'da belirledik, derleyici kodu
derlerken sýnýf türünden nesnenin türünü zaten biliyor ancak öyle durumlar var ki hangi türden nesnenin
hayata geleceði run time'a iliþkin olabiliyor, hangi türden nesnenin hayata geleceði run time'da belirlenir.
Örnek olarak yine Car hiyerarþisi düþünülsün;
void carRace(Car &r)
{
	//Buraya hangi türden araba gelmiþse o türden bir araba daha hayata gelsin
	r.drive();
}
carRace fonksiyonu run time'da hangi türden araba ile çaðýrýlýrsa yine ayný türden bir arabanýn daha hayata
geldiði düþünülsün. Bu durumda bu arabanýn hayata gelmesi için constructor gerekiyor. Bu fiilen sanal ctor
demek. Bir ctor'un çalýþmasý isteniyor ancak hangi ctor'un çalýþacaðý run time'daki koþullara baðlý.
Burada C++'da buna yönelik hazýr bir destek yok ancak kendimiz kod yazmamýz gerekir, buradaki idiyoma clone
idiyomu denir veya virtual constructor idiyomu denir. Sanallýk mekanizmasý ctor için devreye girmiyor olsa da 
diðer üye fonksiyonlar için devreye giriyor o zaman taban sýnýfýn bir tane sanal üye fonksiyonu olsa geri dönüþ
deðeri ise nesne türünden adres yani taban sýnýf türünden bir pointer olsa, fonksiyon sanal olduðundan bütün
sýnýflar bu fonksiyonu override edebilir. Örnek olarak Mercedes fonksiyonu override ettiðinde fonksiyon dinamik 
bir Mercedes yaratýp onun adresini geri döndürür. Sanallýk mekanizmasý devreye gireceðinden bir sorun olmaz.

/////////////////////////////////////////////////////////////////////
class Car {
	std::string m_color; //arabanýn rengi bilgisi
	int m_age; //arabanýn yaþý bilgisi
public:
	Car(const std::string &color, int age) : m_color{ color }, m_age{ age } {}
	virtual void speed() = 0;
	virtual Car *clone() = 0; //pure virtural, default implementasyon verilmeyecek
	void display()const
	{
		std::cout << "renk : " << m_color << std::endl;
		std::cout << "yas  : " << m_age << std::endl;
		std::cout << "***********************************************" << std::endl;
	}
};

class Bmw : public Car {
public:
	Bmw(const std::string &color, int age) : Car{color, age} {}
	void speed()override
	{
		std::cout << "Bmw hizlaniyor" << std::endl;
	}
	virtual Car *clone()override
	{
		return new Bmw{*this}; //Bmw'nin copy constructor'ý çaðýrýlýr, ayný tür ve ayný özellikler
		//new Bmw{ "beyaz", 0 }; //ayný türden baþka bir nesne
	}
};

class Mercedes : public Car {
public:
	Mercedes(const std::string &color, int age) : Car{color, age} {}
	void speed()override
	{
		std::cout << "Mercedes hizlaniyor" << std::endl;
	}
	virtual Car *clone()override
	{
		return new Mercedes{*this}; 
	}
};

class Volvo : public Car {
public:
	Volvo(const std::string &color, int age) : Car{ color, age } {}
	void speed()override
	{
		std::cout << "Volvo hizlaniyor" << std::endl;
	}
	virtual Car *clone()override
	{
		return new Volvo{ *this };
	}
};

void carGame(Car *p)
{
	p->display();
	Car *pn = p->clone();
	p->speed();
	pn->speed();
	pn->display();
	
}
using namespace std;
int main()
{
	srand(static_cast<unsigned>(time(nullptr)));

	for(;;){
	switch (rand() % 3) {
	case 0: cout << "Bmw case" << endl; carGame(new Bmw{ "Siyah", 3 }); break;
	case 1: cout << "Mercedes case" << endl; carGame(new Mercedes{ "Yesil", 6 }); break;
	case 2: cout << "Volvo case" << endl; carGame(new Volvo{ "Kirmizi", 1 }); break;
		}
	getchar();
	}
}
/////////////////////////////////////////////////////////////////////
clone fonksiyonunda copy constructor çalýþýr, yani ayný nesneden bir tane daha oluþturulmuþ 
oldu. Ancak yeni, farklý bir Bmw oluþturulmak istendiðinde baþka bir kod yazýlýr. clone denildiði
zaman vurgu daha çok ayný nesneden bir tane daha oluþturmak yönünde. 

Dinamik Tür ve Statik Tür Kavramý:
C gibi bir dilde bir nesnenin türü her zaman compile time'da bellidir. Ancak yukarýdaki örnekte
mesela, *p bir nesne ancak *p nesnesi run time'da Bmw ise Bmw gibi Volvo ise Volvo gibi davranacak.
Run time açýsýndan bakýldýðýnda *p türetme hiyerarþisi içinde bulunan onlarca sýnýftan biri olabilir.
Nesnenin derleme zamanýnda derleyicinin yaptýðý bir takým kontrollere tabii türüne nesnenin statik
türü denir. ok operatörü, nokta operatörü ve çözünürlük operatörünün sað tarafýnda kullanýlan 
isimler her zaman statik türe göre kontrol edilir. ptr bir pointer olmak üzere ptr->func() gibi
bir çaðrý yapýldýðýnda derleyici func ismini ptr'nin ait olduðu sýnýfýn scope'u içinde arar. ptr'nin
polimorfik bir türden olmasý isim aramayý deðiþtirmez. Ne kadar türetme olursa olsun veya çalýþma 
zamaný çok biçimliliði olursa olsun, eðer derleyici func ismini compile time'da ptr'nin ait olduðu
sýnýfýn scope'u içinde bulamazsa name look up hatasý oluþur. Compile time'a iliþkin kontroller
statik türe göre yapýlýr. Polimorfik sýnýf diye bir kavram olmasaydý, dinamik tür de olmazdý çünkü
*ptr, ptr->, BaseRef. her zaman Base gibi davranýrdý. Davranýþa esas tür ise dinamik tür.  
Compile time'a iliþkin kontroller yani statik kontroller nesnenin statik türü ile ilgili ancak davranýþ
dinamik türü ile ilgili.

/////////////////////////////////////////////////////////////////////
using namespace std;
class Car {
public:
	virtual void drive()
	{
		std::cout << "Car is running" << std::endl;
	}
};
class Dacia : public Car {
	virtual void drive()override
	{
		std::cout << "Dacia is running" << std::endl;
	}
public:
};

void foo(Car *ptr)
{
	///////////
	ptr->drive();
}
int main() {
	foo(new Dacia);
}
/////////////////////////////////////////////////////////////////////
Burada bir sentaks hatasý oluþmaz. Access control her zaman statik türe iliþkindir.
Burada foo fonksiyonu içinde ptr->drive() fonksiyonu çaðýrýldýðýnda, fonksiyon Dacia türünden
nesne için çaðýrýlýr, Dacia sýnýfýnýn drive fonksiyonu ise sýnýfýn private bölümünde ancak bir
access control hatasý oluþmaz. Access control'un dinamik tür ile bir ilgisi yok.
Bu kodda access control sadece ptr->drive();'a göre yapýlýr yani derleyici sadece ptr'nin türüne
bakar o da Car *, drive ise Car sýnýfýnýn private bölümünde mi hayýr deðil o zaman hiçbir
problem yok. Yani bir sanal fonksiyonu sýnýfýn private bölümünde override etmek ile onun çaðýrýlmasý
engellenmez. Fonksiyonun private bölümde olmasýnýn yarattýðý farklýlýk ise eðer çaðrý Car * ile 
deðil de Dacia * ile yapýlsaydý kontrol o statik türe göre yapýlacaktý, o zaman error olacaktý.
/////////////////////////////////////////////////////////////////////
int main()
{
	auto p = new Dacia;
	foo(p); //geçerli

	p->drive(); //geçersiz
}
/////////////////////////////////////////////////////////////////////
foo(p) çaðrýsýnda bir problem yok yine ayný þekilde geçerli. Ancak p->drive(); geçersiz burada
access hatasý mevcut.




/////////////////////////////////////////////////////////////////////
using namespace std;
class Car {
public:
	virtual void drive(double speed = 180.)
	{
		std::cout << "Car is running at speed " << speed << std::endl;
	}
};
class Bmw : public Car {
public:
	virtual void drive(double speed = 90.)override
	{
		std::cout << "Dacia is running at speed " << speed << std::endl;
	}
};

void foo(Car *ptr)
{
	///////////
	ptr->drive();
} 
int main() {
	auto p = new Bmw;
	foo(p);

	p->drive();
}
/////////////////////////////////////////////////////////////////////
Varsayýlan argüman kontrolü de kesinlikle statik türe göre yapýlýr. ptr->drive() ifadesinde
ptr'nin türü Car * olduðu için varsayýlan argüman olarak Car sýnýfýnýn varsayýlan argümaný alýnýr.
Hem foo(p) ifadesinde hem de p->drive() ifadesinde ayný sýnýfýn drive fonksiyonu çaðýrýlý ve 
ikisinde de varsayýlan argüman kullanýlmýþ ancak p->drive()'daki çaðrý Bmw pointeri ile yapýldýðý
için ve varsayýlan argüman kontrolü statik türe göre yapýldýðýndan varsayýlan argüman olarak 90
kullanýlýr. 

Nokta operatörünün, ok operatörünün, çözünürlük operatörünün saðýndaki isimlerin ne olduðu kontrolleri
statik türe göre yapýlýr. Default argüman kontrolü ve access control de statik türe baðlý olarak 
yapýlýr. Dinamik tür ise davranýþa esas tür. carGame fonksiyonu düþünüldüðünde parametresi Car *,
bu fonksiyonun içindeki *ptr artýk dinamik tür; Bmw de olabilir, Mercedes de olabilir.	


typeid operatörü hem dinamik türe hem de statik türe göre çalýþýr. Eðer ortada polimorfik bir tür
varsa typeid operatörü dinamik türe göre çalýþýr ancak polimorfik bir tür deðilse o zaman statik
türe göre çalýþýr. Dinamik türden bahsedebilmek için polimorfik bir tür olmasý gerekir, polimorfik
tür olmasý için de en az bir sanal fonksiyonu olmasý gerekir. Bir türün polimorfik olmasý için ya 
kendisinin bir sanal fonksiyonu olacak ya da  polimorfik bir taban sýnýftan kalýtým yolu ile elde 
edilmiþ olacak.


27_OCAK_2018_CUMARTESÝ

Kalýtýmda üçüncü kategori sadece interface veren. Burada kullanýlan fonksiyonlar pure virtual(saf sanal)
fonksiyonlar. Bu durumda bu fonksiyonlar override edilmek zorunda, sýnýfýn concrete olmasý için.
Override edilmezse kalýtým geçerli olur ancak o sýnýf abstract olur yani o sýnýf türünden nesne 
tanýmlanamaz. Bir sýnýfýn en az bir tane saf sanal fonksiyonu varsa ya da bir sýnýf soyut bir 
sýnýftan kalýtým yoluyla elde edilmiþ ancak taban sýnýfýn tüm saf sanal fonksiyonlarýný override
etmemiþ ise bu sýnýf soyut(abstract class) sýnýflardýr. Bu sýnýflar polimorfik iþlemlerde kullanýlýrlar
ancak instantiate edilemezler yani bu sýnýflar türünden nesne tanýmlanamaz. Çoðu nesne yönelimli
sistemde polimorfik iþlemeye esas sýnýflar genelde soyut sýnýflar olur.

C++'da bir sýnýfýn abstract class olabilmesi için en az bir tane saf sanal fonksiyonu olmalý veya 
abstract bir sýnýftan kalýtým yolu ile elde edilecek ancak o taban sýnýfýn pure virtual fonksiyonlarýndan
en az birini override etmemiþ olacak. Buradaki abstract olmasýnýn nedeni, derleyici compile time'da
kontrol yapar, o sýnýf türünden nesne tanýmlanmasý durumunda sentaks hatasý verecek. Unutulmamalý ki
nesne tanýmlanamýyor ancak referans ve pointer tanýmlanabiliyor ki bu tür sýnýflar çoðunlukla
pointer ve referans yolu ile fonksiyonlara parametre olurlar böylece polimorfik iþlemelerde kullanýlýrlar.
C++'da statik fonksiyonlar ve global fonksiyonlar polimorfik olamaz, yani doðrudan override edilemezler.
Polimorfik bütün sýnýflarda her ne kadar dilin bir zorunluluðu olmasa da destructor sanal yapýlýr.

/////////////////////////////////////////////////////////////////////
using namespace std;
class Car {
	std::string m_color;
	int m_age;
public:
	Car(const std::string &color, int age) : m_color{ color }, m_age{ age } {}
	virtual void display(std::ostream &os)const = 0;
};

class Audi : public Car {
public:
	Audi(const std::string &color, int age) : Car{color, age} {}
};

int main() {
	Car mycar{"red", 10}; //geçersiz, "cannot instantiate abstract class"
	Car *ptr; //geçerli

	Audi myAudi{"blue", 7}; //geçersiz, "cannot instantiate abstrac class"
}
/////////////////////////////////////////////////////////////////////
Car sýnýfý bir abstract class çünkü bir tane pure virtual fonksiyonu var. Car sýnýfý türünden bir
nesne oluþturmak geçersiz ancak Car sýnýfý türünden bir pointer tanýmlamak geçerli.
Audi, Car sýnýfýndan kalýtým yolu ile elde edilmiþ bir sýnýf, Audi sýnýfý Car sýnýfýnýn display
fonksiyonunu override etmedi bu yüzden Audi de abstract class. Eðer Audi sýnýfý Car sýnýfýnýn
display fonksiyonunu override ederse bu durumda Audi sýnýfý türünden nesne oluþturmak geçerli olur.


/////////////////////////////////////////////////////////////////////
using namespace std;
class Car {
	std::string m_color;
	int m_age;
public:
	Car(const std::string &color, int age) : m_color{ color }, m_age{ age } {}
	virtual void display(std::ostream &os)const = 0;
	virtual void drive() = 0;
};

class Audi : public Car {
public:
	Audi(const std::string &color, int age) : Car{color, age} {}
	virtual void display(std::ostream &os)const override;
};

void func(Car *p)
{
	p->drive();
	p->display(cout);
}
/////////////////////////////////////////////////////////////////////
Audi sýnýfý türünden bir nesne oluþturmak yine sentaks hatasý çünkü Audi sýnýfý yine soyut sýnýf.
display fonksiyonunu override etmiþ ancak bu Audi sýnýfýný concrete yapmaz. Ýstisnasýz taban sýnýfýn
bütün sanal fonksiyonlarýný override etmeli ki ancak o zaman soyut sýnýf olmaktan çýksýn.
Ancak Audi sýnýfýnýn soyut olmasý demek, onun func fonksiyonunda kullanýlamayacaðý anlamýna gelmez.
Pointer semantiði ve referans semantiði ile soyut sýnýflar kullanýlabilir.

Sanallýk Mekanizmasý Nasýl Ýmplente Ediliyor ?
Bir fonksiyona bir adres gönderiliyor ve o adresten hareketle run time'da yüzlerce sýnýf arasýndan
hangi fonksiyonun çaðýrýlacaðý anlaþýlýyor. Car hiyerarþisi içinde onlarca sýnýf var, parametresi
Car * olan bir fonksiyon var ve bu fonksiyona sadece bir adres, bellekte bir konum gönderiliyor.
Ancak çalýþma zamanýnda bir þekilde o nesnenin ne olduðu anlaþýlýyor.


/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
	int x, y;
public:
	void f1();
	void f2();
	void f3();
	virtual void vf1();
	virtual void vf2();
	virtual void vf3();
};
int main() {

	cout << "sizeof(Base) = " << sizeof(Base) << endl;
}
/////////////////////////////////////////////////////////////////////
Bir sýnýfýn bir tane bile sanal fonksiyonu olmamasý durumunda yani polimorfik olmayan sýnýflarda
sýnýf türünün sizeof'u öðelerinin sizeoflarýnýn toplamý kadar. Ancak sýnýf polimorfik hale geldiði
zaman sizeof'u 4 byte arttý çünkü bir pointer 4 byte. Birden fazla sanal fonksiyon olmasý durumu
deðiþtirmez. Derleyici eðer bir sýnýf polimorfikse gider o sýnýf türünden nesnelerin içine bir 
pointer gömer. Base sýnýfýnýn 2 tane öðesi var ancak aslýnda 2 deðil 3 öðesi var bu 3. öðeyi
derleyici ekledi. Bu pointera kavramsal olarak virtual table pointer denilir. Base'den kalýtým
yolu ile bir Der sýnýfý elde edilse, Der'in sizeof'u yine 12 olur çünkü Der'in içinde Base var.
O pointer Base'in içine gömülür, her türemiþ sýnýf içinde bir taban sýnýf alt nesnesi var o zaman
bu sýnýf hiyerarþisinde hangi sýnýf olursa olsun nihayetinde hepsinin içerisinde bir Base nesnesi
var yani hepsinin içinde o pointer var. Der'den de türetilmiþ bir sýnýf olursa da farksýz onun 
içinde de yine Base nesnesi mevcut, hepsinin içinde yine o pointer var. 
Biz nasýl kendi oluþturduðumuz nesnelere ilk deðer veriyorsak derleyici de kendi oluþturduðu bu
pointerý bir kodla initialize eder. Bir veri yapýsýnýn adresi ile initialize eder. Bu veri yapýsýna
da virtual function table denir, tipik olarak vektör kullanýlýr. Aslýnda öðeleri fonksiyon adresleri
olan bir vektör var, o öðelerin baþlangýç adresi ile Base'in içindeki pointer initialize edilir.

Bu veri yapýsýnda fonksiyonlarýn adresleri tutulur, mesela bu veri yapýsý Audi sýnýfý için olsun:
Bu veri yapýsýndaki entrylerin indexlendiðini düþünelim:

				AUDI
	----------------------------------------	
0				&start
	----------------------------------------
1				&drive
	----------------------------------------
2				&stop
	----------------------------------------
3				&speed_up
	----------------------------------------

Derleyici ürettiði kodla run time'ýn baþýnda bu veri yapýsýndaki, bu vektördeki öðeleri ilgili 
sýnýfýn sanal fonksiyonlarýnýn overridelarýnýn adresleri ile ilk deðer verir. Mesela 0'da start
fonksiyonunun adresi var, Audi'nin start fonksiyonunun adresi!
Bu Audi sýnýfýnýn sanal fonksiyon tablosu, kalýtým hiyerarþisinde polimorfik ne kadar sýnýf varsa
hepsi için böyle bir tablo var ve run time'da tutulur. Derleyici ayný indiste ayný sanal fonksiyonlarýn
adreslerini tutar. Audi'nin drive override'ý burada 2 numaralý indiste ise Mercedes'in de drive
override'ý yine 2 numaralý indiste tutuluyor. Bu bilgiye run time'da deðil compile time'da eriþilir,
derleyici hangi fonksiyonlarýn sanal olduðunu compile time'da zaten bulur. 
Derleyici taban sýnýf türünden nesneye pointer gömer, bu pointer'a virtaul pointer denir. Bu pointera
ilgili sýnýfýn sanal fonksiyon tablosunun adresi ile ilk deðer verir. Yani bu Car nesnesi bir Audi'nin
içindeki Car ise, o zaman bu pointer Audi'nin sanal fonksiyon tablosunun adresini taþýr.
Audi'nin tablosunun adresi 4400, Mercedes'in tablosunun adresi 9000 olsun, böyle belki onlarca ayrý
sanal fonksiyon tablosu var ancak bu bir Audi nesnesi ise yani bu taban sýnýf olan Car nesnesi bir
Audi nesnesinin içindeki Base Class object olan Car ise derleyici bu pointerý run time'da 4400 adresi
ile initialize eder. Her polimorfik nesnenin içinde bir pointer var ama o pointerin deðeri o nesne
hangi sýnýf türünden ise o sýnýfýn sanal fonksiyon tablosunun adresi.
carptr diyelim ki Car taban sýnýfý türünden bir pointer. carptr->drive() diye bir fonksiyon çaðrýsý
yapýldýðýnda, derleyici drive fonksiyonunun virtual olup olmadýðýný compile time'da anlar. Eðer
virtual olmasaydý C'de ürettiðine benzer bir kod üretecekti yani linkera bu fonksiyonun çaðrýldýðýna
dair bir referans yazacaktý. Burada ise derleyici þöyle bir kod üretir:
carptr bir Car nesnesini gösterir, derleyici için o Car nesnesinin Audi'nin içindeki Car nesnesi mi,
Bmw'nin içindeki Car nesnesi mi olduðu hiç farketmez. Derleyici orada bir vptr olduðunu biliyor,
çünkü kendi yerleþtirdiðinden yerini biliyor, derleyici þöyle bir kod üretir: carptr->vptr
Bu bir vektörün adresi, gider bu adresteki vektörün veya herhangi bir veri yapýsýnýn mesela 2 indisli
elemanýna eriþir: (carptr->vptr)[2] buradan bir fonksiyon adresi elde eder ve (carptr->vptr)[2]() o
fonksiyonu çaðýrýr. Bu 2'yi de yine compile time'dan bilir, taban sýnýfýn her bir sanal fonksiyonunu
indexlediði düþünülsün, ayrý ayrý sýnýflar var ama ayný indexde ayný overridelar tutuluyor.

Sanallýk mekanizmasýnýn tabi ki bir maliyeti var. Sonuçta run time'da bir kod çalýþýyor. Çok alt 
seviyeli bir uygulama deðilse bu maliyetin lafý bile olmaz. Sadece iki tane dereferencing fazlasý var.
Biri vptr'ye eriþmek diðeri ise vptr yoluyla sanal fonksiyon tablosunun belirli bir indexine eriþip
oradan fonksiyonun adresini almak. Eðer sanal olmasaydý fonksiyonun adresini doðrudan kullanacaktý
þimdi ise önce nesnenin içindeki pointera bakar, oradan tablonun adresine eriþip index yolu ile 
fonksiyona ulaþýr. Buraya kadar olan iþlem maliyeti bir de bellek maliyeti var. 
Bellek ile ilgili kýsýtlama çok daha fazla. Bir kere her polimorfik nesne için bir pointer fazla
bellek alaný tutuluyor. Kalýtým yolu ile elde edilecek tüm sýnýf nesnelerinde de bir pointer fazla 
olacak. Bir de sanal fonksiyon tablolarý var. Bu tablolar da bir yer kaplýyor ancak instance baþýna
deðil class baþýna. Her polimorfik sýnýf nesnesi için bir pointer fazla bellek alaný her polimorfik
class için bir sanal fonksiyon tablosunun bellek alaný. 100 sýnýf varsa bu 100 sýnýf için run
time'ýn baþýnda bu tablolar üretilir. Eðer türemiþ sýnýf override etmemiþse, taban sýnýfýn fonksiyon
adresleri konur böylece her halükarda o adresteki fonksiyon çaðýrýldýðýnda override etmiþ ise onun
override'ý çaðýrýlýr override etmemiþse de onun taban sýnýfýnýn fonksiyonunun adresi ile initialize
edildiðinden taban sýnýfýn override'ý çalýþýr. 
Biz carptr->vfunc() diye bir çaðrý yaptýðýmýzda derleyici önce statik türe göre bu isme bakar daha 
compile time'dayýz, bunun sanal fonksiyon olduðunu görür ve yine compile time'da index elde eder.
Bu pointerýn gösterdiði taban sýnýf nesnesinin içine kendi gömdüðü pointera eriþir, o adresten yola
çýkarak veri yapýsýna ve veri yapýsýnýn belirli bir öðesine eriþir onun da bir fonksiyon adresi
olduðunu bildiðinden o adresteki fonksiyona çaðrý yapar.	


Virtual Destructor(Sanal Sonlandýrýcý Ýþlev)

Sanallýk mekanizmasýnýn devreye girmesi için ortada bir referans veya pointer olmasý gerekir.
Elimizde bir taban sýnýf pointerý veya referansý varsa bu pointer veya referans yolu ile bir 
fonksiyon çaðýrýldýðýnda sanallýk mekanizmasý devreye girer. Dinamik ömürlü nesneler söz konusu
olduðunda ise bazý problemli durumlar ortaya çýkabiliyor. 
Bmw *p = new Bmw; bu nesnenin hayatýný bitirmek için delete operatörünü kullanýyorýuz.
delete ptr; ifadesi ile. delete operatörü karþýlýðýnda derleyici sýnýfýn, ptr'nin ait olduðu sýnýfýn
destructor'ýný çaðýrý, destructor'ýn kodunun çalýþmasýndan sonra da operatör delete fonksiyonunu
çaðýrarak o sizeof(Bmw) kadar ayýrýlan yeri geri verir. new operatörü bir bellek alanýnýn tahsis
edilmesini saðlar delete operatörü ise tam tersini yapar. Bmw'de olduðu gibi sýnýfýmýz kalýtým
hiyerarþisinde yer alan bir sýnýf ise bu durumda ptr denildiðinde derleyici Bmw'nin destructor'ýný
çaðýrýr, Bmw'nin destructor'ýnýn sonuna da derleyici taban sýnýfýn destructor'ýna yapýlan çaðrýyý
ekler. Bmw eðer Car sýnýfýndan türetilmiþse önce Bmw'nin ardýndan onun içindeki taban sýnýfýn alt
nesnesinin yok edilmesi için Car sýnýfýnýn destructor'ý çaðýrýlýr.	
Unutulmamalý ki dinamik ömürlü nesnelerinin hayatlarýný bitirmek kodu yazanýn sorumluluðunda, C++'da
garbage collector yok.

/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	Base() {
		std::cout << "Base nesnesi icin kaynaklar edinildi" << std::endl;
	}
	~Base() {
		std::cout << "Base nesnesi icin kaynaklar geri verildi" << std::endl;
	}
};

class Der : public Base {
public:
	Der() {
		std::cout << "Der Constructor" << std::endl;
	}
	~Der() {
		std::cout << "Der Destructor" << std::endl;
	}
};

int main() {
	
	Der *derptr = new Der;

	delete derptr;
}
/////////////////////////////////////////////////////////////////////



Run time polymorphism düþünüldüðünde çoðu zaman türemiþ sýnýf nesnelerini taban sýnýf pointerý ile 
manipüle ediyoruz. Der nesnesini Der türünden deðil, Base türünden bir pointer ile kontrol ederiz.
Her Der bir Base olduðu için dinamik Der nesnesi Base'e de baðlanýr.
/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	Base() {
		std::cout << "Base nesnesi icin kaynaklar edinildi" << std::endl;
	}
	~Base() {
		std::cout << "Base nesnesi icin kaynaklar geri verildi" << std::endl;
	}
};

class Der : public Base {
public:
	Der() {
		std::cout << "Der Constructor" << std::endl;
	}
	~Der() {
		std::cout << "Der Destructor" << std::endl;
	}
};

int main() {
	
	Base *baseptr = new Der;

	delete baseptr;
}
/////////////////////////////////////////////////////////////////////
Base nesnesinin kaynaklarý geri verildi ancak Der sýnýfýnýn destructor'ý çaðýrýlmadý.
Der nesnesi de ayný þekilde kaynaklar elde edebilir.
Polimorfik sýnýf için Der nesnesi, taban sýnýf pointerý ile iþlendi	ama nesne dinamik olduðunda
Der nesnesinin edindiði kaynaklar geri verilmemiþ olur.
Derleyici delete baseptr; gibi bir ifade gördüðünde baseptr'nin statik türüne bakar ki o da Base *,
gider Base'in destructor'ýný çaðýrýr oysa aslýnda Der'in destructor'ýnýn çaðýrýlmasý gerekiyor.
Yani burada Base yerine Der'in destructor'ý çaðýrýlsaydý bir problem olmayacaktý. Derleyici burada
statik türe bakýyor.


Çözümü ise oldukça basit, destructor'ý virtual yapmak. Nasýl bir sanal fonksiyon mekanizmasý herhangi
bir üye fonksiyon için devreye giriyorsa destructor için de devreye girer. delete baseptr; ifadesinde
kullanýlan adres Base * olmasýna raðmen derleyici bu noktada hangi destructor'ý çaðýracaðýný bu 
noktada baseptr'nin kimi gösterdiðine baðlý olarak seçer. Artýk hangi destructor'ýn çaðýrýlacaðý
çalýþma zamanýnda belirlenir.
/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	Base() {
		std::cout << "Base nesnesi icin kaynaklar edinildi" << std::endl;
	}
	virtual ~Base() {
		std::cout << "Base nesnesi icin kaynaklar geri verildi" << std::endl;
	}
};

class Der : public Base {
public:
	Der() {
		std::cout << "Der nesnesi icin kaynaklar edinildi" << std::endl;
	}
	~Der() {
		std::cout << "Der nesnesi icin kaynaklar geri verildi" << std::endl;
	}
};

int main() {
	
	Base *baseptr = new Der;

	delete baseptr;
}
/////////////////////////////////////////////////////////////////////
Burada bütün problem, dinamik bir türemiþ sýnýf nesnesini taban sýnýf pointeri ile kontrol etmek, 
böyle bir problem olmasaydý zaten sanal destructor'a ihtiyaç olmayacaktý.
Destructor sanal deðilse delete ptr; gibi bir ifadede derleyici ptr'nin statik türüne bakar ve 
çaðrýyý ona göre yapar. Ancak run time'da kaynaklarýn geri verilmesi için aslýnda delete edilen
pointerýn statik türüne iliþkin deðil dinamik türüne iliþkin sýnýfýn destructor'ýnýn çaðýrýlmasý
gerekiyor.
Eðer bir sýnýf polimorfik olacaksa destructor'ý sanal yapýlmalý.
Bir sýnýfýn destructor'ýnýn sanal yapýldýðý görülürse, sýnýf polimorfik bir yapý için hazýrlanmýþtýr.
Bir sýnýfýn kalýtým için oluþturulduðunu anlamanýn en temel 2 göstergesi; sýnýfýn protected bölümü
olmasý(olmak zorunda deðil), destructor'ýnýn sanal olmasý.


Sýnýf Ýçi Using Bildirimi:

/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	void func()
	{
		std::cout << "Base::func" << std::endl;
	}
};
class Der : public Base {
public:
	void func(int)
	{
		std::cout << "Der::func" << std::endl;
	}
};
int main() {

	Der myder;
	myder.func(); //geçersiz

	myder.Base::func(); //geçerli
}
/////////////////////////////////////////////////////////////////////
Burada function overloading yok, func fonksiyonlarýnýn scope'larý farklý.
myder.func(); geçersiz bir ifade çünkü derleyici func ismini arar, myder sýnýfý içinde bulur ve
bir parametreli olan func fonksiyonunu görür.



Burada function overloading olmamasýna raðmen, Base'in func fonksiyonunun da Der'in interface'inde
olmasý istenebilir yani sanki bir function overloading varmýþ gibi.
/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	void func()
	{
		std::cout << "Base::func" << std::endl;
	}
};
class Der : public Base {
public:
	void func()
	{
		Base::func();
	}
	void func(int)
	{
		std::cout << "Der::func" << std::endl;
	}
};
int main() {

	Der myder;
	myder.func(); //Base::func
	myder.func(5); //Der::func
}
/////////////////////////////////////////////////////////////////////
Türemiþ Der sýnýfý içine, Base'in func fonksiyonunun aynýsý konulur o da kendi içinde Base'in
func fonksiyonuna çaðrý yapar böylece myder.func() ifadesinde Base'in func'ýna çaðrý yapýlýr.
Bu compile time'a yönelik bir durum. Eðer Base'in 10 tane ayrý fonksiyonu olsaydý yine ayný isimde
func'ýn overloadlarý için türemiþ sýnýf içinde 10 tane ayrý fonksiyon yazýlýr ve bu ilgili Base
fonksiyonlarýna çaðrý yapýlýrdý.	

Diðer bir problem ise þu þekilde; Base'in fonksiyonlarýnýn Base'in protected bölümünde olduðu
düþünülsün, yani clientlara kapalý. Yine bu fonksiyonlar türemiþ sýnýf nesnesi içinde interface'e
katýlýp, clientlara açýk hale getirilmek isteniyor. Yapýlacak þey yine ayný, ayný parametrik yapýda 
fonksiyonlar tanýmlanýr, onlar Base'in protected fonksiyonlarýný çaðýrabilir, bu yazýlan fonksiyonlar
da public olsun böylece protected fonksiyonlar bizim clientlarýmýz tarafýndan çaðýrýlabilir.
/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
protected:
	void func()
	{
		std::cout << "Base::func()" << std::endl;
	}
	void func(double)
	{
		std::cout << "Base::func(double)" << std::endl;
	}
	void func(int, int)
	{
		std::cout << "Base::func(int, int)" << std::endl;
	}
};
class Der : public Base {
public:

};
int main() {

	Der myder;
	myder.func();     //geçersiz
	myder.func(2.5);  //geçersiz
	myder.func(5,10); //geçersiz 
}
/////////////////////////////////////////////////////////////////////
Tüm bu fonksiyonlara yapýlan çaðrýlar sentaks hatasý, hatanýn sebebi de protected bölümdeki fonksiyonlara
eriþilemiyor olmasý. Taban sýnýfýn protected fonksiyonlarýný kendimiz çaðýrabildiðimiz gibi clientlar da 
çaðýrabilsin isteniyorsa yine ayný þekilde Der sýnýfý içinde ayný isimde ve parametrik yapýda fonksiyonlar
tanýmlanýr ve bu fonksiyonlar, Base sýnýfýnýn protected bölümündeki fonksiyonlara çaðrý yapar.


Ýki durumda da ayný hile yapýlýr. Hep birinci problemin hem de ikinci problemin hiç bu þekilde kod
yazmadan çözülebileceði dilin bir aracý mevcut: sýnýf içi using bildirimi.
/////////////////////////////////////////////////////////////////////
class Der : public Base {
public:
	using Base::func;
};
/////////////////////////////////////////////////////////////////////
Der sýnýfý içinde böyle bir using bildirimi yapýlýr, arkadaki kodlarý derleyici ayarlar.
Sanki Der sýnýfýnýn public bölümünün bir parçasýymýþ gibi doðrudan public bölümde görülür kabul
ediliyor. Eðer farklý isimde fonksiyonlar varsa, isimler için ayrý ayrý using bildirimi yapýlmalý.
Bunun kullanýldýðý iki tipik yer var, biri maskeleme yani birinci tema. Ortada zaten maskeleme yoksa 
buna gerek yok. Taban sýnýfýn public bölümü zaten türemiþ sýnýfýn public bölümü, derleyici onu zaten
otomatik olarak yapar. Sýnýfýn protected bölümüne eriþmek yani onu clientlara açmak ve gizleme olmasýna
raðmen o gizlemeyi ortadan kaldýrýp adeta bir function overloading yaratmak bu mekanizmanýn en çok
kullanýldýðý iki tip senaryo. Bu mekanizmada da bir seçicilik yok yani örnekte mesela func ismi için
using bildirimi yapýldýðýnda bu tüm fonksiyonlar için geçerli aradan birini seçmek veya birini dahil
etmemek gibi bir durum söz konusu deðil. Tüm overloadlar türemiþ sýnýfýn interface'ine katýlýr.
 

/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
protected:
	void func()
	{
		std::cout << "Base::func()" << std::endl ;
	}
	void func(int) {
		std::cout << "Base::func(int)" << std::endl;
	}
	void func(double)
	{
		std::cout << "Base::func(double)" << std::endl;
	}
	void func(int, int)
	{
		std::cout << "Base::func(int, int)" << std::endl;
	}
};
class Der : public Base {
public:
	using Base::func;
	void func(int)
	{
		std::cout << "Der::func(int)" << std::endl;
	}
};
 /////////////////////////////////////////////////////////////////////
Burada Der sýnýfýnýn func(int) imzalý bir fonksiyonu var, ayný þekilde Base'in de yine ayný imzaya
sahip bir fonksiyonu var ve Der sýnýfý içinde func ismine dair using bildirimi yapýlýyor.
Der myder; myder.func(5); gibi bir ifadede bir ambiguity durumu oluþmaz, Der sýnýfýnýn int parametreli
func fonksiyonu çaðýrýlýr.

Bazen kalýtýmýn, polimorfizm var ya da yok amaçlarýndan biri extension. Yani davranýþ deðiþikliði 
olmak zorunda deðil. Mesela string sýnýfý ile tamamen ayný bir sýnýf olacak ama interface'inde ekstra
bazý fonksiyonlar var, yapýlmasý gereken kalýtýmla sýnýfý elde etmek ve o fonksiyonlarý eklemek.
Burada aðýrlýklý tema code reuse. Türemiþ sýnýf nesnesi içinde taban sýnýf alt nesnesi var. Türemiþ
sýnýf nesnesi hayata geldiðinde onun içindeki taban sýnýf alt nesnesi de hayata gelir. Türetme yolu
ile oluþturulan sýnýfýn parametreli olan constrcutorlarýnýn da taban sýnýfýn constructorlarý ile 
ayný olmasý için ne kadar constructor varsa türemiþ sýnýf ayný parametrik yapýda constructorlar 
tanýmlar, türemiþ sýnýfýn bu ctorlarý member initializer list ile taban sýnýfýn constrcuctorlarýný
çaðýrýr. Eðer çaðýrmazsa türemiþ sýnýf nesnesi hayata geldiðinde taban sýnýf alt nesnesine argüman
geçilmemiþ olur, bu da error. Bu gibi durumlarda bu amaçla bir türetme yapýldýðýnda aslýnda amaç
sadece bir fonksiyon eklemek ama tüm constructorlarýn da tekrar yazýlmasý gerekiyordu.
Yukarýdaki using özelliði eskiden constructorlara uygulanamýyordu þimdi C++11 ile birlikte artýk
ctorlara da uygulanabiliyor. Programcý o constructorlarý yazma zahmetinden kurtulmuþ oldu.
C++11 ile gelen bu özelliðe inherited constructor denir. 

/////////////////////////////////////////////////////////////////////
using namespace std;
class Fighter {
public:
	Fighter(const std::string &name, int age);
	Fighter(int wpcnt, const std::string &name);
	Fighter(const std::string &fathername);
	//////
	void run();
	void jump();
	void shoot();
};

class XFighter : public Fighter {
public:
	void strangle();
};
int main() {

	XFighter xf{"Murtaza", 34}; //geçersiz
}
/////////////////////////////////////////////////////////////////////
Derleyici main'deki ifadeye bakar, XFighter'in böyle bir constructor'ý olmadýðýn görür.
Kurallara göre XFighter sýnýfýnýn sadece default constructor'ý var. Sadece strangle() fonksiyonunu
eklemek için bile bu extension yapýlsa dahi Fighter sýnýfýnýn constructorlarýnýn taban sýnýfýn
ctorlarý içinde çaðýrýlmasý gerekiyor. Eski C++ olsa Fighter'ýn ctorlarý ayný þekilde sadece isimleri
deðiþtirilerek türemiþ sýnýfa konulurdu. MIL sentaksý ile de her ctor için taban sýnýfýn ctor'u ayný
argüman ile çaðýrýlýrdý.


Modern C++'daa diðer fonksiyonlar için nasýl using bildirimi yapýlýyorsa burada da using bildirimi
yapýlýr, gerisini derleyici halleder.
/////////////////////////////////////////////////////////////////////
using namespace std;
class Fighter {
public:
	Fighter(const std::string &name, int age) {}
	Fighter(int wpcnt, const std::string &name) {}
	Fighter(const std::string &fathername) {}
	//////
	void run();
	void jump();
	void shoot();
};

class XFighter : public Fighter {
public:
	using Fighter::Fighter;

	void strangle();
};
int main() {

	XFighter xf{"Mehmet"};
}
/////////////////////////////////////////////////////////////////////

Taban sýnýfýn protected bölümünü kendi türemiþ sýnýfýmýzýn public bölümüne eklemek istediðimizde bu
iþ için using bildirimini kullanabiliriz. Ancak private bölüm için böyle bir imkan yok.


Final Anahtar Sözcüðü
Final anahtar sözcüðü Java, C# dillerinde zaten olan bir anahtar sözcüktü, C++'a ise 2011 standartlarý
ile geldi. Bir kalýtým hiyerarþisinde bazen kalýtým yolu ile elde edilen sýnýftan artýk kalýtým yolu
ile yeni sýnýflar elde edilemesin istenebilir. Bunun farklý nedenleri olabilir, eskiden dilin sentaksý
derleyiciye böyle bir kontrol yükümlülüðü vermediði için C++11 öncesi yorum satýrý ile final yazýlýyordu.
Yani kavramsal olarak final yine vardý ama dilin sentaksýnýn bir parçasý deðildi.
C++11 ile final anahtar sözcüðü ile bu derleyicinin kontrolüne tabii tutulur. Ýki ayrý kullanýmý var,
ilki sýnýfýn kendisini final yapmak bu durumda artýk bu sýnýftan kalýtým yolu ile baþka bir sýnýf
oluþturulamasýn. Diðeri ise final override, yani taban sýnýfýn bir sanal fonksiyonu override ediliyor,
taban sýnýfýn bir sanal fonksiyonu override edildiðinde bizim fonksiyonumuz da sanal olur, bizdek sonraki
sýnýflara da override hakký verilmiþ olur bunu final yaptýðýmýzda artýk türetme yapýlabilir ama 
türetilen sýnýflar bu fonksiyonu override edemez, override etme giriþimi sentaks hatasý.

/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
};

class Der final : public Base {
public:
};

class SDer : public Der { //sentaks hatasý
public:
};
/////////////////////////////////////////////////////////////////////
Der sýnýfý final olarak deklare edildiðinden kendisinden türetme yolu ile sýnýf elde edilemez.


/////////////////////////////////////////////////////////////////////
using namespace std;
class Base {
public:
	virtual void func();
};

class Der : public Base {
public:
	void func()final override;
};

class SDer : public Der {
public:
	void func()override; //geçersiz
};
/////////////////////////////////////////////////////////////////////
Der sýnýfýnýn func fonksiyonu final ile nitelendirildiðinden, ondan türeyen sýnýflarýn bu fonksiyonu
override etmesi sentaks hatasý. final anahtar sözcüðü override anahtar sözcüðünden önce gelmek zorunda.


/////////////////////////////////////////////////////////////////////
int main() {

	int final = 0;
	int override = 10;
}
/////////////////////////////////////////////////////////////////////
Týpký override anahtar sözcüðü gibi, final anahtar sözcüðü de contextual keyword, identifier olmasý
geçerli.



28_OCAK_2018_PAZAR

Polimorfik Liste

/////////////////////////////////////////////////////////////////////
#include <ostream>
#include <iostream>
#include <string>
#include <iomanip>
#include <vector>
#include <ctime>
#include <cmath>
#include <sstream>

void randomize()
{
	srand(static_cast<unsigned>(time(nullptr)));
}

using namespace std;
class Shape {
public:
	virtual double getArea()const = 0;		  //Alan bilgisi
	virtual double getPerimeter()const = 0;   //Çevre Bilgisi
	virtual std::string getValues()const = 0; //Þekle dair önemli bilgiler
	virtual std::string getName()const = 0;	  //Þeklin ismi
};

class Square final : public Shape {
	double m_side;
public:
	Square(double side) : m_side{side} {}
	virtual double getArea()const override { return m_side * m_side; }
	virtual double getPerimeter()const override { return 4. * m_side; }
	virtual std::string getValues()const override 
	{
		std::ostringstream oss;
		oss << "Kenar    : " << m_side;
		return oss.str(); //belleðe yazýlan yazýyý string nesnesi olarak geri verir.
	}
	virtual std::string getName()const override { return "Kare"; }
};

class Rectangle final : public Shape {
	double m_side1, m_side2;
public:
	Rectangle(double side1, double side2) : m_side1{ side1 }, m_side2{ side2 } {}
	virtual double getArea()const override { return m_side1 * m_side2; }
	virtual double getPerimeter()const override { return 2. * (m_side1 + m_side2); }
	virtual std::string getValues()const override
	{
		std::ostringstream oss;
		oss << "Kenar 1  : " << m_side1 << std::endl;
		oss << "Kenar 2  : " << m_side2;
		return oss.str();
	}
	virtual std::string getName()const override { return "Dikdortgen"; }
};

class Triangle final : public Shape {
	double m_side1, m_side2, m_side3;
public:
	Triangle(double side1, double side2, double side3) : m_side1{ side1 }, m_side2{ side2 }, m_side3{side3} {}
	virtual double getArea()const override 
	{
		double u = getPerimeter() / 2;
		return sqrt(u * (u - m_side1) * (u - m_side2) * (u - m_side3));
	}
	virtual double getPerimeter()const override { return m_side1 + m_side2 + m_side3; }
	virtual std::string getValues()const override
	{
		std::ostringstream oss;
		oss << "Kenar 1  : " << m_side1 << std::endl;
		oss << "Kenar 2  : " << m_side2 << std::endl;
		oss << "Kenar 3  : " << m_side3;
		return oss.str();
	}
	virtual std::string getName()const override { return "Ucgen"; }
};

enum Eshape {RECTANGLE, SQUARE, TRIANGLE, CIRCLE};

class Circle final : public Shape {
	double m_radius;
public:
	Circle(double r) : m_radius{ r } {}
	virtual double getArea()const override{ return 3.1415928 * m_radius * m_radius; }
	virtual double getPerimeter()const override { return 2. * 3.1415928 * m_radius; }
	virtual std::string getValues()const override
	{
		std::ostringstream oss;
		oss << "Yaricap  : " << m_radius;
		return oss.str();
	}
	virtual std::string getName()const override { return "Daire"; }
};

void displayShapeInfo(std::ostream &os, const Shape &s)
{
	os << "Sekil : " << s.getName() << endl;
	os << "Degerler : " << endl;
	os << s.getValues() << endl;
	os << "Alan     : " << s.getArea() << endl;
	os << "Cevre    : " << s.getPerimeter() << endl;
	os << "**********************************************************" << endl;
}

void randomize()
{
	srand(static_cast<unsigned>(time(nullptr)));
}

double drand()
{
	return rand() % 10 + 1 + static_cast<double>(rand() / RAND_MAX);
}

bool isTriangle(double d1, double d2, double d3)
{
	return abs(d1 - d2) < d3 && d1 + d2 > d3 &&
		   abs(d1 - d3) < d2 && d1 + d3 > d2 &&
		   abs(d3 - d2) < d1 && d3 + d2 > d1;
}

void getRandomTriangle(double &d1, double &d2, double &d3)
{
	while (d1 = drand(), d2 = drand(), d3 = drand(), !isTriangle(d1, d2, d3))
		;
}

Shape *createRandomShape()
{
	double d1, d2, d3;

	switch (rand() % 4) {
	case Eshape::SQUARE:    return new Square{ drand() }; 
	case Eshape::RECTANGLE: return new Rectangle{ drand(), drand() };
	case Eshape::CIRCLE:    return new Circle{ drand() };
	case Eshape::TRIANGLE:  
		getRandomTriangle(d1, d2, d3);
		return new Triangle(d1, d2, d3);
	}
}

int main() {

	vector<Shape *> spvec;
	randomize();

	for (int k = 0; k < 1000; ++k)
		spvec.push_back(createRandomShape());

	for (const auto &sp : spvec) {
		displayShapeInfo(cout, *sp);
		getchar();
	}

}
/////////////////////////////////////////////////////////////////////
Bizim bir çizim programýnda bazý þekillerimiz olsun. Bu þekiller ortak bazý iþlemlere tabi
tutuluyor olsun. Þekillere iliþkin alan ve çevre bilgisi hesaplanabilir, her þeklin sonuçta bir
alan ve çevresi var, bunlar ortak interface'de tutulabilir.
Shape sýnýfý abstract bir sýnýf bu durumda Shape sýnýfýndan kalýtým yolu ile elde edilecek sýnýflar
ya Shape sýnýfýnýn pure virtual fonksiyonlarýný override eder veya türetme ile elde edilen sýnýflar
da ancak abstract olarak kullanýlabilir.
Shape sýnýfýnýn fonksiyonlarý pure virtual fonksiyonlar. Shape sýnýfýndan türetilecek olan sýnýflar
bu fonksiyonlarý override edecekler.
displayShapeInfo fonksiyonu polimorfik iþlem yapan global bir fonksiyon.
Henüz türetme yolu ile Shape sýnýfýndan sýnýflar elde edilmeden dahi main'deki kodlar çalýþýr halde,
türetme ile yeni sýnýflar elde edildiðinde bu eski kodlar yeni sýnýflar için kullanýlabilecek.
Sýnýflar için destructor yazmaya gerek yok, derleyicinin yazacaðý destructor burada zaten yeterli
çünkü sýnýflar kaynak tüketmiyor.
Shape sýnýfýndan kalýtým yolu ile Square elde etmemiz, Square sýnýfýna yeni fonksiyonlar ekleyemeyeceðimiz
anlamýna gelmez ama eklenen yeni fonksiyonlar Polimorfik iþleme kullanýlamazlar çünkü polimorfik
iþleme super class'a göre yapýlýr, eklenen baþka fonksiyonlar ancak Square'in interface'ini alanlar
kullanabilir.
Nasýl cout bir ostream nesnesi ise, ayný sýnýftan türetilmiþ ismi ostringstream olan bir sýnýf var,
bu sýnýf belleðe yazma iþlemleri için oluþturulmuþ bir sýnýf, C'deki sprintf'in yaptýðýný yapar.
Square sýnýfýnýn getName fonksiyonunda geri dönüþ deðeri olarak return string{"Kare"}; þeklinde bir
kod da yazýlabilirdi ancak böyle yazýlmasýna gerek yok. String sýnýfýnýn zaten explicit olmayan
const char * bir constructor'ý olduðu için doðrudan return "Kare"; ile de geri dönülebilir. 
Bu ifade bir string literali döndürüldüðü anlamýna gelmez, string literalini sadece geri döndürmek
istediðimi string nesnesini initialize etmek ile onun constructorýna argüman olarak göndermiþ oluruz.
Biz containerlara koyduk ancak containerlara adres koyduk yani biz dinamik nesnenin kendisini deðil,
dinamik nesneyi kontrol eden pointerlarý containera koyduk. Pointer deðil de smart pointer'ý koysaydýk
bu durumda smart pointer'ýn hayatý bittiðinde dinamik nesnenin de hayatý bitmiþ olacaktý.
Vektör ile iþimiz ne zaman bitse, vektör smart pointerlarý delete eder, smart pointerlar da bu
dinamik nesneleri delete eder. Hatta eðer unique ptr yerine shared ptr sýnýfýný kullansak o zaman
bu dinamik nesneleri diyelim ki 10 ayrý containerda iþleme sokabilir ama 10 ayrý containerda aslýnda
ayný nesneyi kullanmýþ olur.


MULTIPLE INHERITANCE(ÇOKLU KALITIM)

Tek bir kalýtým iþlemi ile birden fazla sýnýfýn public interface'ini kendi interface'imize katabiliriz.
Çoklu Kalýtýmýn mutlaka public inheritance olmasý gerekmiyor, private ya da protected kalýtýmýnda da 
çoklu kalýtým kullanýlanýlabilir.
Ortada Fax ve Modem sýnýfý olsun, tek bir türetme ile hem Fax hem de Modem sýnýfýnýn interface'ini kendi
interface'ine katacak bir FaxModem sýnýfý oluþturabiliriz. Artýk FaxModem'in clientlarý hem Fax'dan hem de 
Modem'den gelen interface'i kullanabilirler. Yalnýzca iki deðil daha fazla sýnýftan da kalýtým yolu ile
sýnýf oluþturulabilir. Birinden public diðerinden private diðerinden de protected kalýtým da yapýlabilir.
Kalýtým tipi ne olursa olsun hepsinde sanal fonksiyonlar override edilebilir bu konuda bir engel yok.
Yani FaxModem sýnýfý hem Fax'ýn hem de Modem'in sanal fonksiyonlarýný override edebilir.
Public Kalýtýmýndaki "is a ?" iliþkisi de bozulmuþ deðil, her FaxModem bir Fax'dýr ayný zamanda her 
FaxModem bir Modem. Fax interface'ine dayalý olarak yazýlmýþ bütün polimorfik kodlara FaxModem
gönderilebilir ayný þekilde Modem'e göre yazýlmýþ tüm kodlara da FaxModem gönderilebilir, sonuçta 
FaxModem hem Fax hem de Modem.


/////////////////////////////////////////////////////////////////////
class Base1 {
public:
	void func1();
	void foo1();
	void g1();
};

class Base2 {
public:
	void func2();
	void foo2();
	void g2();
};

class Der : public Base1, public Base2 {

};

int main() {

	Der myder;

	myder.func1();
	myder.func2();

}
/////////////////////////////////////////////////////////////////////
Der, Base1 ve Base2 sýnýflarýndan public türetmesi ile çoklu kalýtýmla elde edilmiþ sýnýf.
Tekli türetmedeki kurallar burada da geçerli;
class Der : public Base1, public Base2 {}; yerine
class Der : Base1, public Base2 {}; yazýlmýþ olsaydý kalýtým yine geçerli olurda ancak Base1'den
private türetmesi ile türetilmiþ olurdu. 
Der bir class deðil de struct olsaydý o zaman default'u public türetmesi olurdu. 
Der türünden bir nesne için Base1 ve Base2'nin tüm fonksiyonlarý çaðýrýlabilir, her iki sýnýfýn
interface'i devralýndý.
Access control ile ilgili kurallar da ayný þekilde geçerli. Bir Der nesnesi yolu ile  Der sýnýfýnýn
public bölümüne eriþilebilir, sýnýfýn private veya protected bölümlerine eriþilemez. Ancak tabi
Der sýnýfýnýn implementasyonu her bir taban sýnýfýn yani Base1 ve Base2'nin protected bölümüne ve
public bölümüne eriþilebilir, taban sýnýflarýn private bölümü kalýtým yolu ile elde edilmiþ sýnýflara
kapalý.


Bir Der nesnesi hayata geldiðinde onun içinde hem Base1 hem de Base2 taban sýnýf alt nesneleri var.
Nasýl tekli kalýtýmda bir türemiþ sýnýf nesnesi içinde bir taban sýnýf alt nesnesi var ise þimdi
türemiþ sýnýf nesnesi içinde çoklu kalýtým ile interface'ini devraldýðý tüm sýnýflar olacak.
Bunlarý kodu yazan construct edecek, etmezse tekli kalýtýmda olduðu gibi derleyici bunlar için
default constructor'ý çaðýrýr ve eðer sýnýfýn default ctor'u yok veya delete edilmiþse bu durumda 
yine ayný þekilde sentaks hatasý. Dolayýsýyla bu sýnýflarýn parametreli constructor'ýnýn çaðýrýlmasý
için bizim ayný þekilde MIL sentaksý ile onlarý initialize etmemiz gerekir. Hangi taban sýnýf 
nesnesinin daha önce yaratýlacaðý bu sefer kalýtýmdaki sýra tarafýndan belirleyici.

/////////////////////////////////////////////////////////////////////
class Base1 {
public:
	Base1()
	{
		std::cout << "Base1::Constructor\n";
	}
};

class Base2 {
public:
	Base2()
	{
		std::cout << "Base2::Constructor\n";
	}
};

class Der : public Base2, public Base1 {

};

int main() {

	Der myder;
}
/////////////////////////////////////////////////////////////////////
myder nesnesi içinde Base1 ve Base2 alt nesnesi var. Construct olma sýralarý yazýlan sýraya göre 
belirlenir. class Der : public Base1, public Base2 {}; olsaydý tam tersi sýra ile hayata gelirlerdi.


Çoklu Kalýtýmda compile time'a yönelik karþýlaþýlan problemlerden biri isim çakýþmasý.
/////////////////////////////////////////////////////////////////////
class Base1 {
public:
	void func() {}
};

class Base2 {
public:
	void func(int) {}
};

class Der : public Base1, public Base2 {

};

int main() {

	Der myder;

	myder.func(12); //"Der::func()" is ambigious

	myder.Base1::func();   //geçerli
	myder.Base2::func(10); //geçerli
}
/////////////////////////////////////////////////////////////////////
Buradaki kural tamamen name look up ile ilgili. Çoklu türetmede isim arama þu þekilde yapýlýr:
Örneðin ok, nokta veya çözünürlük operatörünün saðýndaki isim burada nokta operatörünün saðýnda
kullanýldý. Her zaman olduðu gibi önce Der sýnýfý içinde aranýr, burada bulunsaydý isim aramaya
yönelik bir sentaks hatasý oluþmazdý. Bulunamadýðý zaman isim arama bir sýraya göre yapýlmaz.
Çoklu türetmede bütün taban sýnýflar isim arama açýsýndan ayný hakka sahipler birbirlerine göre
üstünlük yok. Dolayýsý ile ister fonksiyon ismi ister baþka isim olsun, isim nitelenmeden kullanýlýrsa
derleyici ambiguity hatasý verir, farklý scopelarda ayný iki isim olmuþ olur ancak birbirlerine 
göre seçicilikleri yok. Hata func isminin kullanýmýna iliþkin deðil. Hata argüman hatasý deðil,
derleyici daha hangi func'ý seçeceðini anlamaz.

Türemiþ sýnýf yolu ile, nokta operatörünün - ok operatörünün - çözünürlük operatörünün saðýnda
kullanýldýðýnda veya türemiþ sýnýfýn üye fonksiyonu içinde nitelemeden bu isim kullanýldýðýnda eðer
bir isim çakýþmasý varsa niteleme yapýlmadýðýnda derleyici ismi bulamaz.


/////////////////////////////////////////////////////////////////////
class Base1 {
public:
	void func() {}
};

class Base2 {
public:
	void func(int) {}
};

class Der : public Base1, public Base2 {
public:
	void g()
	{
		func(12); //geçersiz, name look-up hatasý
		Base1::func();
		Base2::func(12);
	}
};
/////////////////////////////////////////////////////////////////////
Yine yaný þekilde isim arama hatasý. Yine isim önce blokta aranýr ancak bulunamaz, class scope'da
da bulunamaz. Bu sefer taban sýnýflarda arar, ancak aramada bir sýra olmadýðýndan her ikisinde de 
ayný isim olduðundan ambiguity hatasý. Yine taban sýnýflarýn ismi ile nitelendirildiklerinde geçerli.



/////////////////////////////////////////////////////////////////////
void gfunc1(Base1 &);
void gfunc2(Base2 &);

int main() {

	Der myder;

	gfunc1(myder); //geçerli
	gfunc2(myder); //geçerli
}
/////////////////////////////////////////////////////////////////////
Upcasting ile ilgili kurallar ayný þekilde geçerli herhangi bir problem yok.



/////////////////////////////////////////////////////////////////////
class Base1 {
public:
	virtual void vf1() = 0;
};

class Base2 {
public:
	virtual void vf2() = 0;
};

class Der : public Base1, public Base2 {
public:
	void vf1()override{}
	void vf2()override{}

};

int main() {

	Der myder;
}
/////////////////////////////////////////////////////////////////////
Base1 ve Base2'nin sanal fonksiyonlarý olabilir. Der sýnýfýnýn concrete olmasý için her iki taban
sýnýfýn bütün sanal fonksiyonlarýný override etmesi gerekir yoksa Der sýnýfý abstract olarak kalýr.


RunTime'a Ýliþkin Problemli Durum:
Þöyle bir çoklu kalýtým gerçekleþtirilmiþ olalým, yine Fax ve Modem sýnýflarýndan çoklu kalýtým
yolu ile FaxModem sýnýfý türetme yolu ile elde edilmiþ olsun. Ancak bu sefer Fax ve Modem sýnýflarý da
Device denilen bir sýnýftan kalýtým yolu ile türetilmiþ olsunlar. Bu çok sýk karþýlaþýlan bir pattern.
Çoðu zaman böyle Fax ve Modem sýnýflarýndan çoklu kalýtým yolu ile bir sýnýf oluþturulur ayný zamanda
o Fax ve Modem sýnýflarý da bir sýnýftan türetme yolu ile elde edilmiþ sýnýflar olur.
Standart Kütüphane de buna örnek. En tepede ismi ios_base olan bir sýnýf var, ios_base sýnýfý giriþ
çýkýþ iþlemleri hiyerarþisindeki en tepedeki sýnýf ve bir template deðil, bildiðimiz bir sýnýf.
ios_base sýnýfýndan public kalýtýmý ile basic_ios isimli bir sýnýf oluþturulmuþ. basic_ios'daki 
interface halen söz konusu akýmýn giriþ iþlemlerinde mi yoksa çýkýþ iþlemlerinde mi kullanýlacak
bir akým olduðuna baðlý deðil, yani giriþ iþlemleri için de çýkýþ iþlemleri için de kullanacak olsak
basic_ios interface'ine ihtiyacýmýz var. Giriþ - Çýkýþ iþlemleri ise buradan sonraki türetmede 
özelleþtiriliyor. Buraya kadar interface ortak buradan sonra ise giriþ ve çýkýþ akýmlarýný kontrol
edecek sýnýflarýn interface'i farklýlaþýyor. basic_ios sýnýfýndan iki tane türetme yapýlmýþ;
basic_osteram ve basic_istream. basic_ostream çýkýþ akýmlarý için basic_istream ise giriþ akýmlarý
için. ostream, basic_ostream'in char açýlýmýnýn typedef ismi, isteram ise basic_istram'in char
açýlýmýnýn typedef ismi. Öyle giriþ çýkýþ iþlemleri var ki ayný akým hem giriþ hem de çýkýþ için
kullanýlacak, mesela C'deki ayný dosya üzerinde hem okuma hem yazma iþlemi yapýlmasý. Bu gibi 
durumlarda her iki interface'in de devralýnmasý gerkiyor. Multiple inheritance ile basic_ostream ve
basic_istream sýnýflarýndan türetme yolu ile basic_iostream sýnýfý türetilmiþ. basic_iostream
sýnýfýnýn da typedef ismi iostream. En tepedeki ios_base sýnýfý dýþýndaki tüm sýnýflar class template.
Mesela belleðe yazma sýnýflarý basic_istream'den türetilmiþtir. Yazma amaçlý dosyalarý yönetmek için
kullanýlan offstraem sýnýfý, basic_ostream'den türetme yolu ile elde edilmiþtir. Okuma amaçlý
dosyalarý yönetmek için kullanýlan iffstraem sýnýfý, basic_istream sýnýfýndan türetilmiþtir.
Hem okuma hem yazma amaçlý dosyalarý yönetmek için kullanýlan fstraem sýnýfý ise basic_iostream'den
türetme yolu ile elde edilmiþtir. Ýþte bu diamond formation, elmas formasyonuna örnek.

Bizim örneðimizde Fax ve Modem sýnýfýndan türetme yolu ile FaxModem sýnýfý elde edildi. Ayný zamanda
Fax ve Modem sýnýflarý da ortak bir sýnýftan türetilmiþ olurlarsa bu diamond formation.
Aslýnda ortada bir problem yok, problem tamamen kullaným ile ilgili yani nasýl kullanýlacaðý ile ilgili.
Burada iki olanak var, dil bu iki olanaktan hangisinin seçileceðini kodu yazana býrakýyor. Birinci
olanak þu, öyle bir FaxModem oluþturulabilir ki içinde iki tane Device olabilir biri Fax sýnýfýndan
gelen Device diðeri ise Modem sýnýfýndan gelen Device. Ýkinci olanak ise bunlarýn ayrý iki Device'larýnýn
olmamasý, bir tane Device olmasý. Fax da ayný Device'ý kullanýyor, Modem de ayný Device'ý kullanýyor olsun.
Diamond Formation sanki bir hataymýþ gibi düþünülebiliyor, ancak bir hata deðil bir karar verme noktasý.
Gerçekten Fax kendi Device'ýný Modem kendi Device'ýný kullanýyor olabilir. Ýçinde Fax ve Modem ayrý ancak
ortak bir Device'ý da kullanýyor olabilir. Önemli olan bizim çoklu kalýtým ile elde ettiðimizin hangi
modeli temsil edecekse ona uygun bir sentaksý seçmemiz. Uygulamada en çok yapýlan hata programcý ortak bir
Device ister ancak dilin sentaksýný doðru kullanamadýðýndan Fax'ýn içinde ayrý Modem'in içinde ayrý bir
Device elde eder. Tek bir Device olarak düþündüðünden Fax tarafýndan Device'ý açar, Modem'i kullanmak 
istediðinde ise Modem çalýþmaz çünkü Modem'in Device'ý açýlmamýþ olur, programcý yazdýðý kodun ortak bir
Device'ý kullandýðý yanýlgýsýna düþer. Bunun sonucunda hem compile time'a yönelik bazý statik problemler
hem de run time'a yönelik problem oluþur.

Her ne kadar tek olma ihtiyacý ayrý ayrý olma ihtiyacýna göre çok daha yüksek olsa da dilin default'u
ayrý ayrý olmasýna yönelik. Çoklu kalýtým default þekilde býrakýlýrsa Fax'da da bir Device olmuþ olur,
Modem'de de bir Device olmuþ olur. Çoðu durumda ortak taban sýnýfýn tek olmasý istenir.


/////////////////////////////////////////////////////////////////////
class Device {
public:
	void turn_off() {}
	void turn_on() {}
};

class Fax : public Device {
public:
};

class Modem : public Device{
public:
};

class FaxModem : public Fax, public Modem {
public:
};

int main() {

	FaxModem fm;

	fm.turn_on(); //geçersiz, ambiguity 

	fm.Fax::turn_on();
	fm.Modem::turn_on();

}
/////////////////////////////////////////////////////////////////////
Farkýnda olunmasa da burada iki tane Device var. Device açýlýyor veya kapanýyor ancak hangi
Device olduðu belli deðil yani Fax'ýn Device'ý mý yoksa Modem'in Device'ý mý.
FaxModem türünden fm nesnesinin içinde iki tane ayrý Device var. turn_on fonksiyonu bir this
pointer'ýna sahip bu this pointer'ý Device *this dolayýsýyla derleyici bir taban sýnýf nesnesinin
adresini turn_on'a geçer ama elinde iki tane taban sýnýf nesnesi adresi var. Derleyici Fax'dan
gelen Device'ýn adresini mi yoksa Modem'den gelen Device'ýn adresini mi this pointerý olarak kullanýp
fonksiyona geçecek, bunu bilemiyor.
Derleyici çift anlamlýlýk, ambiguity hatasý verir.
Eðer gerçekten de FaxModem de iki Device olacaksa yani modellemek istenen buysa bunun kod karþýlýðý
kullanýrken nitelemek, baþka yolu yok.


/////////////////////////////////////////////////////////////////////
class Device {
public:
	void turn_off() {}
	void turn_on() {}
};

class Fax : public Device {
public:
};

class Modem : public Device{
public:
};

class FaxModem : public Fax, public Modem {
public:
	void check()
	{
		turn_on(); //geçersiz, ambiguity
		Fax::turn_on();   //geçerli
		Modem::turn_on(); //geçerli
		static_cast<Modem *>(this)->turn_on(); //geçerli
	}
};
/////////////////////////////////////////////////////////////////////
Taban sýnýfýn üye fonksiyonu çaðýrýldýðýnda derleyici bunu yine this->turn_on() olarak alýr ve
turn_on() fonksiyonuna normalde yine türemiþ sýnýf nesnesinin içindeki taban sýnýf alt nesnesinin
adresini geçecek ancak yine ayný þekilde iki tane olduðundan geçersiz.


/////////////////////////////////////////////////////////////////////
class Device {
public:
	void turn_off() {}
	void turn_on() {}
};

class Fax : public Device {
public:
};

class Modem : public Device{
public:
};

class FaxModem : public Fax, public Modem {
public:

};

void func(Device &);

int main() {

	FaxModem fm;

	func(fm); //geçersiz
	func(static_cast<Fax &>(fm)); //geçerli
	func(static_cast<Modem &>(fm)); //geçerli
}
/////////////////////////////////////////////////////////////////////
func fonksiyonunun parametresi Device, FaxModem de ayný zamanda bir Device olduðundan fonksiyona
FaxModem sýnýfý türünden bir nesne geçiliyor ancak yine ayný nedenden dolayý geçersiz.
Yine derleyicinin bu çaðrý ile hangi Device'ý kullanacaðýný anlama þansý yok.
Türetme hiyerarþisi içinde fonksiyona bir sýnýf gönderildiðinde derleyicinin hangi taban sýnýf alt
nesnesini kullanacaðýný bilmesi gerekir. FaxModem'in içinde iki tane Device olacaðýndan derleyici
bu fonksiyona hangi Device'ý geçeceðini bilemez.


/////////////////////////////////////////////////////////////////////
class Device {
	bool m_on_flag;
public:
	Device() : m_on_flag{ false } {}
	bool is_on()const { return m_on_flag; }
	void turn_on() {
		m_on_flag = true;
		std::cout << "cihaz acildi..." << std::endl;
	};
	void turn_off() { 
		m_on_flag = false;
		std::cout << "cihaz kapandi..." << std::endl;
	}
};

class Fax : public Device {
public:
	void sendFax()
	{
		if (!is_on()) {
			std::cout << "Cihaz kapali oldugundan fax gonderilemiyor..." << std::endl;
			std::cout << "Cihazi aciniz..." << std::endl;
		}
		else
			std::cout << "Fax gonderildi..." << std::endl;
	}
};

class Modem : public Device{
public:
	void sendData()
	{
		if (!is_on()) {
			std::cout << "Cihaz kapali oldugundan data gonderilemiyor..." << std::endl;
			std::cout << "Cihazi aciniz..." << std::endl;
		}
		else
			std::cout << "Data gonderildi..." << std::endl;
	}
};

class FaxModem : public Fax, public Modem {
public:
};

int main() {

	FaxModem fm;

	fm.Fax::turn_on();
	fm.sendData();
}
/////////////////////////////////////////////////////////////////////
Programcý tek bir Device var gibi düþünüyor ancak program çalýþtýðýnda, cihaz kapalý olduðundan
data gonderilemiyor, cihazi aciniz yazýsýnýn çýktýðý görülüyor. Cihaz aslýnda açýldý ama açýlan
cihaz o cihaz deðil. Fax'ýn Device'ý açýldý ancak, Modem'in Device'ý halen kapalý.



C++'da ortak taban sýnýf nesnesinin sayýsýný teke indirmek için kullanýlan yapýya virtual inheritance
denir. Tek yapýlmasý gereken Fax ve Modem sýnýflarýný Device sýnýfýndan türetirken bu isteðin belirtilmesi.
Yani Fax ve Modem sýnýfýndan bir kalýtým yapýldýðýnda, bu base class'dan yani Device sýnýfýndan kalýtým 
yolu ile elde edilecek sýnýflarda bir tane base class alt nesnesi, Device sýnýfý alt nesnesi olsun.
Bu ricada bulunmasý gereken FaxModem sýnýfý deðil, Fax ve Modem sýnýflarý. Bu anahtar sözcük 
kullanýldýðýnda ne statik problemler kalýr ne de run time'a iliþkin problemler çünkü artýk tek bir 
Device var yani hangi taban sýnýf alt nesnesinin kullanýlacaðý belirli.
Tabi bu durumda çözünürlük operatörüne de gerek kalmamýþ olur.
/////////////////////////////////////////////////////////////////////
class Device {
	bool m_on_flag;
public:
	Device() : m_on_flag{ false } {}
	bool is_on()const { return m_on_flag; }
	void turn_on() {
		m_on_flag = true;
		std::cout << "cihaz acildi..." << std::endl;
	};
	void turn_off() { 
		m_on_flag = false;
		std::cout << "cihaz kapandi..." << std::endl;
	}
};

class Fax : virtual public Device {
public:
	void sendFax()
	{
		if (!is_on()) {
			std::cout << "Cihaz kapali oldugundan fax gonderilemiyor..." << std::endl;
			std::cout << "Cihazi aciniz..." << std::endl;
		}
		else
			std::cout << "Fax gonderildi..." << std::endl;
	}
};

class Modem : virtual public Device{
public:
	void sendData()
	{
		if (!is_on()) {
			std::cout << "Cihaz kapali oldugundan data gonderilemiyor..." << std::endl;
			std::cout << "Cihazi aciniz..." << std::endl;
		}
		else
			std::cout << "Data gonderildi..." << std::endl;
	}
};

class FaxModem : public Fax, public Modem {
public:
};

int main() {

	FaxModem fm;

	fm.turn_on();
	fm.sendData();
	fm.turn_off();
	fm.sendFax();
}
/////////////////////////////////////////////////////////////////////



03_02_2018 CUMARTESÝ

Diamond Formasyonundaki problemin çözümü, eðer bir tane taban sýnýf nesnesi isteniyorsa en tepedeki
sýnýftan türetilmiþ olan sýnýflar için özel bir türetme biçimi kullanýlmasý, virtual inheritance ile
elde edilmeliler. Dilin default'u virtual inheritance deðil, kaç tane taban sýnýf varsa onlarýn hep-
sinden bir tane taban sýnýf alt nesnesi gelmesi. 

Elimizde normal bir kalýtým hiyerarþisi olsa, çoklu kalýtýmla elde edilmiþ deðil;
A<-B<-C<-D: A'dan kalýtým ile B, B'den kalýtým ile C, C'den kalýtým ile D sýnýfý elde edilmiþ olsun.
D için constructor yazýldýðýnda MIL sentaksý ile C construct edilir. D için constructor yazýlýrken
örneðin B'nin construct edilmesine yönelik bir seçim yok, buna yönelik yazýlan kodlar sentaks hatasý.


/////////////////////////////////////////////////////////////////////
class Base {
public:
	Base(int) {};
};

class Der : public Base {
public:
	Der(int x, int y) : Base{ 0 } {};
};

class SDer : public Der {
public:
	SDer(int x) : Base{ x } {}; //doðrudan geçersiz
	//SDer(int x) : Der{x, 5} {};
};
/////////////////////////////////////////////////////////////////////
Base sýnýfýnýn int parametreli constructor'ý var yani default constructor'ý yok.
Base'den kalýtým yoluyla sýnýf elde edildiðinde Base alt nesnesini construct etmek programý
yazanýn sorumluluðunda aksi halde sentaks hatasý. Der sýnýfýndan da bir türetme yapýlýyor.
Her sýnýf Member Initializer List ile sadece kendi doðrudan taban sýnýfýný initialize edebilir. 
SDer içinde Der'in initialize edilmesinde bir sorun yok zaten default yoksa yapýlmalý. Ama 
Der'in üstündeki indirect base class'larý SDer içinde initialize etme yükümlülüðü programcýda 
deðil ki zaten yapmaya kalktýðýmýzda sentaks hatasý


Bunun bir istisnasý var, virtual inheritance. Virtual Inheritance'da bir problem var.
(Device sýnýfýndan Fax ve Modem, bu ikisinden FaxModem türetme yolu ile elde edilmiþtir.)
Hiyerarþi daha aþaðýya doðru da gidebilir. Yani FaxModem sýnýfýndan da türetme yolu ile bir sýnýf
türetilebilir, bu sýnýfýn ismi de FastModem olsun. FaxModem ve onun altýndaki sýnýf nesnelerinin 
içinde bir tane Device var, bu Device bir þekilde construct edilecek. FastModem'de FaxModem initialize
edilir, FaxModem; Fax'ý ve Modem'i initialize eder. Peki bu Device'ý kim initialize edecek ?
Þimdi bunlardan birer tane olsaydý, Fax kendi Device'ýný itialize ederdi; Modem de kendi Device'ýný
initialize ederdi. Eðer Device'ýn default ctor'u olsa onda da bir problem yok eðer derleyiciye býrakýlsa
derleyici normal görevi olarak default ctor'u çaðýrýr. Ancak enteresan problem ise, eðer sanal türetme
uygulandýysa bu Device'dan bir tane, bir de bunun parametreli bir ctor'unun çaðrýlmasý gerekiyorsa bunu
kimin initialize edeceði problemi ? Bir yandan Fax'ýn ve Modem'in ayrý ayrý Device'ý initialize etmesi
gerekir ki Fax ve Modem olarak kullanýlabilsinler. Ama sanal türetmeden sonraki sýnýflarýn da doðal 
olarak bir Device'a sahip olmalarý gerekir bu Device'ý kim construct edecek ? 
Sanal türetmeye yönelik bir durum, bu durumda türetme hiyerarþisi içindeki bütün sýnýflar Device'ý
kendileri construct edecekler. Fax'a ve Modem'e býrakýlmaz. FaxModem Device'ý da kendi initialize 
edecek(Normalde Fax ve Modem'i initialize ediyordu). FasModem yine ayný þekilde Device'ý initialize
edecek. Türetme hiyerarþisinde kaçýncý sýnýf olduðu önemli deðil, en altta da olsa MIL sentaksý ile
Device'ýn construct'ýný çaðýracak. Tabi unutulmamalý ki buradaki ctor, parametreli ctor. Eðer ki 
default ctor varsa ve o çaðýrýlacaksa zaten ortada problemli bir durum yok.


Device sýnýfýnýn default ctor'una çaðrý yapýlacaðýndan dolayý geçerli.
Ancak eðer Device sýnýfýnýn parametreli bir ctor'u olsaydý kod geçersiz olurdu. Çünkü FaxModem sýnýfýnýn
default ctor'u delete edilmiþ durumda.
//////////////////////////////////////////////////////////////////
class Device {
public:
};

class Fax : virtual public Device {
public:
};

class Modem : virtual public Device {
public:
};

class FaxModem : public Fax, public Modem {
public:
};

int main(void)
{
	FaxModem fm; //geçerli

	return 0;
}
//////////////////////////////////////////////////////////////////


Fax ve FaxModem sýnýflarýnýn içindeki Device'ý construct edilmedi.
Device sýnýfýnýn default Ctor'ý yok.
Bu þekilde býrakýlýrsa Device'dan sonraki tüm sýnýflarýn ctor'larý delete edilmiþ olur.
//////////////////////////////////////////////////////////////////
class Device {
public:
	Device(int x)
	{
		cout << "Device(int)" << endl;
	}
};

class Fax : virtual public Device {
public:
};

class Modem : virtual public Device {
public:
};

class FaxModem : public Fax, public Modem {
public:
};

int main(void)
{
	FaxModem fm; //geçersiz
	Fax f; // geçersiz

	return 0;
}
//////////////////////////////////////////////////////////////////


Fax'ý legal hale getirmek için, Fax'ýn herhangi bir ctor'u; Device'ýn ctor'unu MIL sentaksý ile
çaðýrmak zorunda.
Önce Fax'ýn ctor'ý çaðýrýldý, onun ana bloðuna girmeden Device'ýn ctor'ý çaðrýldý.
Ayný þekilde Modem sýnýfý için de ilgili ctor yazýlabilir.
//////////////////////////////////////////////////////////////////
class Device {
public:
	Device(int x)
	{
		cout << "Device(int)" << endl;
		cout << "x = " << x << endl;
		cout << endl;
	}
};

class Fax : virtual public Device {
public:
	Fax() : Device{12}
	{
		cout << "Fax(int)" << endl;
	}
};

int main(void)
{
	Fax f;

	return 0;
}
//////////////////////////////////////////////////////////////////


FaxModem sýnýfý düþünüldüðünde, aslýnda Modem sýnýfýnýn default ctor'ý var, Fax sýnýfýnýn da 
default ctor'ý var. Yani sanal kalýtým söz konusu olmasaydý FaxModem sýnýfý türünden bir nesnenin
oluþturulmasýnda bir problem olmazdý.
Ancak maindeki FaxModem fm; ifadesi geçersiz. Aslýnda FaxModem sýnýfý Fax ve Modem'den çoklu 
kalýtým ile elde edildi, derleyici FaxModem sýnýfý için default constructor'ý yazar. Fax'ýn ve 
Modem'in default ctor'ý da var, aslýnda problem yok gibi görünüyor ancak virtual inheritance 
olduðunda problem söz konusu.
//////////////////////////////////////////////////////////////////
class Device {
public:
	Device(int x)
	{
		cout << "Device(int)" << endl;
		cout << "x = " << x << endl;
		cout << "********************" <<endl;
	}
};

class Fax : virtual public Device {
public:
	Fax() : Device{12}
	{
		cout << "Fax(int)" << endl;
	}
};

class Modem : virtual public Device {
public:
	Modem() : Device{ 132 }
	{
		cout << "Modem(int)" << endl;
	}
};

class FaxModem : public Fax, public Modem {
public:
};

int main(void)
{ 
	FaxModem fm; //sentaks hatasý

	return 0;
}
//////////////////////////////////////////////////////////////////


Problemi çözmek için, FaxModem sýnýfýnýn hangi ctor'ý olursa olsun(default veya parametreli fark
etmez) Device sýnýfýný MIL sentaksi ile initialize etmeli.
//////////////////////////////////////////////////////////////////
class Device {
public:
	Device(int x)
	{
		cout << "Device(int)" << endl;
		cout << "x = " << x << endl;
		cout << "********************" <<endl;
	}
};

class Fax : virtual public Device {
public:
	Fax() : Device{12}
	{
		cout << "Fax(int)" << endl;
	}
};

class Modem : virtual public Device {
public:
	Modem() : Device{ 132 }
	{
		cout << "Modem(int)" << endl;
	}
};

class FaxModem : public Fax, public Modem {
public:
	FaxModem() : Device{987} {}
};

int main(void)
{ 
	FaxModem fm; //geçerli

	return 0;
}
//////////////////////////////////////////////////////////////////
Bu þekilde bir kod olmadýðý sürece türetme hiyerarþisindeki hepsinin constructor'larý delete kabul
edilir. Sanal kalýtým olmasaydý bu kod sentaks hatasý olurdu çünkü Device, FaxModem'in doðrudan
taban sýnýfý deðil. Yukarýdaki kodda Device sýnýfý 987 ile construct edildi, construct iþlemini Fax
veya Modem ile construct edilmiþ olsa 12 veya 132 gelirdi.


SpeedyFM sýnýfý ise FaxModem sýnýfýndan türetildi. FaxModem'in default constructor'ý mevcut.
Diðer sýnýflar gibi bir sýnýf olsaydý SpeedyFM türünden sfm nesnesini oluþturmak geçerli olurdu.
Ancak yine sentaks hatasý. Dilin kurallarýna göre her ne kadar hiyerarþik olarak Device ile SpeedyFM
arasýnda oldukça mesafe olsa da, bir SpeedyFM nesnesi hayata geldiðinde onun içindeki Device'ý yine
SpeedyFm'in kendisi construct etmeli. 
FaxModem'de olduðu gibi SpeedyFM'nin ctor'ý içinde Device'ýn ctor'u MIL sentaksý ile initialize 
edilmeli.
//////////////////////////////////////////////////////////////////
class Device {
public:
	Device(int x)
	{
		cout << "Device(int)" << endl;
		cout << "x = " << x << endl;
		cout << "********************" <<endl;
	}
};

class Fax : virtual public Device {
public:
	Fax() : Device{12}
	{
		cout << "Fax(int)" << endl;
	}
};

class Modem : virtual public Device {
public:
	Modem() : Device{ 132 }
	{
		cout << "Modem(int)" << endl;
	}
};

class FaxModem : public Fax, public Modem {
public:
	FaxModem() : Device{987} {}
};

class SpeedyFM : public FaxModem {
public:
};

int main(void)
{ 
	SpeedyFM sfm; //geçersiz

	return 0;
}
//////////////////////////////////////////////////////////////////


EXCEPTION HANDLING 

Bir program run time'da çalýþýyor ve çalýþýrken programýn iþini yapmasýný engelleyen bazý durumlar
oluþuyor, exception handling bu durumlarýn kontrolü, bu durumlarýn iþlenmesi. Exception Handling
hata arama ile ayný þey deðil. Program çalýþýrken, bir kodlama hatasý yapýldýðýndan dolayý program
iþini yapamayabilir, bu ayrý bir durum bu hatalara kodlama hatalarý denir. Eðer amaç kodlama hatala-
rýný bulmaksa, bunun araçlarý ayrý. Eðer amaç run time, çalýþma zamaný hatalarýný bulmaksa iþte o 
zaman exception handling mekanizmasý kullanýlýr.

Mesela fonksiyonlardan birinin iþini yapabilmesi için, bir dosyayý açmasý gerekiyor, standart C
fonksiyonu olan fopen'ýn çaðýrýldýðý düþünülsün. Ýki nedenden dosya açýlamayabilir, dosya açýlamadýðý
için fonksiyon iþini yapamama durumu ile karþýlaþýr, bu durumda fonksiyonu çaðýran kodlar da iþini
yapamamýþ olur ve program ayný þekilde doðru çalýþmamýþ olur. Ýki nedenden biri þöyle, programcýnýn
bir dosya ismi oluþturmasý gerekiyor ve o dosyayý okuma amacý ile açacak, dosya ismi string manipulasyonu
ile elde edilecek, "kirmizi_corap_xxl.jpeg" programcý string iþlemlerini yanlýþ yapmýþ olsun ve isimdeki
_ karakterlerinden biri stringde yer almamýþ dolayýsý ile bu isimde bir dosya olmadýðýndan dosya 
açýlamýyor. Buradaki çözüm ise kodun düzeltilip doðru þekilde yazýlmasý. Bu bir kodlama hatasý.
Bunun çözümü kodlama hatasýný bulup, kodu düzeltmek. Bunun için kod debug edilebilir, assert makrolarý
kullanýlabilir.

Ýkinci senaryo ise þöyle, dosyayý iþyerindeki çalýþanlardan biri yanlýþlýkla sildi. Program iþini 
yapamaz ancak bunun yazýlan kaynak kod ile alakasý yok. Ýkinci bir örnek olarak veritabanýna 
eriþilmesi gerekiyor, bunun için biri þifreyi oluþtururken yanlýþ þifre girmiþ ve eriþim kýsýtlanmýþ.
Exception Handling derken, kastedilen bu ikinci tür hatalar. Programýn kaynak kodundan dolayý olmayan,
çalýþma zamanýnda beklenmeyen durumlardan oluþan iþ yapamama durumlarý.

Bir fonksiyon çaðýrýldýðý zaman çoðu zaman fonksiyonun kendisi yükümlü olduðu iþi yapýp yapamadýðýný
anlayacak durumda, bunun ile ilgili problemli bir durum yok. Örnek olarak writeDatabase fonksiyonu.
Bu fonksiyon yazma iþlemi yaparken bazý kontroller yapar ve yazamadýðýný anlar. Peki yazamadýðýný
anladýðýnda ne yapacak ? Kontrol sonucu internet baðlantýsýnýn olmadýðýný gördü, fonksiyon ne 
yapmalý ? C'de problemin bu yüzü ile pek yüzleþmedik, mesela exit kullandýk. Fonksiyonun iþini
yapamamasý durumunda, karar verecek olan çoðu zaman bu fonksiyon deðil ki. Sonuçta bu fonksiyonu da 
çaðýran baþka bir fonksiyon var. Belki çaðýraný da çaðýran yine bir fonksiyon var. Bu durumlarda bu
fonksiyonun baþarýsýzlýk bilgisinin karar verme noktasýna kadar iletilmesi gerekiyor. 

C tarzý dillerde böyle bir mekanizma yok. Hatayý tespit eden kod daha alt seviyede ancak o hata 
tespit edildiðinde ne yapýlacaðýna karar veren kod çok daha yukarýda. C'de böylesi durumlarda, yani 
bir fonksiyon run time'da iþini yapamadýðýný saptadýðýnda kullanýlan iki tane yöntem var. Ýki yöntem
de aslýnda programcýnýn ihtiyacýný karþýlayacak seviyede ve güvenlikte deðil. Ýlki fonksiyonun iþini
yapamadýðýný bilgisini geri dönüþ deðeri ile iletmesi. C'de bir iþ yapmaya yönelik fonksiyonlarýn 
çoðunun geri dönüþ deðeri baþarý bilgisidir. Örnek olarak fopen, dosyayý açar eðer ki açamazsa NULL
pointer döndürür. Ýkinci yöntem ise standart kütüphane ve birçok kütüphane tarafýndan kullanýlýr.
Global bir hata deðiþkeni olur, C'de bunun adý errno'dur. Bu global hata deðiþkeninin default, hata
olmayan durumu gösteren bir deðeri olur ki int türü için bu genelde 0'dýr. Bu global deðiþken dýþa da 
açýlýr böylece diðer kaynak dosyalardan da eriþilir.(extern bildirimi baþlýk dosyasýnda yapýlarak)
Ýþini yapamayan bir fonksiyon gider bu global hata deðiþkenini bir deðer ile set eder. Farklý hatalar
farklý tamsayý deðerlerine map edilir. Böylece çaðýran kod o hata deðiþkeninin deðerine bakar, örneðin
0 ise bir hatanýn olmadýðýný anlar. Yöntemlerden biri geri dönüþ deðerini kullanýr diðer yöntemde ise
geri dönüþ deðeri bu amaca tahsis edilmek yerine global deðiþken ile bu iþi yapar.
Global deðiþken kullanmanýn da avantajlarý var, mesela ya fonksiyonun zaten bir geri dönüþ deðeri 
varsa ve hiçbir özel deðer buna ayrýlamýyor ise ? 

Geri dönüþ deðeri ile iletmenin dezavantajlarý: En büyük dezavantajý iþ gören kod ile hata iþleyen
kodun iç içe geçmesi. C'nin büyük sýkýntýlarýndan biri.
x = doSomething(); // ya bu fonksiyon iþini yapamadýysa ?
if (x == -1){ 
	////
}

if(x > 10) { }
else {}

Buradaki if(x == -1)'in anlamý eðer ki fonksiyon istisnai bir þekilde iþini yapamazsa bu kod devreye 
girsin demek. Bir de programýn kendi lojik yapýsý var. Yani fonksiyonun geri dönüþünden alýnan deðere
göre bir iþ de yaptýrýlabilir. Böylece kod okunurken, koda müdahale zorlaþýyor çünkü hangisinin iþ 
gören kod hangisinin hata iþleyen kod olduðunu anlamak zor. Bu ikisi birbirinden ayrýlsa çok daha iyi
olur. Kod okunurken, müdahale edilirken bu ikisinin ayrýmý yapmak çok kolay olur zaten ayrý yazýlmýþ
olurlar.

Ýkinci tipik problem ise, hatayý tespit edilen kodla hataya müdahale edecek kodun baðlantýsýný kurmakta.
f1, f2'yi ..... f4 ise f5'i çaðýrdý. Ancak aslýnda müdahale noktasý f1'i çaðýran yer. f5 iþini 
yapamadýðýnda geri dönüþ deðeri ile bunu f4'e bildirir, f4 de iþini yapamamýþ olur o da yine ayný 
þekilde geri dönüþ deðeri ile bunu f3'e iletir ..... Kodun boyuru artmýþ olur, yine kodlar iç içe
geçmiþ olur, hata yapma riski artar. f5 ile f1 arasýnda doðrudan baðlantý kuracak bir araç yok.	 
Dilin öyle bir aracý olsa ki, hatayý iþleyen kod hatayý tespit ettiðinde programýn akýþý bizim ilave
bir kod yazmamýza gerek kalmadan f5'den f4'e f3'e deðil de doðrudan f1'e gitsin, kim müdahale edecekse
programýn akýþý doðrudan oraya gitsin. 

Dezavantajlardan biri de þu olabilir. C'de bir program var, ortada 5 fonksiyon var, sýra ile çaðýrýyorlar;
a->b->c->d->e gibi. e fonksiyonu en son çaðrý yapýlan fonksiyon ve iþini yapamýyor, iþini yapamadýðýný NULL
pointer döndürerek kendisini çaðýrana bildirdi. d, fonksiyonunun kodunu yazan programcý eðer ki e'nin geri
dönüþ deðerini kontrol etmeyi ihmal etmiþ ise(malloc ve fopen fonksiyonlarýnýn geri dönüþ deðerlerinin kontrol
edlmesi gibi) artýk durum daha tehlikeli. Debug ederken artýk ne olduðunu çözümlemek oldukça zor kontrol yapýlmadý.
Hata oluþmasý riski içeren bir kodda C'de bunu kontrol etme zorunluluðu yok, ihmale açýk. Geri dönüþ deðeri ile
de bunu bildirebilir, global deðiþken yolu ile de olabilir. Global deðiþkene bakýldýðýnda ise sadece deðere bakýp,
kontrol etmek yeterli deðil ayný zamanda deðeri eski deðerine de çekmek durumunda. Kendisinden sonra çalýþan kod-
lar bu global deðiþkene baktýðýnda eðer önceki kodlar bu deðeri deðiþtirmemiþse fonksiyon bu deðere bakar, 
kendi kodunun doðru çalýþmadýðýný zanneder. Eðer bir kontrol yapýlmadýðý zaman programýn sonlanacaðý þekilde bir
mekanizma olsa, kiþinin ihmal riski ortadan kalkmýþ olurdu. Geleneksel hata iþleme düzeneðinin en büyük dezavan-
tajlarý bunlar.

Tüm bu dezavantajlara razý olunsa bile C++, C# gibi dillerde geri dönüþ deðeri kavramý olmayan fonksiyonlar var.
(ctor, dtor) Constructor, run time'da iþini yapamama durumuna en sýk maruz kalan fonksiyonlardan biri, ctor
bir nesneyi hayata getirir, süreç baþarýsýz olursa nesene oluþamaz bu durumda da baþka kodlarýn o nesnenin
hayata gelememiþ olduðunu bilmesi gerekir. Fakat ctor'un geri dönüþ deðeri yok, modern araçlar olmasa ctor gibi
fonksiyonlarda bu iþlem daha da zor olurdu. Ya ilave bir parametre olacaktý veya global deðiþken kullanýlacaktý.
 

 Run time'da böyle bir hata olduðunda peki ne yapýlýr ? Tek bir cevap verilemez her durum birbirinden farklý.
 Ortada bir kayýp olmadýðý sürece, veri kaybý, kalýcý hasar gibi bazý programlar bu duruma karþý duyarsýz. Bazý
 durumlarda exception handling kullanýlmaz bile, program sonlandýrýlýr ve tekrar çalýþtýrýlýr. Bazen hatayý iþ-
 lemek bu kadar basit olabilir, hatayý tespit eden kod iþini yapamadýðýný anlar ve gerekli iþlemleri yapar
 (kaynaklarý iade eder, dosyalarý kapatýr), bu yapýlara terminatif mekanizmalar denir. Burada amaç þu;
 program sonlanacak yani burasý kesin, programýn devam etme þansý yok ancak yapýlmasý gereken programý devam
 ettirmeye çalýþmak deðil, olmasý gerektiði gibi sonlandýrmak yani kayýp olmadan. Örnek olarak program sonlandý
 ancak kaynaklar geri verilmedi, dosyalara en son yazýlan þeyler, yazýlamamýþ oldu.   
 
Araç setinde tipik olarak üç bileþen var. Biri, hatayý tespit eden kodun hatayý daha yukarýdaki katmanlara
bildirmek için kullandýðý kontrol deyimi. Geleneksel mekanizmada, ancak fonksiyon kendisini çaðýrana durumu
bildirebiliyor. Burada ise hatayý tespit eden kod, hata bilgisini içeren bir nesne oluþturur ve bu nesneyi
daha yukarýdaki katmanlara gönderir. Örnek olarak fonksiyon böyle bir hata nesnesi oluþturur, bu nesneyi sadece
kendini çaðýrana deðil, onu çaðýraný çaðýrana .... tüm üst katmanlara bunun bilgisini verir(throw eder)
Bu, bu tür dillerde throw statement denilen özel bir kontrol deyimi ile yapýlýr. 
throw statement; //C'de olmayan bir kontrol deyimi
bu deyimin görevi, hatayý tespit eden kodun daha yukarýdaki katmanlara hatayý iletebilmesi için bir nesne
hazýrlamasý, bu nesneye gerekli bilgileri yazmasý ve yukarýdaki katmanlara gönderilmesi.

Hataya müdahale edecek kodlarýn belirli bir kod bloðu içinde çalýþacak kodlar söz konusu olduðunda "burada eðer
bir hata oluþursa ben buna müdahale etmeye adayým" anlamýnda bir kod bloðu oluþturmalarý gerekir. Bu kod bloðuna
bu tür dillerde kullanýlan anahtar sözcük ise try block.
Bir try block oluþturmakla yapmýþ olduðumuz: bu blok içinde çalýþacak kodlar bir hata nesnesi gönderirse bu hata 
nesnesini  yakalamaya aday olduðumuz bilgisi verilir. 

Hata nesnesini yakalayan ve ona müdahale eden kod ise error handler. Bu kodda yine bir blok ile belirlenir ve
bu bloða da catch blok denir.

Eðer bir kod böyle bir hata nesnesi hazýrlar da yukarý fýrlatýrsa ve yukarýdaki kodlardan hiçbiri bu hata
nesnesini yakalamazsa, artýk programý sonlandýracak bir mekanizma ortaya çýkar.(geleneksel hata ele alma yollarý-
ndan farklý olarak) Yani eðer bir hata nesnesi gönderilirse, bu nesne yakalanmak zorunda aksi taktirde program
zaten sonlanacak. Aslýnda nihayetinde hata nesnesi yakalanmazsa run time'da programý kullanan kiþi olarak abort 
fonksiyonu çaðýrýldýðý görülür. Abort programý sonlandýrýr ancak exit gibi bir takým garantiler vermez, aniden
sonlandýrýr. Tabi bunun da avantajý abort'un çaðýrýldýðý bilinir. 

C'de run time'da bir program normal þekilde sonlanabilir(normal termination), bu exit'in çaðýrýlmasý.
Anormal sonlanabilir(abnormal termination), abort'un çaðýrýlmasý.
Run time hatasý ile program çökebilir. Burada ne exit ne abort çaðýrýlýr, program run time'da çöker.
Eðer bir program abort ile sonlandýrýldýysa, abort'un býraktýðý imza görülür.(abnormal program termination gibi
bir yazý hata ekranýna yazýlýr)

Bir hata nesnesi gönderilir ve yakalanmazsa prorgam sonlanýr. Eðer ki program devama zorlanacaksa, gönderilen
bütün hata nesneleri yakalanmak zorunda. Bir tane bile yakalanmamýþ hata nesnesi olursa, bu programýn
sonlanmasýna yol açar. Eðer programýn sonlanmasý problem deðilse bu ayrý, hata yine yakalanmalý ancak bu sefer
yapýlmasý gereken bazý iþlemleri yapmak için yakalanmalý. Resumptive bir mekanizma kullanýlacaksa o zaman
programýn gönderilen tüm hata nesnelerini yakalamasý gerekir, bir tane hata nesnesi bile sýzmamalý ve de bu
hata nesnesi yakalandýktan sonra programýn bir veri kaybý olmadan, kaynak kaybý olmadan iþini yapmaya devam etmesi
gerekir. 

Programlardaki bu özelliðe exception safety denir. Bu tür programlarda run time'da ne olursa olsun program
çalýþmaya devam eder, iþini yapmaya devam eder. Ýstenmeyen durumlar karþýsýnda program kendini recover eder.

Throw Statement:

throw bir anahtar sözcük, ondan sonra bir ifade var.
throw exp; //throw deyimi
aslýnda return deyimlerine çok benzer, fonksiyonlarýn kodu içinde return deyimleri de bu þekilde.
ifadesiz return deyimleri olduðu gibi burada da ifadesiz bir throw deyimi var ancak return'e benzerlik anlam 
olarak bambaþka, buna rethrow statement denir.
Ýki throw deyimi var biri ifadeli throw statement diðeri ise özel durumlarda kullanýlan rethrow statement.
Derleyici throw deyimi karþýsýnda nasýl bir kod üretir ?
throw x; //ifadesi için run time'da programýn akýþý bu noktaya gelirse(muhtemelen bu ifade bir if'in doðru
kýsmýnda olacak) derleyici bizim için bir nesne construct eder. Yukarýdaki katmanlara gönderilen nesne
throw ifadesindeki nesne deðil. throw ifadesi olarak nesne gösteren bir ifade kullanýlsa dahi, gönderilen 
nesnenin kendisi ifadedeki nesne olmaz. Derleyici yazdýðýmýz throw ifadesini, yapacaðý kopyalamada alacaðý
deðer olarak kullanýr.

decltype(x) excobj {x}; //Derleyicinin ürettiði kod, x throw ifadesindeki nesne

Eðer ki gerçekten de throw ifadesinde programcýnýn oluþturduðu nesne yukarýdaki katmanlara gönderilmek
istenirse, nesne dinamik olarak oluþturulur. Onun adresi ile throw edilir, derleyici pointer oluþturur ve 
pointerý gönderir. Nesnemiz delete edilene kadar hayatý devam eder.
Yani derleyici tarafýndan oluþturulmuþ olan nesnenin oluþturulur oluþturulmaz ömrü bitse de bizim kendi 
throw ifademizde oluþturduðumuz nesne bundan etkilenmez.

Bu nesne iki amaçla bilgi taþýyacak þekilde oluþturulur. Bu nesnenin türü hatanýn ne olduðuna iliþkin genel
bilgiyi verir. Bu nesne matherror isimli bir sýnýf türünden ise, gönderilen nesnenin türünün matherror olmasý
matematik ile ilgili bir hata olduðunu belirtir. Fileerror türünden ise, dosyalar ile ilgili bir hata olduðunu
gösterir. Farklý türler farklý hataya karþýlýk gelir, hata nesnesinin türü hatanýn ne olduðu konusunda genel
bilgi verir. Primitif türler de kullanýlýr ancak uygulama pratiðinde bu iþ için özel oluþturulmuþ sýnýflar 
kullanýlýr hatta kalýtým ve run time polimorfizm de kullanýlýr.

throw x; //ifadesindeki x bir sýnýf nesnesi ise bu sýnýf nesnesi belirli bilgileri encapsule eder. O bilgiler 
ile daha özel o hataya yönelik veriler yukarý iletilebilir. Dosya hatasý isminde bir sýnýf olsun, FileError. 
Kalýtým yolu ile iki tane sýnýf elde edilmiþ; FileReadError, FileWriteError. Okuma ile ilgili hatalarda
FileReadError sýnýfý türünden nesne, Yazma ile ilgili hatalar olduðunda ise FileWriteError sýnýfý türünden hata
nesneleri gönderilir. Kalýtým mekanizmasýnýn kullanýlmasý, run time polymorphism'deki araçlar ile hatayý
yakalayýp ona müdahale etmek isteyen kodun çok daha kolay yazýlmasýný saðlar. Bütün hatalar, en tepedeki
bir taban sýnýfdan türetilmiþ olsun.(Gerçekten C++'nýn standart kütüphanesinde böyle bir sýnýf mevcut, exception.
Standart kütüphanede ne seviyede olursa olsun gönderilen bütün hata nesnelerinin ait olduðu sýnýflar exception
hiyerarþisinde. Exception türünden bir hata nesnesi yakalamak istendiðinde C++'nýn standart kütüphanesinden
gönderilen bütün hata nesneleri yakalanabilir.)

FileReadError sýnýfý türünden bir hata nesnesi gönderilsin. Zaten gönderilen hata nesnesinin türünün 
FileReadError olmasý bunun dosya okuma hatasý olduðunu anlatýr. Ancak sýnýfýn private elemanlarýnda, satýr
numarasý diye bir öðe olduðu düþünülsün. Dosyanýn kaçýncý satýrýný okurken hata olduðunu belirtir. Böylece
hata nesnesini yakalayan, hata nesnesinin türünden ne tür bir hata olduðun anlar. Bazý fonksiyonlarý çaðýrarak
daha detaylý bilgi alabilir. Dosyanýn kaçýncý satýrýndaki bilgi olduðu bilgisini de alabilir.

Throw ifadesinde iki farklý kategoride bilgi iletilir. Biri zaten ifadenin türü, ikincisi ise oluþturulan
nesnenin, instance'ýn içinde tutulan deðerler. Dosya ismi, satýr numarasý, zaman bilgisi.. 
En tipik yaklaþým içinde bir string tutmak. Nesneyi alan o yazýya bakýp, o yazýnýn ne olduðuna baðlý olarak
bazý iþlemler yapar. 

Zorunluluk olmasa da throw ifadelerinin çoðunda þöyle ifadeler yer alýr;
Madem kullanýlan throw ifadesi sadece derleyicinin oluþturacaðý hata nesnesini initalize etmekte kullanýlacak
o zaman bunun geçici nesne olmasýnda sakýnca yok. Gerçekten de throw statement'lerin tamamýna yakýnýnda 
geçici nesneler kullanýlýr.
throw MathError{}; //C++11 sentaksý, {} ctor için kullanýlan parantez
throw MathError(); //C++11 öncesi
Bu ifadelerin yürütülmesi ile de nesnenin ömrü biter.

throw FileReadError{"ali.txt", 45}; //FileReadError'un bir ctor'u var. Bu ctor bir string ve tamsayý alýyor.

Artýk programýn akýþý ya buradan bu hatayý yakalayacak koda çekilecek veya bu hata yakalanmazsa program 
sonlanacak. Hatanýn yakalanamamasýna ingilizcede uncaught exception denir, yakalanamayan hata nesnesi gibi.
Bu durumda derleyicinin ürettiði kod doðrudan olmasa da abort'un çaðýrýlmasýný saðlar.(ismi terminate olan
bir fonksiyon çaðýrýlýr, terminate fonksiyonunun defaultu abort'u çaðýrmak. Ancak istenirse terminate'in
default davranýþý deðiþtirilebilir. callback yapýsý ile hangi fonksiyonu çaðýracaðý set edilebilir.)


//////////////////////////////////////////////////////////////////
void f4(int x)
{
	if (x > 10)
		throw 2.3;
}  
//////////////////////////////////////////////////////////////////
Uygulama pratiðinde karþýlýðý olmasa da sentaksa uygun bir örnek. Derleyici double türden bir hata nesnesi
oluþturur ve o hata nesnesine 2.3 ilk deðerini verip bu 2.3 deðeri taþýyan bu hata nesnesini yukarýdaki
katmanlara iletir.


//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	if (x > 10)
		throw 2.3;
	cout << "f4 sone erdi\n";
}

void f3(int x)
{
	cout << "f3 cagirildi\n";
	f4(x);
	cout << "f3 sone erdi\n";
}

void f2(int x)
{
	cout << "f2 cagirildi\n";
	f3(x);
	cout << "f2 sone erdi\n";
}

void f1(int x)
{
	cout << "f1 cagirildi\n";
	f2(x);
	cout << "f1 sone erdi\n";
}

int main(void){ 

	cout << "main basladi\n";
	f1(4);
	cout << "main sona erdi\n";


	return 0;
}
//////////////////////////////////////////////////////////////////
Exception gönderilmediðinde, main f1'i; f1, f2'yi; .... en son f4 çaðrýldý. 



//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	if (x > 10)
		throw 2.3;
	cout << "f4 sone erdi\n";
}

void f3(int x)
{
	cout << "f3 cagirildi\n";
	f4(x);
	cout << "f3 sone erdi\n";
}

void f2(int x)
{
	cout << "f2 cagirildi\n";
	f3(x);
	cout << "f2 sone erdi\n";
}

void f1(int x)
{
	cout << "f1 cagirildi\n";
	f2(x);
	cout << "f1 sone erdi\n";
} 

int main(void){ 

	cout << "main basladi\n";
	f1(45);
	cout << "main basladi\n";


	return 0;
}
//////////////////////////////////////////////////////////////////
f1, f2, f3, f4 çaðýrýldý yazýsý çýkar. Aslýnda f4'ün içinde throw kodu çalýþýr. Throw kodu çalýþýr ancak
hatayý kimse yakalamadýðý için f4 sona erdi yazýsý bile çýkmaz. Programýn akýþý buradan ya hatayý iþleyecek
koda çekilecek, yok eðer hata yakalanamazsa uncaught exception durumu oluþur ve abort fonksiyonu çaðrýlýr.
Programýn sonlanmasýnýn nedeni abort'un çaðýrýlmasý. 

Daha gerçekçi bir kullaným ise;
Uygulamalarýn çoðunda C++'ýn standart hiyerarþisi içindeki sýnýflardan birini doðrudan kullanýrýz veya
kalýtým yolu ile bir sýnýf elde ederiz. 

out_of_range C++'nýn standart hata sýnýflarý hiyerarþisindeki sýnýflardan biri.
Logic Error sýnýfýndan türetilmiþtir, o da Exception sýnýfýndan türetilmiþtir.
//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	if (x > 10)
		throw out_of_range{"Aralik disi deger!!!"};
	cout << "f4 sone erdi\n"; 
}
//////////////////////////////////////////////////////////////////


Try Block ve Catch Block:

Eðer programcý bu çalýþan kodda gönderilecek hatalarý yakalamaya aday bir kod yazacaksa orayý bir blok içine
almalý, bu blok try bloðu. try bloðu, kaynak kodda gerçek bir blok ancak run time açýsýndan bakýldýðýna o try
bloðunun içindeki kod yürütüldüðü zaman bütün süreçleri kapsar. f1, f2'yi; f2, f3'ü .... f4 ise hata nesnesi
gönderdi. Bu try bloðunu izleyen catch bloklarý ile hata yakalanabilir. Fiziksel olarak çalýþacak kod burada 
önemli, f4 fonksiyonu doðrudan çaðýrýlmadý ancak f4'ün kodu bu bloðun içinde çalýþacak kodla çlýþýr.
Kaç tane state'de fonksiyon çaðýrýlýrsa çaðýrýlsýn, son fonksiyon exception throw etse bile yine oradaki 
exceptioný yakalamaya aday. Ancak try bloðunu zorunlu olarak minimal bir tane catch bloðu izlemek zorunda.

//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi\n";
	
	try{
		f1(45);
	}
	catch (int) {

	}
	
	cout << "main basladi\n";
	return 0;
}
//////////////////////////////////////////////////////////////////

catch anahtar sözcüðünü açýlan ve kapanan parantez izler, ondan sonra bir blok var.
Nasýl fonksiyonlarýn parametre deðiþkenleri varsa, catch bloklarýnýn da parametreleri var. Ancak sadece bir
tane parametresi olabilir. Geri dönüþ deðeri yazýlacak bir durum yok. Parametre deðiþkeni olmak zorunda ve bir
tane olmamk zorunda. Parametreye isim verilebilir ancak eðer parametre catch bloðu içinde kullanýlmayacaksa
isim verilmesi zorunlu deðil. catch bloðu oluþturmakla þuna talip olunmuþ olur, yukarýdaki try bloðu içinde
çalýþan kodda gönderilecek hata nesnesinin türü int olursa programýn akýþý bu bloðun içine çekilsin.
Programýn akýþý ancak gönderilen hata nesnesinin türü ile, catch parametresinin türü ayný ise.


//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi\n";
	try{
		f1(45);
	}
	catch (int x) {
		cout << "hata main islevi icinde yakalandi x = " << x << endl;
	}
	cout << "main basladi\n";

	return 0;
}
//////////////////////////////////////////////////////////////////
Gönderilen hata nesnesi int türden ve deðeri 5 ise; programýn akýþý throw deyiminden buraya gelir.
throw ifadesinin deðeri bu deðiþkene kopyalanýr. 
Fonksiyonlarda olduðu gibi, catch bloðuna parametre yazarken call-by-value yazýlabilir, call-by-reference da
yapýlabilir. Ancak eðer ki run time polymorphismden yararlanýlacaksa, call-by-value yapýlamaz. O durumda 
call-by-value yapýldýðýnda object slicing yapýlmýþ olur, polimorfik bilgi kaybedilmiþ olur.

Yazmýþ olduðumuz örnekte gönderilen hata nesnesinin türü double. double'dan veri kaybý olsa da int'e dönüþüm
var. Burada dilin kurallarý bu dönüþüme geçerli deðil. Gönderilen hata nesnesinin bir catch bloðu tarafýndan
yakalanmasý için türünün kesinlikle ayný olmasý lazým. unsigned int gönderildi, catch parametresi int; yakalanmaz.
float gönderildi, tür double; yakalanmaz. Bunun tek istisnasý run-time polymorphism, is a iliþkisi. Örneðin
MathError, Exception'dan kalýtým yolu ile elde edilirse, DivideByZeroError, MathError'dan kalýtým yolu ile 
elde edilirse, gönderilen hata nesnesi DivideByZeroError türünden ise o türden bir referans ile de yakalana-
bilir, MathError türünden referans ile de yakalanabilir, Exception reference ile de yakalanabilir. Onun
dýþýnda türün kesinlikle ayný olmasý gerekir.

Hata nesnesi gönderildi, ortada böyle bir try bloðu var ve tür uyuþmazlýðýndan yakalanamadý. Bu durumda yine
uncaught exception durumu oluþur. Yani bir hata nesnesinin yakalanamamasý durumu iki ihtimalle oluþur. Biri
zaten try bloðu yoktur yani zaten ortada kod yoktur, bir diðeri ise try bloðu var ama gönderilen hata nesnesi
yakalamaya aday olunan hata nesnesi türünden deðil. 

Hata nesnesi yakalansa ne olurdu ?
Programýn akýþý catch bloðu içine girer, buradaki hata iþleyen kod çalýþýr. Eðer bu kod 
a) programý sonlandýrmazsa,
b) gönderilen hata nesnesini rethrow etmezse,
c) gönderilen hata nesnesini translate etmezse,
o zaman týpký breaki olan bir switch deyiminde olduðu gibi catch bloðundaki kodlar çalýþýr ondan sonra en
son catch bloðunu izleyen(sonuçta bir tane olmak zorunda deðil) koddan sonraki kod ile devam eder.



//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	if (x > 10)
		throw 4;
	cout << "f4 sone erdi\n"; 
}

void f3(int x)
{
	cout << "f3 cagirildi\n";
	f4(x);
	cout << "f3 sone erdi\n";
}

void f2(int x)
{
	cout << "f2 cagirildi\n";
	f3(x);
	cout << "f2 sone erdi\n";
}

void f1(int x)
{
	cout << "f1 cagirildi\n";
	f2(x);
	cout << "f1 sone erdi\n";
} 

int main(void){ 

	cout << "main basladi\n";
	try{
		f1(45);
	}
	catch (int x) {
		cout << "hata main islevi icinde yakalandi x = " << x << endl;
	}
	cout << "main devam ediyor\n";


	return 0;
}
//////////////////////////////////////////////////////////////////
f4 fonksiyonu içinde gönderilen hata nesnesi int türden. Programýn akýþý main'deki catch bloðu içine gelir.
"hata main islevi icinde yakalandi" yazýsý çýkar. rethrow edilmedi, translate edilmedi, program da sonlanmadý.
O zaman programýn akýþý normal blok sonrasýndaki deyim ile devam eder ve "main devam ediyor" yazýsý çýkar.



Türleri farklý olmak üzere istenildiði kadar catch bloðu oluþturulabilir.
Gönderilen hata nesnesi int türdense programýn akýþý ilk catch bloðuna çekilir ve onun içindeki kod çalýþýr.
rethrow etmez, translate etmez, programý sonlandýrmazsa týpký bir breakli switch statement gibi programýn akýþý
cout <<"main devam ediyor\n"; kodundan devam eder.
Gönderilen hata nesnesi double ise ikinci catch bloðu çalýþýr ve kod yine cout <<"main devam ediyor\n"; 
kodundan devam eder.
Hata nesnesi float türden ise en alttaki blok çaðýrýlýr ve kod yine ayný þekilde devam eder.
Gönderilen hata nesnesi bunlardan biri türünden deðil ise uncaught exception durumu oluþur.
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi\n";
	try{
		f1(45);
	}
	catch (int x) {
		cout << "hata main islevi icinde yakalandi (catch int) x = " << x << endl;

	}
	catch (double x) {
		cout << "hata main islevi icinde yakalandi (catch double) x = " << x << endl;

	}
	catch (float x) {
		cout << "hata main islevi icinde yakalandi (catch float) x = " << x << endl;

	}


	cout << "main devam ediyor\n";


	return 0;
}
//////////////////////////////////////////////////////////////////



Eðer ki yukarýdaki catch bloklarý varken, gönderilen hata nesnesinin türü aþaðýdaki gibi unsigned int ise;
normalde unsigned int, int'e de atanabilir, double'a da, float'a da. Ancak burada uncaught exception oluþur.
Çünkü burada tür dönüþümü yok. Tek kabul edilebilir tür farklýlýðý is a ? iliþkisi.
//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	if (x > 10)
		throw 4u;
	cout << "f4 sone erdi\n"; 
}
//////////////////////////////////////////////////////////////////


Özel bir catch bloðu var. Bu catch bloðu, ne gönderilirse gönderilsin yakalamak için var. Hata nesnesinin
türünün bir önemi yok. Bu catch bloðunun sentaksýna catch all denir. Burada yine elipsis atomu kullanýlýr.
C'de 3 nokta(elipsis) token'i tek bir yerde kullanýlýr, variyadik imzalarda. C++'da ise daha fazla yerde
kullanýlýr.
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi\n";
	try{
		f1(45);
	}
	catch (int x) {
		cout << "hata main islevi icinde yakalandi (catch int) x = " << x << endl;

	}
	catch (double x) {
		cout << "hata main islevi icinde yakalandi (catch double) x = " << x << endl;

	}
	catch (float x) {
		cout << "hata main islevi icinde yakalandi (catch float) x = " << x << endl;

	}
	catch (...) {
		cout << "hata catch all blogu tarafindan yakalandi" << endl;

	}


	cout << "main devam ediyor\n";


	return 0;
}
//////////////////////////////////////////////////////////////////




Bir switch deyimi karþýlýðýnda derleyicinin ürettiði kod; caseler yukarýdan aþaðýya doðru olduðundan iþlem
de yukarýdan aþaðýya doðru yapýlýr.	Switch ifadesi de bir else-if merdiveni gibi. Burada da ayný özellik
geçerli yani catch(...) sýnamasýnýn yapýlmasý için üsttekilerin sýnamalarýnýn yapýlmýþ olmasý gerekir.
Aþaðýdaki kod lojik açýdan doðru deðil. Dilin sentaksý da bu kontrolü yapar ve kod geçersiz olur.
catch all baþta olduktan sonra zaten aþaðýdaki catch bloklarýna gidilme þansý yok.
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi\n";
	try{
		f1(45);
	}
	catch (...) {
		cout << "hata catch all blogu tarafindan yakalandi" << endl;

	}
	catch (int x) {
		cout << "hata main islevi icinde yakalandi (catch int) x = " << x << endl;

	}
	catch (double x) {
		cout << "hata main islevi icinde yakalandi (catch double) x = " << x << endl;

	}
	catch (float x) {
		cout << "hata main islevi icinde yakalandi (catch float) x = " << x << endl;

	}

	cout << "main devam ediyor\n";


	return 0;
}
//////////////////////////////////////////////////////////////////



Polimorfik iþlemede de ayný durum geçerli. Gönderilen hata nesnesi DivideByZeroError türünden olsun.
Aþaðýdaki kod örneðinde de yine ayný þekilde lojik hata mevcut. Zaten her DivideByZeroError, MathError
olduðundan daha ilk sýnamada zaten yakalanmýþ olur.
//////////////////////////////////////////////////////////////////
	catch (MathError) {

	}
	catch (DivideByZeroError) {

	}

//////////////////////////////////////////////////////////////////

Birden fazla catch bloðu varsa, catch bloklarý özelden genele doðru sýralanmalý. Hiyerarþideki en alttaki
sýnýf en üstteki catch bloðu olmalý. Taban sýnýflarý daha altta, eðer catch all varsa o da en altta olmalý.

Exception Handling'de bir tane bile hata nesnesini kaçýrmak istenmiyorsa, tüm program main içinde çalýþtýðýndan
main'in tamamý try bloðu içine alýnýr, bir de catch all konulursa hata nesneleri yakalanýr. Ancak burada da
bir istisna mevcut. Global nesnelerden neden bazý durumlarda kaçýnýldýðý burada ortaya çýkar. Global nesneler
main çalýþmaya baþlamadan önce hayata gelir. Yani main'in tamamý try bloðu içine alýnsa bile halen global 
sýnýf nesnelerinin ctorlarýndan gelecek exceptionlarýn yakalanma ihtimali yok. Java, C# gibi proglamlama
dillerinde zaten global nesne kullanmak durumu yok. C++'da global nesne kullanýmý geçerli ancak C'deki gibi
yaygýn kullaným yok. Global nesne yerine Singleton nesne kullanýlabilir, bu global nesne kullanýmýný kýsýtlamaya
yönelik yöntemlerden biri. 	

Exception Handling'de yapýlan bazý tipik hatalar var. Ýlki mekanizmayý tamamen yanlýþ anlamak mesela, C'de kod
yazmaya alýþmýþ, fonksiyonlardan hata kodu döndüren kodlara benzer burada da her yazdýðý kodu try bloðu içine 
almýþ bir de catch bloðu kullanmýþ. Bu mekanizmanýn en büyük faydasý zaten hatayý iþleyen kod ile hatayý tespit
eden kodun birbirinden ayrýlmasý. Eðer hata yakalandýðýnda ne yapýlacaðý konusunda bir fikir yoksa o zaman hata
yakalanmaz. C'deki geleneksel hata yakalama mekanizmasý düþünülerek exception handling kullanýlmaz. Hata yakala-
nacaksa bunun sonucunda yapýlmak istenen bazý iþler olmalý. Yakalanmazsa baþkasý, daha yukarýdaki kodlar yakalar. 
En kötü main'de yakalanýr. Ortalýðý iç içe catch bloklarý ile doldurmak iyi fikir deðil. Bir try bloðu oluþturuluyor
ise oradaki hata yakalandýðýnda yapýlacak bir iþin olmasý gerekir. 

Main içinde yakalamanýn þöyle bir anlamý olabilir, baþka yerlerde de yakalanmaya çalýþýlmýþtýr.
Mesela alt seviyeli kodlarda, bizim hiyerarþimiz dýþýnda apayrý bir hata nesnesi gönderilmiþ olabilir ve yazdýðýmýz
kodda bunu yakalayamamýþ olabiliriz. Tipik olarak her uygulamanýn exception hiyerarþisi olur böylece kendi exception
hiyerarþisi içindeki hatalarý zaten belirli noktalarda yakalarýz ancak onun dýþýndaki hatalarý bizim taban sýnýfta
yakalamamýz mümkün olmadýðý için, geriye yakalayabilecek tek yöntem olarak catch all kalýr. En azýndan programda ne
oluyor ne bitiyor, program exception ile mi çýkýlýyor buna bakmak için main içinde yakalamak istenebilir.

Eðer uygulama verim kritik bir uygulama deðilse, her ne kadar bu mekanizmanýn da bir maliyeti olsa da verim kritik
olmayan uygulamalar için performansa etkisi azdýr. Tipik hatalardan biri exception handlingi de normal for, while,
break kontrol deyimleri gibi kullananýlmasý. Yani programýn f1'den özel bir durumdan dolayý f4'e gitmesi gerekiyor,
throw ile gitmiþ ancak ortada bir hata senaryosu yok. Kesinlikle bu mekanizma bir kontrol mekanizmasý olarak, 
programýn ana akýþ kontrol lojiðiinin bir parçasý olarak kullanýlmamalý, ciddi bir maliyet getirir. Özellikle verim
kritik uygulamalarda exception handling daha az tercih edilir. 
Exception Handling kullanýlmazsa neden kullanýlmaz ?
-Gerek olmayabilir, program o kadar basittir ki program kapatýlýp tekrar çalýþtýrýlýr. Birçok programda, program son
derece basit, eðer bir hata durumu olursa hata tespit edilir, C'de yaptýðýmýz gibi exit ile sonlandýrýlýr ve bu maliyet
hiç ödenmemiþ olur.  
-Kritik programlar, real-time kodlar olur ve bu mekanizmaya harcayacak kaynaðý olmaz. 
-Bu dillerdeki exception handling araçlarý senkron hatalara yönelik. Asenkron hatalar ile hiç alakasý yok. Programýmýz
çalýþýrken, baþka bir program veya interrupt devreye girecekse bunun exception handling araçlarý ile iþlenmesinin
mümkünatý yok. Mekanizma ancak programýn kendi içindeki çalýþan kodlardan oluþan hatalarý yakalamaya yönelik.

Kullanýlan kütüphaneler de exception mekanizmasý kullanabilir, bu durumda programcý exception kullanmak istemiyor olsa
da kullandýðý kütüphaneler exception throw eder, program sonlanabilir. 


string sýnýfý için köþeli parantez operatörüne geçersiz bir index verilirse exception throw etmez.
Aþaðýdaki örnekte s için at fonksiyonu kullanýlmak yerine s[127] ifadesi kullanýlsaydý, exception throw etmezdi.
Ancak string sýnýfýnýn at fonksiyonu kullanýldýðýnda ve fonksiyona geçersiz bir index geçildiðinde exception throw 
ettiði görülür.
//////////////////////////////////////////////////////////////////
void f4(int x)
{
	cout << "f4 cagirildi\n";
	string s(x, 'A');

	cout << "karakter = " << s.at(125) << endl;

	cout << "f4 sone erdi\n"; 
}

void f3(int x)
{
	cout << "f3 cagirildi\n";
	f4(x);
	cout << "f3 sone erdi\n";
}

void f2(int x)
{
	cout << "f2 cagirildi\n";
	f3(x);
	cout << "f2 sone erdi\n";
}

void f1(int x)
{
	cout << "f1 cagirildi\n";
	f2(x);
	cout << "f1 sone erdi\n";
} 

int main(void){ 

	cout << "main basladi" << endl;

	try {
		f1(47);
	}
	catch (...) {
		cout << "hata catch all blogu tarafindan yakalandi" << endl;
	}
	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////	


Ýsmi exception olan sýnýf C++'nýn standart kütüphanesinin hata hiyerarþisi sýnýflarýnýn en tepesindeki sýnýfý.
C++'dan gönderilen ister operatör seviyesinde olsun, ister standart kütüphanenin üye veya global fonksiyonlarý
olsun hepsi exception türünden nesneler.
Buradaki hata da standart kütüphaneden gönderildiðine göre bu da bir exception o zaman burasý hatayý yakalar.
//////////////////////////////////////////////////////////////////	
int main(void){ 

	cout << "main basladi" << endl;

	try {
		f1(47);
	}
	catch (exception &) {
		cout << "hata (catch exception &) blogu tarafindan yakalandi" << endl;
	}
	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////


Sýnýfýn polimorfik iþleme için önemli bir fonksiyonu var, what fonksiyonu. Sýnýfýn what fonksiyonu çaðýrýldýðýnda,
fonksiyon const char * türünden bir yazý verir. O yazý hatayý betimleyen bir yazýdýr. Hata bilgisi bir yazý olarak
elde edilmek istenirse, what fonskiyonunun çaðýrýlmasý yeterli. Ancak what fonksiyonu bir virtual fonksiyon, pure
virtual deðil. Dolayýsý ile ya override edilecek, eðer override edilmezse taban sýnýfýnki çalýþacak.
//invalid string position
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi" << endl;

	try {
		f1(47);
	}
	catch (exception &r) {
		cout << "hata (catch exception &) blogu tarafindan yakalandi : " << r.what()  << endl;
	}
	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////


exception ile deðil logic_error ile de yakalanýr. Gönderilen hata nesnesi logic_error türünden ise
yakalanýr. Gönderilen hata nesnesi hem exception hem de logic_error türünden yoksa yakalamazdý.
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi" << endl;

	try {
		f1(47);
	}
	catch (logic_error &r) {
		cout << "hata (catch logic_error &) blogu tarafindan yakalandi : " << r.what()  << endl;
	}
	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////
	  

Hata nesnesi ayný zamanda da out_of_range ile de yakalanýr. Gönderilen nesne ayný zamanda out_of_range
türünden. Hiyerarþi gerçekten de böyle, exception'dan türetilmiþ logic_error sýnýfý var. logic_error
sýnýfýndan türetilmiþ sýnýflardan biri de out_of_range. Dolayýsý ile out_of_range türünden bir nesne 
hem out_of_range hem logic_error hem de exception türünden.
//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main basladi" << endl;

	try {
		f1(47);
	}
	catch (out_of_range &r) {
		cout << "hata (catch out_of_range &) blogu tarafindan yakalandi : " << r.what()  << endl;
	}
	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////

Stack Unwinding

Exception yakalanamzsa uncaught exception oluþur ve program terminate olur. Ama exception'ý yakalamanýn
bir de bonusu var, bu bonus stack unwinding denilen bir mekanizma ile hatayý gönderen koddan hatayý 
iþleyecek handler koda gelene kadarki bütün stack seviyesindeki nesneler teker teker destroy edilirler.
Dil bunu garanti eder, dil bunu ancak hata nesnesi yakalandýðý zaman garanti eder. Normalde bazý objectler
RAI objectler, yani constructor'ý ile kaynaklar elde etmiþ destructor'ý ile kaynaklarý geri veren objeler;
iþte bu mekanizmadaki asýl problem burada. RAI nesnelerine neden ihtiyaç duyduðumuza exception tarafýndan 
bakýldýðýnda: 


Fonksiyon, kaynaklar elde ediyor.(sözde kod yazýldý)
//////////////////////////////////////////////////////////////////
void func()
{
	auto ptr = new Source;

	foo();

	delete ptr;
}
//////////////////////////////////////////////////////////////////
Normalde elde edilen kaynak, fonksiyon bloðu içinde delete edilene kadar kullanýlabilir.
Programýn akýþý sebebiyle o arada gönderilen bir exception neticesinde buradan çýkarsa ?
Arada foo fonksiyonu çaðýrýldý ve foo fonksiyonu exception throw etti. Programýn akýþý buradan çýkar bu durumda 
delete ptr; ifadesi iþlenmemiþ oldu. Peki buradaki kaynaðý kim iade edecek ?


Kaynaklar bu yüzden de nesneler ile kontrol edilir. Kaynak yukarýdaki þekilde kullanýlmak yerine aþaðýdaki gibi
kullanýlsa;	SourceUser bir sýnýf, sýnýf türünden bir nesne tanýmlandý. Bu kodda kaynaðý sýnýfýn ctor'u elde eder.
Kaynaðý destructor'ý geri verir. Kaynaklar bloðun sonunda destruct olur. Peki ya yine arada exception throw edilirse ?
//////////////////////////////////////////////////////////////////
void func()
{
	SourceUser x; 

	foo();

	
}
//////////////////////////////////////////////////////////////////


Ýþte burada artýk stack unwinding süreci devreye girecek. Progamýn akýþý hata iþleyen koda girme süreci içinde hatayý
throw eden kodla hatayý iþleyen kod arasýnda kaç stack seviyesi olursa olsun oradaki tüm yerel nesneler derleyicinin
ürettiði kodla destroy edilir. Örnek olarak f1, f2'yi .... f19, f20'yi çaðýrdý, f20 exception throw etti, main'de 
exception yakalandý; f1'in, f2'nin .... içindeki yerel nesneler destroy edilir.


//////////////////////////////////////////////////////////////////
class ResourceUser {
	int ma[16];
public:
	ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesi kullanimi icin kaynaklar edinildi" << endl;
	}

	~ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesinin kullandigi kaynaklar geri verildi" << endl;
	}
};

void f3()
{
	cout << "f3 cagirildi" << endl;
	ResourceUser f3x;

	//programýn akýþý buraya geldiðinde zaten 3 nesne de hayatta
	throw 5;

	cout << "f3 sona erdi" << endl;
}

void f2()
{
	cout << "f2 cagirildi" << endl;
	ResourceUser f2x;
	f3();
	cout << "f2 sona erdi" << endl;
}

void f1()
{
	cout << "f1 cagirildi" << endl;
	ResourceUser f1x;
	f2();
	cout << "f1 sona erdi" << endl;
}

int main(void){ 

	cout << "main cagirildi" << endl;

	f1();

	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////
f3 içindeki throw olmasa, exception throw etmeseydi programýn olaðan akýþýnda tüm nesneler destroy edilirdi. Ancak þimdi
kodun akýþý buradan çýkýnca bunlarýn destructorlarý çaðýrýlmayacak. Eðer gönderilen bir exception yakalanmazsa
exception oluþana kadarki stack türevli oluþan otomatik ömürlü ne kadar nesne varsa hiçbirinin destructor'ý çaðýrýlmaz.
Çünkü ana bloðun sonuna kadar programýn akýþý zaten oraya gitmiyor. 



Exception yakalandýðýnda ise durum deðiþir. Stack unwinding'in avantajý da zaten burada.
Catch bloðuna girmeden zaten yerel nesnelerin hepsinin kaynaklarý geri verilmiþ olur. catch bloðu içindeki getchar 
çaðrýsýna gelinmeden zaten tüm kaynaklarýn geri verildiði görülür. Hata yakalandýðýnda stack unwinding süreci içinde 
(yýðýnlarýn geri sarýmý) hata gönderen kod ile hata iþleyen kod arasýndaki stack framelerdeki tüm yerel sýnýf nesneleri
yok edilir. Bir hata nesnesi yakalanarak bu garanti elde edilir.
//////////////////////////////////////////////////////////////////
class ResourceUser {
	int ma[16];
public:
	ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesi kullanimi icin kaynaklar edinildi" << endl;
	}

	~ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesinin kullandigi kaynaklar geri verildi" << endl;
	}
};

void f3()
{
	cout << "f3 cagirildi" << endl;
	ResourceUser f3x;

	//programýn akýþý buraya geldiðinde zaten 3 nesne de hayatta
	throw 5;

	cout << "f3 sona erdi" << endl;
}

void f2()
{
	cout << "f2 cagirildi" << endl;
	ResourceUser f2x;
	f3();
	cout << "f2 sona erdi" << endl;
}

void f1()
{
	cout << "f1 cagirildi" << endl;
	ResourceUser f1x;
	f2();
	cout << "f1 sona erdi" << endl;
}

int main(void){ 

	cout << "main cagirildi" << endl;

	try{
		f1();
	}

	catch (int) {
		getchar();
		cout << "hata yakalandi" << endl;
	}


	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////


Ancak Java, C# gibi dillere göre çok problemli bir durum var. Akýllý pointerlarýn da neden gerektiði þimdi daha iyi 
anlaþýlýr. Akýllý pointerlarýn kullanýmýna iliþkin en önemli temalardan biri de burada. 


Bazý nedenlerden dolayý bizim sýnýf nesnelerimiz dinamik oluyor yani new operatörü ile oluþturulur.
Aþaðýdaki kodun bir öncekine göre tek farký, oluþturulan nesneler otomatik ömürlü deðil, dinamik ömürlü.
Hata nesnesi yakalanmasýna raðmen, dinamik ömürlü nesneler için böyle bir mekanizma yok. Programcý delete etmediði
sürece bunlarýn destructorlarý çaðrýlmaz.
//////////////////////////////////////////////////////////////////
class ResourceUser {
	int ma[16];
public:
	ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesi kullanimi icin kaynaklar edinildi" << endl;
	}

	~ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesinin kullandigi kaynaklar geri verildi" << endl;
	}
};

void f3()
{
	cout << "f3 cagirildi" << endl;
	auto f3x = new ResourceUser;
	 
	throw 5;
	delete f3x;
	cout << "f3 sona erdi" << endl;
}

void f2()
{
	cout << "f2 cagirildi" << endl;
	auto f2x = new ResourceUser;
	f3();
	delete f2x;
	cout << "f2 sona erdi" << endl;
}

void f1()
{
	cout << "f1 cagirildi" << endl;
	auto f1x = new ResourceUser;
	f2();
	delete f1x;
	cout << "f1 sona erdi" << endl;
}

//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "main cagirildi" << endl;

	try{
		f1();
	}

	catch (int) {
		getchar();
		cout << "hata yakalandi" << endl;
	}


	cout << "main sona erdi" << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////
 

 C++'da dinamik nesne kullanýmý, C# ve Java'ya göre çok daha zor. Dinamik ömürlü bir nesnenin kullandýðý kaynaklarýn geri
 verilmesi için destructorýnýn çaðýrýlmasý gerekiyor. Destructorýnýn çaðýrýlmasý için delete edilmesi gerekiyor. Delete
 edilmesi için de delete kodunun çalýþmasý gerekiyor. Delete koduna programýn akýþý gelmeden eðer exception nedeni ile 
 programýn akýþý baþka bir noktaya çekilirse delete kodu çalýþmadýðý için de kaynaklar sýzmýþ olur. Bu çok büyük bir problem.
 Ancak bu problemin de basit bir çözümü var. Bazý akýllý pointer sýnýflarýnýn genel varlýk nedeni dinamik nesneleri kontrol
 etmek. fonksiyonlar içindeki dinamik nesne normal bir pointerý baðlanmak yerine, bir akýllý pointera baðlanýrsa o zaman
 stack'de bir nesne yaratýlmýþ olur, dil zaten bu akýllý pointer'ýn destroy edilmesinin garantsini veriyor. Akýllý pointer 
 nesnesinin destructor'ý ise o da delete kodunu çalýþtýrýr. Ýþte dinamik nesneleri kontrol ederken, normal pointerlarý 
 kullanmak yerine akýllý pointer kullanmak arasýndaki en önemli farklardan biri. Normal pointer kullanýldýðýnda exception ile
 çýkýlýrsa kaynaklar geri verilmez ancak akýllý pointerlar kullanýldýðýnda kaynaklar geri verilir. 
 

 Exception throw edildip, yakalandýðýnda yerel akýllý pointer nesneleri stack unwinding sürecinde yok edilir onlarýn destructorlarý
 da kontrol ettikleri dinamik nesneleri destroy eder.
 main cagirilir, f1 ardýndan f2 ve f3 çaðýrýlýr, fonksiyonlarýn içinde kaynaklar elde edilir. Henüz daha hata yakalayan koda girilmeden
 kaynaklar geri verilir.	
 //////////////////////////////////////////////////////////////////
class ResourceUser {
	int ma[16];
public:
	ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesi kullanimi icin kaynaklar edinildi" << endl;
	}

	~ResourceUser()
	{
		cout << this << " adresindeki sinif nesnesinin kullandigi kaynaklar geri verildi" << endl;
	}
};

void f3()
{
	cout << "f3 cagirildi" << endl;
	unique_ptr<ResourceUser> p3{ new ResourceUser };
	 
	throw 5; //exception throw edilmese zaten nesneler blok sonunda destroy edilir ve kaynaklar geri verilir.
	cout << "f3 sona erdi" << endl;
}

void f2()
{
	cout << "f2 cagirildi" << endl;
	unique_ptr<ResourceUser> p2{ new ResourceUser };

	f3();
	cout << "f2 sona erdi" << endl;
}

void f1()
{
	cout << "f1 cagirildi" << endl;
	unique_ptr<ResourceUser> p1{ new ResourceUser };

	f2();
	cout << "f1 sona erdi" << endl;
}


int main(void){ 

	cout << "main cagirildi" << endl;

	try{
		f1();
	}

	catch (int) {
		cout << "hata yakalandi" << endl;
	}


	cout << "main sona erdi" << endl;

	return 0;
}
////////////////////////////////////////////////////////////////// 



04_02_2018 PAZAR

Standartlara göre exception yakalanýrsa stack unwindig süreci iþlenecek, yakalanmazsa süreç iþlenmeyecek demiyor ancak hiçbir
derleyici exception yakalanmadýðý durumda stack unwinding yapmaz. Yýðýn geri sarýlýr, hatayý gönderen koddan hatayý iþleyen
koda programýn akýþý çekilir, bu aradaki stack framelerdeki otomatik ömürlü yerel nesneler destroy edilir. Buradaki problem
dinamik ömürlü nesneler, bu nesneler delete edilmez. 

Dinamik bellek yönetimi ile ilgili iki nokta birbirine sýk karýþtýrýlýr. Memory Allocation baþka, destructor'ýn çaðýrýlmasý baþka
iki durum. Örnek olarak bir string nesnesi yaratýldý. 
{
string s1; // otomatik ömürlü bir string nesnesi, burada constructorý çaðýrýlýr
Bloðun sonuna gelindiðinde destructor çaðýrýlýr. 

//////////////////////////////////////////////////////////////////
int main(void){ 

	cout << "sizeof(string) = " << sizeof(string) << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////
Kod çalýþtýrýldýðýnda sizeofun 24 olduðu görülür. String sýnýfý için, bir tane yazýnýn boyutunu tutacak öðe, bir tane de dinamik
bellek alanýnýn baþlangýç adresini tutacak pointer yeterli, belki bir pointer daha. 24 olmasýnýn nedeni modern string implementasyonu.
Eskiden böyle deðildi. String sýnýfý türünden nesnelerin içine dizi koyuyorlar, küçük yazýlarý kendi içinde tutuyor. Ancak yazý biraz 
daha büyük olduðunda dinamik bellek yönetimine baþvurur. Böylece küçük boyutlu yazýlar için dinamik bellek alanýnýn elde edilmesi ve 
geri verilmesi iþlemleri devre dýþý kalýr. Kendi içinde adeta bir catch alaný mevcut.

Bir string nesnesinin bellekteki görüntüsü düþünüldüðünde, içinde bir tamsayý deðiþken iki tane de pointer tutulduðu düþünülsün.
string'in tipik implementasyonunda, geri planda kullanýlan bir bellek alaný var ki bu C olsaydý bu alan malloc ile elde edilecekti.
Yazýlar bu bellek bloðunda tutulur. String sýnýfýnýn koduna bakýldýðýnda bir pointerý var, bu pointer dinamik bellek alanýný gösterir.
Bu durumda bir string nesnesi için iki ayrý bellek alanýna ihtiyaç var. Birinci bellek alaný string nesnesinin kendisinin yer aldýðý 
bellek alaný yani sizeof(string) kadar. Bizim kodda 24 byte çýktý. Eðer içinde iki pointer tutulsaydý 8 byte olurdu. Bu içinde küçük
dizi tutmasýna, small string optimization denir. 

Bu dinamik bellek alanýnýn elde edilmesini biz programcý olarak yapmayýz. Programcý ancak bunu reserve fonksiyonlarla çaðrý yaptýðýnda
orasý programcý için ayýrýlýr. Onun dýþýnda ihtiyaç duyulduðu zaman zaten bu alan otomatik olarak ayýrýlýr, hatta yer yetmediði zaman
reallocation kodunu kendi ayarlar. Yerel bir string nesnesi oluþturulduðu zaman string nesnesi için oluþturulan bellek alanýný derleyici
oluþturur, bu alan string nesnesinin alaný yani bizim örnekte sizeof'u 24 byte olan alan. Ancak dinamik bir string nesnesi oluþturulduðunda
bu bellek alanýný new operatörünün kodu ayarlar. 

//////////////////////////////////////////////////////////////////
int main(void){ 

	string *p = new string{ "Murat Ahmet Yesil" };

	return 0;
}
//////////////////////////////////////////////////////////////////
Burada önce operator new fonksiyonu çaðýrýldý, 24 bytlelýk bellek alanýný elde etti. Ardýndan string sýnýfýnýn constructor'ý bu yazýnýn
tutulacaðý bellek alanýný ayarladý. "Murat Ahmet Yesil" yazýsýnýn tutulduðu bellek alanýný destructor, delete eder, string sýnýfýnýn
destructor'ý. Yani eðer burada hayata gelen string nesnesi delete edilmezse, destructor'ý çaðýrýlmaz. Destructor'ý çaðýrýlmadýðý için de
"Murat Ahmet Yesil" yazýsýnýn tutulduðu bellek alaný iade edilmez. Bir de string nesnesinin bulunduðu yani sizeof(string) kadar olan bellek
alaný var. Onu da operator delete fonksiyonu ile geri vermemiz gerekir.

delete p; dediðimiz zaman önce delete operatorünün operandý olan adres için sýnýfýn destructor'ý çaðýrýldý. Destructor gitti, "Murat Ahmet Yesil"
yazýsýnýn tutulduðu bellek alanýný geri verdi. Ardýndan operator delete fonksiyonu çaðýrýldý, o da bu 24 bytle'lýk bellek alanýný geri verdi.
Nesnenin kendisinin yerleþtiði bellek alaný ile o nesnenin kullandýðý kaynaklarýn bulunduðu bellek alaný baþka. Nesnenin kullandýðý kaynaklar
dosyalar olabilir, bazý device'larýn kontrolü olabilir, veri tabaný baðlantýsý olabilir, buradaki gibi bir bellek alaný da olabilir. 
String ve vektörün kullandýðý bellek alanlarý da kaynak. Ýçinde 100 bin tane tam sayý tutan bir vektör düþünülsün, bu tam sayýlar vektör 
nesnesinin içinde tutulmaz, vektör nesnesinin içinde de pointer veya pointerlar var. Ýki bellek alaný birbiri ile karýþtýrýlmamalý.


//////////////////////////////////////////////////////////////////
int main(void){ 

	vector<string> svec;

	svec.push_back("Fulya Sokak");
	svec.push_back("Tarla Sokak");
	svec.push_back("Bulvar Sokak");

	return 0;
}
//////////////////////////////////////////////////////////////////
Burada ilk olarak bizim vektör nesnemizin kullandýðý bellek alaný var. sizeof(vector<string>) kadar.
Ýkincil olarak vektörün öðesi olan stringlerin tutulduðu bellek alanlarý var, sizeof(string) kadar.
Son olarak da stringlerin yazýlarýnýn tutulduðu bellek alanlarý var. 
Bu vektör örneðinde, "Fulya Sokak" gibi yazýlarýn tutulduðu belle alaný dinamik olarak elde edildi.
Bu bellek alanýný dinamik olarak elde eden string sýnýfýnýn kendi kodu.
Vektörün öðeleri olan string nesneleri de dinamik olarak elde edildi, bunu elde eden vektörün kendi kodu.
Bizim vektör nesnesi ise dinamik olarak da elde edilebilir otomatik ömürlü bir nesne olarak da yaratýlabilir. Bizim örnekte otomatik ömürlü
bir nesne hayata getirildi. Ancak;
auto pvec = new vector<string>; þeklinde oluþturulmuþ olsaydý vektör nesnesi için de bellek alaný dinamik olarak elde edilmiþ olurdu.
"Fulya Sokak" gibi yazýlarýn tutulduðu bellek alaný, string'in destructor'ý tarafýndan geri verilir.
String nesnelerinin tutulduðu bellek alanýný, vector'ýn destructor'ý geri verir. 
String nesnelerinin destructor'ýný ise, eðer vektörden bir silme yapýlacaksa hangi öðe silinecekse o öðenin destructor'ýnýn çaðýrýlmasý
sonucunu doðurur. Hiç öðe silinmezse, vector'un hayatý bittiðinde vector'ýn destructorý çaðýrýlýr, vector'un tuttuðu stringlerin her
birini destroy eder. vector içinde string tutulduðu sürece zaten vector'ýn hayatý bittiðinde onun içindeki stringlerin de hayatý biter.

Eðer ki bu stringler dinamik olsaydý ve vektörde string nesneleri deðil de string nesnelerinin adresleri tutulsaydý, vektörün hayatý 
bittiðinde stringlerin hayatý bitmezdi, stringlerin hayatýnýn bitmesi için delete edilmesi gerekir. Containerda pointer tutmanýn dezavantajý bu.
Programcý kendisi delete etmezse containerda iþi bitmesine raðmen onun içindeki adresleri kimse delete etmez. Modern C++'da bu tip durumlarý
kolaylaþtýran, vektörde pointer tutmak yerine akýllý pointer tutmak. Böylece vektörün hayatý bittiðinde içindeki akýllý pointer nesnelerini
yok eder, onlarýn destructorlarý da dinamik nesneleri destroy eder. Akýllý pointerlar kullanýldýðý zaman bu konu ile ilgili bir sýkýntý kalmaz.
Bizim string nesnesinin bellekteki yeri ayrý, o string nesnesine baðlý olarak tutulan yazýnýn bellekteki yeri ayrý. 

C++'da exception hiyerarþisi aslýnda basit bir hiyerarþi. En tepedeki taban sýnýfýn ismi exception. Exception sýnfýndan bir kaç koldan kalýtým
yapýlmýþ. Bazý kalýtýmlar doðrudan operatör seviyesinde fýrlatýlacak hata nesneleri için, mesela bad_alloc. Eðer bir dinamik bellek alaný operator
new ile elde edilmeye çalýþýlýrsa(doðrudan veya dolaylý yani new Fighter dendiðinde de operator new çaðýrýlýyor) ve operator new baþarýsýz olursa
bad_alloc sýnýfý türünden exception throw eder. bad_alloc sadece bir örnek, exceptiondan yapýlan bazý kalýtýmlar doðrudan C++'ýn bazý operatörlerinin
özel durumda göndereceði hata nesnelerinin sýnýflarý.

//////////////////////////////////////////////////////////////////
void func(size_t n)
{
	auto p = new int[n];
	memset(p, 0, n * sizeof(int));
}

int main(void){ 

	try{
	for (int k = 0; k < 100000; ++k)
		func(100000);
	}
	catch (exception &r) { //catch(bad_alloc &r)
		cout << "hata yakalandi : " << r.what() << endl;
	}

	return 0;
}
////////////////////////////////////////////////////////////////// 
Belirli bir noktadan sonra bellek alaný elde edilemediðinden badalloc throw etti, gönderilen hata nesnesini exception sýnýfý ile yakaladýk.
Gönderilen hata nesnesi ile exception arasýnda is a iliþkisi var. Aslýnda gönderilen hata nesnesinin türü bad_alloc, bad_alloc ile de ayný þekilde
hata nesnesi yakalanýr.


Run time type identification'da kullanýlan typeid isimli bir operatör mevcut veya dynamic_cast adlý bir operatör var. Onlarý yanlýþ kullandýðýmýzda da 
mesela typeid operatörünü yanlýþ kullandýðýmýzda bad_type_id isminde bir exception throw eder. dynamic_cast ise yanlýþ kullanýmda bad_cast diye bir 
exception throw eder. Exception hiyerarþisinde Exception sýnýfýndan türetilmiþ bazý sýnýflarýn tek varlýk nedeni C++'ýn kendi operatörlerinin
(new operatörü veya typeid gibi) iþini yapma sürecinde gönderilen exceptionlarýn türü olmasý. Bunlar dýþýnda iki tane hiyerarþinin derinliðini 
arttýrmaya yönelik genel sýnýf oluþturulmuþ bunlardan biri, logic_error diðeri ise runtime_error. Standart kütüphane logic_error ve runtime_error
sýnýflarýndan kendisi de türetme yapmýþ. Programcý olarak exception sýnýfýndan kalýtým yolu ile sýnýf oluþturulabilir. 

Exception sýnýfýnýn default constructor'ý var, copy constructor'ý var. Operatör atama fonksiyonu var ve de what isimli bir const char * döndüren
sanal bir fonksiyonu var. saf-sanal olmadýðýndan bu ister override edilir, ister edilmez. Bu fonksiyon ancak eðer bu fonksiyona yaptýrýlacak
özel bir iþ varsa override edilir. Normal olarak bu fonksiyon o hatayý belirleyen yazýyý döndürür. Sýnýfýn parametreli ctor'ý yok. Ancak bundan
sonraki logic_error ve runtime_error sýnýflarýnýn hepsinin bir string parametreli veya const char * parametreli ctor'larý var. Normalde bunlar
what fonksiyonunun vereceði yazýyý argüman olarak göndeririz.

Diðer hata sýnýflarýnýn baþlýk dosyasý exception deðil, bir iki istisna dýþýnda hepsinin baþlýk dosyasý stdexcept. exception isminde bir baþlýk
dosyasý var, exception baþlýk dosyasýnda sadece exception sýnýfý var. Standart kütüphanenin kendi kalýtým yolu ile elde ettiði sýnýflarýn baþlýk
dosyasý stdexcept. Örneðin logic_error sýnýfý exception'dan türetilmiþ ve stdexcept içinde. Logic_error'dan da türetilmiþ sýnýflar var. C++11'den
önce exception sýnýflarýnýn sadece const char * parametreli ctorlarý vardý, C++11'den itibaren eskileri silmediler ancak const char * olanlara
bir de string overloadý verildi. logic_error sýnýfýnýn da hem const char * hem de string parametreli ctorlarý var. Bu verilecek olan yazý içeride
what'ýn döndüreceði yazý olarak içerde tutulur. 


//////////////////////////////////////////////////////////////////
class Fighter {
public:
	void setDistance(int distance)
	{
		if (distance > 10000)
			throw out_of_range{ "uzak mesafeye kacan savasci hatasi!!!" };
	}
};


int main(void){ 

	Fighter f;

	try{
		f.setDistance(23456);
	}catch (exception &r)
	{
		cout << "Hata Yakalandi : " << r.what() << endl;
	}

	return 0;
}
//////////////////////////////////////////////////////////////////
logic_error ve runtime_error sýnýflarýndan sonra exception sýnýflarýnýn yazý isteyen parametreleri var. Onlara geçilen argüman aslýnda what'ýn 
döndürdüðü yazýyý set eder.

Kendimiz bir exception sýnýfý oluþturduk, logic_error'dan kalýtým yolu ile sýnýf elde ettik, hatanýn adý da bad_fighter. Neden what fonksiyonunu
override etmek isteyelim ? override etmek zorunda deðiliz, eðer tek istediðimiz burada olduðu gibi bir yazýyý iletmekse zaten taban sýnýfýn
contructor'ý bu iþi yapýyor. Çok daha özel bir yazý isteniyorsa, mesela FileReadError örneðinde olduðu gibi, ilgili kalýtým yapýlsa olsa olsa
constructor ile verilen yazý elde edilir. Ancak þöyle bir yazý isteniyorsa "þu dosyanýn 17.satýrýnda okuma hatasý", what fonksiyonunun bunu
vermesinin imkaný yok. Bunu ancak exception'ý throw eden kod gönderir, what'ýn geri döndürdüðü yazýnýn böyle olabilmesi için what fonksiyonunun
override edilmesi gerekir. 

Exception ile ilgili yazýlan kodlarda, baþlangýçta kod yazaný en çok þaþýrtan durumlardan biri þu: try ve catch bloklarýnýn sözde deðil özde de blok
olduðunu anlamakta zorluk çekmeleri, onlar bir blok dolayýsý ile orasý bir scope. try'in içinde bir isim tanýmlayýp, catch içinde de onu kullanmaya
çalýþmak bu görülen hatalardan biri. O bir blok, try içinde tanýtýlan isim ancak onun içinde kullanýlabilir. Derleyicinin kurallarýna göre try ve
catch bloklarý ayrý bloklar olduðundan bunlar içinde tanýmlanan deðiþkenler blok dýþýnda kullanýlamaz. Ömür açýsýndan da ayný þekilde. try bloðu
içinde oluþturulan nesnenin ömrü bloðun sonunda biter.

Dinamik nesneler C++'da kullanýmý diðer dillere göre daha problematik, burada akýllý pointerlarýn kullanýmý önemli. Dinamik nesneyi delete etmeyi
unutma durumuna karþý akýllý pointerlar kullanýlýr, zaten kendi hayatlarý bittiðinde dinamik nesneyi de delete eder. Verilmesi gereken karar ise
dinamik nesneyi ayný anda bir kod mu birden fazla kod mu kullanacak ? Dinamik nesnenin t anýnda tek bir sahibi olacaksa exclusive ownership ile 
kullanýlacaksa unique_ptr, ayný zamanda birden fazla sahibi olacaksa shared_ptr. Garanti olan ise hangisinin kullanýldýðýndan baðýmsýz olarak
dinamik nesneyi gösteren bir pointer kalmadýðýnda onun da hayatý sonlanacak. Akýllý pointerlarýn asýl önemli faydalarýndan biri de exception
handling. Bu pointerlar olmasaydý dinamik nesneler normal pointerlara baðlanacaktý ve onlar delete edilecekti. Delete etmeyi unutmanýn dýþýndaki
problem ise delete koduna varamadan exception throw edilmesi. Akýllý pointerlara baðlanýp exception gönderilir ve yakalanýrsa stack unwinding 
olacak, orada da otomatik yerel sýnýf nesneleri destroy edilecek, onlar destroy edildiðinde de dinamik nesneler destroy edilir. 

Bir exception neden yakalanýr ? Exception yakalandýðýnda ne yapýlýr ?
Eðer yapýlacak bir þey yoksa exception yakalanmaz. En çok yapýlan hatalardan biri de bu. Eðer hata gelme ihtimali olan her yer try catch bloklarý
ile donatýlýrsa C kodundan bir farký kalmaz kodun. Ancak müdahale edilmesi gerekiyorsa exception yakalanýr, kimi ilgilendiriyor ise o yakalamalý.
Farklý yerlerede try bloklarý olabilir, biri yakalamaz ancak ondan daha yukaridaki katmanda biri yakalayabilir.


//////////////////////////////////////////////////////////////////
void f3()
{
	cout << "f3 cagrildi\n";
	try{
		if (1) {
			throw 1;
		}
	}
	catch (int x) {
		cout << "hata f3 icinde yakalandi\n";
	}
	cout << "f3 sona erdi\n";
}

void f2()
{
	cout << "f2 cagrildi\n";
	try{
		f3();
	}
	catch (long x) {
		cout << "hata f2 icinde yakalandi\n";
	}
	cout << "f2 sona erdi\n";
}

void f1()
{
	cout << "f1 cagrildi\n";
	try {
		f2();
	}
	catch (char x) {
		cout << "hata f1 icinde yakalandi\n";
	}
	cout << "f1 sona erdi\n";
}


int main(void){ 

	cout << "main cagrildi\n";

	try {
		f1();
	}
	catch (float x) {
		cout << "hata f1 icinde yakalandi\n";
	}

	cout << "main sona erdi\n";

	return 0;
}
//////////////////////////////////////////////////////////////////
Hata nesnesi int türünden, eðer double türünden olsaydý yakalanmazdý þimdi ise f3 tarafýndan yakalanýr.
Hata yakalanýr ancak programý sonlandýracak bir mekanizma olmadýðýndan kod oradan normal þekilde devam etti.


Örnek olarak bir hatayý yakalamaya çalýþýyoruz, mesela memory error oluþursa müdahale edeceðiz. Müdahale edeceðiz
ancak ne yapacaðýz ? Uygulamaya baðlý olarak neler yapýlabilir:
1)Hata yakalanýr, yapýlmasý gereken bazý iþlemler yapýlýr ve o noktada programý sonlandýrma kararýný verebilecek durumda ve sorumluluktayýzdýr.
O zaman gerçekten prorgam sonlandýrýlabilir.
2)Hatayý yakalamak ve hata nesnesini tekrar göndermek. Yani bizim yapacaðýmýz bazý iþler var ancak bizden bu kadar artýk geri kalanýný 
yukarýdakiler düþünsün. Exception yakalanýr, kýsmi müdahale edilir ayný hata nesnesi daha yukarýdaki katmanlara gönderilir. Böylece hataya
birden fazla yerde müdahale edilir. Yakalanan hata nesnesi kýsmi müdahaleden sonra tekrar yukarýya gönderilecekse bunun için özel bir throw
statement'e ihtiyaç var: rethrow statement. Baþka dillerde rethrow bir keyword olabilir, C++'da ayrýca bir keyword yok. throw keywordü 
ifadesiz kullanýldýðýnda rethrow anlamýna gelir.

throw; ifadesi C++'da rethrow anlamýna gelir. Eðer bir exception yakalanmýþsa, catch bloðu içinde bu throw statement yürütülürse derleyicinin
gönderdiði hata nesnesi tekrar yukarýya gönderilir. Ayný nesne gönderilir. 
Þöyle bir catch bloðu olsun:
catch(myexception &r){
	throw;
	throw r;
}
Bu ikisi arasýnda çok ciddi fark var. rethrow statement kullanýldýðýnda, derleyici ayný nesneyi gönderir, ilk hazýrladýðý orjinal nesne.
Eðer nesne referans yolu ile alýnýp, manipüle edildiyse yukarýya tekrar gönderildiðinde ayný nesne gönderilmiþ olur.
throw r; dendiðinde ise derleyici öbür nesnenin hayatý biteceðinden onu sonlandýrýr. Bu ifadeden hareketle yeni bir nesne oluþturur.
Ayný isim kullanýldýðýndan ayný nesne throw edilmiþ olmaz, bu rethrow deðil, ayný nesne throw edilmiþ olmaz.
throw statement'deki ifade derleyicinin gönderdiði nesnenin kendisi deðil, ikincideki gibi yapýlýrsa yeni bir nesne oluþturulmasý saðlanýr. 


//////////////////////////////////////////////////////////////////
class Myexception{
	int mx;
public:
	Myexception(int x) : mx{x} {}
	void set(int val) { mx = val; }
	void display()const { std::cout << "mx = " << mx; }
};

void f1() 
{
	cout << "f1 cagrildi\n";
	try{
		throw Myexception{ 12 }; //geçici nesne ile exception throw edildi.
	}
	catch (Myexception &r) {
		cout << "hata f1 icinde yakalandi : " << endl;
		r.display();
		r.set(3446);
		throw;
	}
}

int main(void){ 
	
	f1();

	return 0;
}
//////////////////////////////////////////////////////////////////
Kod çalýþtýðýnda exception f1 içinde yakalanýr. Oradaki yazýlar çýkar ondan sonra rethrow edildiði için tekrar gönderilir. 
Ayný þey þimdi de geçerli, tekrar yakalanmadýðý için yine uncaught exception. rethrow edilmesi olayýn bittiði anlamýna gelmez, yine de
yakalanmasý gerekir. Tekrar yakalanmazsa yine uncaught exception.


//////////////////////////////////////////////////////////////////
class Myexception{
	int mx;
public:
	Myexception(int x) : mx{x} {}
	void set(int val) { mx = val; }
	void display()const { std::cout << "mx = " << mx << endl;  }
};

void f1() 
{
	cout << "f1 cagrildi\n";
	try{
		throw Myexception{ 12 }; //geçici nesne ile exception throw edildi.
	}
	catch (Myexception &r) {
		cout << "hata f1 icinde yakalandi : " << endl;
		r.display();
		r.set(3446);
		throw;
	}
}

int main(void){ 
	
	try{
		f1();
	}
	catch (Myexception &r) {
		cout << "hata main icinde yakalandi..\n";
		r.display();
	}
	return 0;
}
//////////////////////////////////////////////////////////////////
Tekrar gönderildiði zaman bu sefer ayný hata nesnesi main içinde yakalandý.



rethrow'da, rethrow statementinin fiilen catch bloðunun içinde olmasý gerekmiyor. Örnek olarak bu durumda yardýmcý bir fonksiyon
yazýlmýþtýr, bu fonksiyon çaðýrýlýr. Bu hala catch bloðu içinde çalýþan bir kod olduðundan func'ýn içinde de rethrow edilebilir.
//////////////////////////////////////////////////////////////////
class Myexception{
	int mx;
public:
	Myexception(int x) : mx{x} {}
	void set(int val) { mx = val; }
	void display()const { std::cout << "mx = " << mx << endl;  }
};

void func() {
	cout << "hata isleme surecinde func islevi cagriliyor ve rethrow ediliyor\n";
	throw;
}

void f1() 
{
	cout << "f1 cagrildi\n";
	try{
		throw Myexception{ 12 }; //geçici nesne ile exception throw edildi.
	}
	catch (Myexception &r) {
		cout << "hata f1 icinde yakalandi : " << endl;
		r.display();
		r.set(3446);
		func();
	}
}

int main(void){ 
	
	try{
		f1();
	}
	catch (Myexception &r) {
		cout << "hata main icinde yakalandi..\n";
		r.display();
	}
	return 0;
}
//////////////////////////////////////////////////////////////////

Bu durumda dolayýsýyla derleyici rethrow statement'i bir fonksiyon içinde görse compile time'da sentaks hatasý verme 
ihtimali yok. Yani bir fonksiyon yazýlýyor, derleyici þu fonksiyonu görüyor:
void func() {
	cout << "hata isleme surecinde func islevi cagriliyor ve rethrow ediliyor\n";
	throw;
}
Derleyici bu fonksiyonun ne zaman çaðýrýlacaðýný bilemez.
Þöyle bir kural var, böyle bir fonksiyonun kodu normal yolla çaðrýlýrsa o zaman yine terminate çaðrýlýr.
Yani func gibi bir fonksiyon doðrudan çaðýrýlýrsa runtime'da kod func'a gelir ancak ortada bir hata nesnesi yok ki rethrow etsin.
Derleyicinin hazýrladýðý bir exception nesnesi yok. Bu durumda yine terminate çaðrýlýr.

Terminate'in çaðýrýlmasý kötü bir durum artýk program sona eriyor. Dolayýsýyla ne yapýlacaksa program terminate etmeden yapýlmasý
gerekir. Peki hangi senaryolarda terminate çaðrýlýr ?
Birinci senaryo uncaught exception. Hata gönderilmiþtir ve hata nesnesi yakalanamamýþtýr. Buna ortada catch bloðu yoksa yakalanamamasý,
catch bloðu varsa ancak türün tutmamasý da dahil. Yakalanmýþ, rethrow edilmiþ, o yakalanamamýþtýr, o da dahil. Bunlarýn hepsi uncaught
exception, bu durumda terminate çaðrýlýr. Terminate ise abort'u çaðýrýr. Terminate'in default davranýþýný deðiþtirmek için ise 
setTerminate isimli fonksiyon çaðrýlýr.
Ýkinci senaryo ise, bir fonksiyonun kodu çalýþmýþtýr, onun içinde rethrow statement vardýr ancak ortada bir hata nesnesi yoktur. Yine
terminate çaðrýlýr.
Toplamda 6-7 senaryo var.


//////////////////////////////////////////////////////////////////
void f2()
{
	try{
		throw out_of_range{ "hata hata hata" };
	}
	catch (exception &r) {
		cout << "hata f2 icinde yakalandi rethrow ediliyor\n";
		throw; //1
		throw r; //2
	}
}

void f1()
{
	f2();
}

int main(void){ 

	try{
		f1();
	}
	catch (out_of_range &x) {
		cout << "hata main icinde yakalandi" << endl;
	}
	return 0;
}
//////////////////////////////////////////////////////////////////
main f1'i çaðýrýyor, f1 ise f2'yi çaðýrýyor. f2 içinde out_of_range sýnýfý türünden bir hata gönderiliyor.
exception sýnýfý türünden bir nesne ile yakalanýp ve rethrow ediliyor. main'de hata out_of_range ile yakalanýyor.
rethrow ettiðimde hatanýn tür bilgisini kaybeder miyim ? Gönderilen hata out_of_range türünden, ancak exception ile
yakalanýp rethrow ediliyor. Koda çalýþtýrýldýðýnda hata f2 icinde yakalanýp rethrow edilir, main içinde ise
out_of_range ile yakalanýr. Demek ki rethrow edildiðinde tür bilgisi kaybolmuyor.

Kodda bir deðiþiklik yapýlsa f2 içinde throw r; yapýlsa bu ayný þey deðil. Artýk gönderilen hata nesnesinin türü
runtime'da out_of_range türünden deðil. Öyle olsaydý burasý yine yakalardý. rethrow etmek ile ayný hata nesnesini
tekrar göndermek arasýnda ciddi bir var. rethrow edildiðinde polimorfik, dinamik tür korunur. Ancak ayný nesne 
gönderildiðinde artýk o polimorfik tür bilgisi ortadan kaybolur.

En çok yapýlan iþlerden biri de, hata yakalanýr, yine bir hata nesnesi gönderilir. Ancak gönderilen hata nesnesi 
baþka bir türden. Bazý durumlarda alt katmanlardaki kodlar tipik olarak bir hatayý yakalayýp kýsmi olarak müdahale
ettikleri zaman kendileri de daha yukarýdaki katmanlara onlarýn anlayacaðý dilden bir exception gönderir.
Örnek olarak bir GUI programý düþünülsün, ortada bir Text editör var ve text editore yazý yazýlamýyor. Aþaðýdaki
katmanlardan gelen hata ise bellek ile ilgili bir problemden dolayý oluþan segmentation fault. Gelen bu hata yakalanýr
ve üst katmanlara bu hali ile deðil daha farklý bir þekilde iletilebilir.

void f()
{
	try{
		///
	}
	catch(bad_alloc &){
		////
		throw BadTextInfo;	
	}
}

f içinde bad_alloc türünden bir hata nesnesi yakalanýr, içeride gerekli iþlemler yapýlýr sonuç olarak ise BadTextInfo 
isminde bir hata nesnesi throw edilir. f fonksiyonunu çaðýran için BadTextInfo anlamlý ancak daha alt katmandaki hata
kategorileri f'i çaðýran için anlamlý ve müdahale edilebilir deðil. Bu sebeple daha alt katmanlardaki hata yakalayan
kodlar hatayý yakaladýklarý zaman birçok durumda var olan exception object'i göndermezler, kendileri yeni bir exception
nesnesi oluþturup, bunu daha üst seviye bilgi ile donatýp kendilerinden daha yukarýdaki katmana bunu bildirirler.
Buna popüler olarak exception translation denir; baþka bir exception alýndý ancak onu göndermek yerine daha yukarýdaki
kodlara farklý bir exception gönderildi.

Bunlar dýþýndakiler artýk pek olaðan durumlar deðil, ya program terminate edilir, ya rethrow edilir veya translate edilir.
Genel olarak bunlardan biri yapýlýr.


Constructors and Exceptions

En fazla exception göndermeye aday fonksiyon constructor. Kodu çalýþacak, bir nesneyi hayata getirecek fakat o süreç içinde 
beklenmeyen bir durum olduðunda nesne hayata gelemeyecek. Bu durumda daha yukarýdaki kodlarý bundan haberdar etmesi gerekecek.
DatabaseConnection türünden bir nesne hayata gelecek ki bu connection saðlansýn. Ancak nesne hayata gelemiyorsa o nesneyi hayata
getiren açýsýndan bakýldýðýnda veritabaný baðlantýsýnýn yapýlamadýðý anlamýna gelecek. Diðer fonksiyonlar bazý nedenlerden dolayý
exception kullanmayabilir, geri dönüþ deðeri ile hatayý iletme durumunda olabilirler. Constructor'ýn böyle bir imkaný da yok.
Geri dönüþ deðeri kavramý yok, geri dönüþ deðeri mekanizmasý ile hata döndürme gibi bir durumu da yok. Constructor'ýn kodundan
exception gönderilmesi kadar doðal bir durum yok. Destructor'dan ise exception gönderilmemeli, gönderilecekse de dýþarý sýzmamalý.
(Kendi içerisinde handle edilsin, yakalansýn)

Örnek olarak Fraction sýnýfý, paydanýn 0 olacaðý bir Fraction nesnesi yaratýlmaya çalýþýldýðýnda, ideali constructor'ýn bir 
exception throw etmesi.

Bir sýnýfýn constructor'ýnýn kodu yazýlýyor:
Fighter::Fighter()
{
	/////codes

	throw x;

	/////
}
Eðer bu constructor'ýn çalýþmasý durumunda programýn akýþý bu throw ifadesini görmezse, kod sonuna kadar çalýþýr. Constructor'un
kodu tamamlanýr ve nesne hayata gelir. Eðer exception throw ederse hayata gelen bir nesne olmayacak. Bir nesnenin hayata gelmesi
için constructor'ýn kodunun çalýþmasý gerekir.
Exception nedeni ile throw x; ifadesi ile koddan çýkýldýðý düþünülsün. Hayata gelememiþ, bu Fighter nesnesi için destructor çaðrýlmaz.
Önemli kurallardan biri, bir constructorýn kodunun içinden exception throw edildiði için çýkýlýrsa hayata gelememiþ *this için 
kesinlikle destructor çaðrýlmaz.

Exception güvenliði düþünüldüðünde, tüm exceptionlar yakalanmalý ve destructor'ý çaðýrýlmasý gereken bütün nesnelerin destructor'ý
çaðrýlmalý. Çünkü eðer bir nedenden dolayý destructor'ý gerekli bazý iþlemleri yapan(kaynaklarý geri veren) bir destructor 
çaðrýlmazsa ortada sorunlu bir durum var demektir. Ýdeal durum, hayata gelmiþ tüm nesneler için destructor'ýn çaðrýlmasý.


//////////////////////////////////////////////////////////////////
class Fighter {
public:
	Fighter(int x)
	{
		cout << "constructor" << endl;
		if(x>10)
			throw 1;
	}
	~Fighter()
	{
		cout << "destructor" << endl;
	}
};
int main(void) {

	Fighter f{ 50 };

	return 0;
}
//////////////////////////////////////////////////////////////////
Kodda görüldüðü üzere exception gönderilir, ancak destructor çaðrýlmaz.
Çaðrýlmamasýnýn nedeni hatanýn yakalanmamasý deðil, nesnenin zaten hayata gelmemiþ olmasý.


Burada ise nesne dinamik olarak hayata geliyor.
Dinamik nesne için constructor çaðrýlýr ve exception throw eder.
Bu durumda, dinamik nesne için aslýnda geri planda bir dinamik bellek alaný elde edilir, bunu elde eden
new karþýlýðý derleyicinin ürettiði kod, operator new fonksiyonu.
Ardýndan bu adresle constructor çaðrýlýr o da exception throw eder. Normalde bu nesne delete edilecekti ve 
bellek alaný geri verilecekti ve de destructor çaðrýlacaktý.
Burada ise destructor çaðrýlmadýðýndan nesne hayata gelmedi. Peki o ayrýlan bellek alaný ne olacak ?
Dil bu bellek alanýnýn geri verileceðinin garantisini verir. Dinamik nesne new operatörü ile oluþturulursa
dinamik nesne için çaðrýlan ctor exception throw ederse, zaten ortada çaðrýlacak bir destructor yok(nesne 
hayata gelmedi) ortadaki bellek bloðunu derleyici geri verir(kendi ürettiði kodla). 
//////////////////////////////////////////////////////////////////
class Fighter {
public:
	Fighter(int x)
	{
		cout << "constructor" << endl;
		if(x>10)
			throw 1;
	}
	~Fighter()
	{
		cout << "destructor" << endl;
	}
};

int main(void) {

	try {
		auto p = new Fighter{ 50 };
	}
	catch (int) {
		cout << "hata main icinde yakalandi" << endl;
	}
	return 0;
}
//////////////////////////////////////////////////////////////////


Peki ya constructor'ýn kodunda, throw edilmeden önce bir kaynak elde edilmiþse bundan tabiki de
programcýnýn kendisi sorumlu. Constructor throw etmeden, ctor kodu içinde kaynaklar elde edilmiþse,
bu kaynaklar normal pointerlara baðlandýysa bunlarý delete etmek programcýnýn iþi. Constructor da olsa
raw pointer kullanýlmamalý. Hiç kaynak sýzýntýsý olmamasý için nesnenin kullandýðý kaynaklar akýllý
pointerlara baðlanmalý. Bu durumda kaynaklar raw pointerlara baðlandýðýnda, pointer deðerini alýr ancak
normalde bu pointerý delete edecek olan destructor. Exception throw edilmesinden dolayý destructor 
çaðrýlmayacaðýndan kaynak geri verilmemiþ olur. Kaynaklar normal pointerlara baðlanmadýðý sürece 
ortada bir problem yok.


Fighter sýnýfýnýn elemanlarýndan biri Anyclass türünden olsun. Bu durumda bir Fighter nesnesi hayata	
geldiðinde Anyclass nesnesi de hayata gelir. Fighter'ýn constructor'u burada yine exception throw eder.
Bu noktada Anyclass nesnesi hayata gelmiþ olur, bununla ilgili de ortada problemli bir durum yok.
Hayata gelenlerin hepsi destruct edilir. Dikkat edilmesi gereken programýn akýþý constructor'ýn koduna
girdiðinde eðer bu noktaya kadar bazý nesneler hayata gelmiþ ancak dinamik olarak hayata gelmiþ ve raw
pointerlara baðlanmýþsa bunlarýn delete edilmesinden programcý sorumlu.
//////////////////////////////////////////////////////////////////
class Anyclass {

};

class Fighter {
	Anyclass mx;
public:
	Fighter(int x)
	{
		cout << "constructor" << endl;
		if(x>10)
			throw 1;
	}
	~Fighter()
	{
		cout << "destructor" << endl;
	}
};
//////////////////////////////////////////////////////////////////
Fighter sýnýfýnýn construct'ý çalýþtýrýldýðýnda, o da Anyclass sýnýfýnýn constructor'ýný çalýþtýrýr. 
Anyclass'ýn constructor'ý exception throw ederse: Bu durumda member hayata gelmemiþ demektir dolayýsý
ile member için destructor çaðrýlmaz. Fighter da bu durumda hayata gelmemiþ olacak, ikisi için de 
destructor çaðrýlmaz.


Aþaðýdaki gibi ayný veya farklý sýnýf türünden iki öðe var. mx hayata geldi ancak my için çaðrýlan
constructor exception throw etti. Yine ortada problemli bir durum yok. my için ve Fighter için destructor
çaðrýlmaz ancak mx için çaðrýlýr.
//////////////////////////////////////////////////////////////////
class Anyclass {

};

class Fighter {
	Anyclass mx, my;
public:
	Fighter(int x)
	{
		cout << "constructor" << endl;
		if(x>10)
			throw 1;
	}
	~Fighter()
	{
		cout << "destructor" << endl;
	}
};
//////////////////////////////////////////////////////////////////

Yani constructor'dan exception göndermek konusunda tereddüt edilecek bir durum yok.


Ancak problemli bir durum var. Bu problemli duruma karþý ise dilin ilginç bir aracý var.
Member olarak kullanýlan bir sýnýf var ve bu sýnýf exception gönderme potansiyelinde.
Bir de Owner sýnýfý var, Member sýnýfý türünden bir öðesi var.
//////////////////////////////////////////////////////////////////
class Member {
public:
	Member(int x)
	{
		cout << "Member constructor" << endl;
		if (x > 100)
			throw 1;
	}
};

class Owner {
	Member mx;
public:
	Owner(int val) : mx{val}
	{
		/*try{
		}*/
	}
};

int main(void) {

	Owner ox{ 325 };

	return 0;
}
//////////////////////////////////////////////////////////////////
Bir Owner nesnesi yaratýlýrken onun Member'i construct edilmeye çalýþýldýðýnda bu örnekte olduðu gibi
Member'in constructor'ý exception throw ederse Owner'ýn ve Member'in destructor'ýnýn çalýþmayacaðýný 
biliyoruz. Bu hata programcý olarak main içinde yakalanabilir. 
Peki bir nedenden dolayý constructor bu hatayý yakalamak istiyorsa ? Constructor'ýn memberlarýndan biri
exception throw ederse, bu exception nasýl yakalanýr ?
Owner'ýn constructor'ý, Member'in constructor'ýndan gönderilecek hata nesnesini yakalamak için ne yapmalý ?
Bir try bloðu oluþturulacaksa yapýlabilecek en iyi þey fonksiyonun tüm kodunu try bloðu içine yazmak ancak
burada bu da geçerli deðil. Member'ýn hayata gelmesi, Owner'ýn constructor'unun kodu içinde olmuyor ki.
Programýn akýþý constructor'ýn kodu içine geldiðinde Member zaten hayata gelmiþ durumda. Member'in ctor'u
exception throw ederse zaten try bloðu içindeki kod hiç çalýþmaz.

Ýþte bunun için function try blok isminde bir araç dile eklendi(2000'lerin baþýnda)
Function try blok, main de dahil olmak üzere herhangi bir fonksiyona uygulanabilecek bir sentaks ancak
kesinlikle varlýk nedeni üstte bahsedilen duruma problem getirmek.
Normal yukarýda yoruma alýndýðý þekliyle bir try bloðu oluþturulduðu zaman, Member'larýn constructor'ýnýn
çalýþma kodu bu try bloðunun dýþýnda kalýyor ama function try blok oluþturulduðunda onu da try bloðunun
içine katabilme imkanýmýz var. Bir member'ýn gönderdiði exception'ý, o Member'a sahip olan sýnýfýn 
constructor'ýnýn kodunun yakalayabilmesinin tek yolu function try blok.


Normal fonksiyonlar için function try bloðu:(Normal bir fonksiyon söz konusu olduðunda görsellikten baþka
fazla da bir katkýsý yok)
Bir fonksiyonun gövdesinin tamamý try blok içine alýnmak isteniyor, fonksiyonun içine hiç kod yazýlmaz.
//////////////////////////////////////////////////////////////////
void func()
{
	try {

	}
	catch (int x) {

	}
}
//////////////////////////////////////////////////////////////////
Bütün kod try bloðu olsun istenirse, function try blok kullanýlmazsa bu þekilde yazýlabilir.

Function try blok ise þöyle bir sentaks hakký verir: Fonksiyonun ana bloðu ile try bloðu ayný, tekrar yazýlmaz.
 //////////////////////////////////////////////////////////////////
void func()
try
{

}
catch (int x) {

}
//////////////////////////////////////////////////////////////////
main dahil herhangi bir fonksiyona function try blok uygulanabilir.
Ancak function try bloðun varlýk nedeni bu deðil. Varlýk nedeni Member'larýn ctor'undan gönderilen exceptionlarý
yakalama isteði.


//////////////////////////////////////////////////////////////////
class Member {
public:
	Member(int x)
	{
		cout << "Member constructor" << endl;
		if (x > 100)
			throw 1;
	}
};

class Owner {
	Member mx;
public:
	Owner(int val) : mx{val}
	{
		try {

		}
		catch (int x) {
			cout << "hata Owner ctor icinde yakalandi" << endl;
			throw;
		}
	}
};

int main(void) {

	Owner ox{ 299 };

	return 0;
}
//////////////////////////////////////////////////////////////////
Kod Owner sýnýfýnýn constructor'ý içindeki try bloðuna gelmez bile.
Buradaki gibi bir ctor'un tüm kodu bir try bloðu içine yazýlsa ona catch konsa, Memberlarýn constructorlarýndan
gelen exception yakalanamaz. Eðer yakalansaydý programýn akýþý catch bloðunun içine girecekti.

Owner sýnýfýnýn constructor'ý aþaðýdaki gibi function try blok içine alýndýðýnda hatanýn yakalandýðý görülür.
//////////////////////////////////////////////////////////////////
class Member {
public:
	Member(int x)
	{
		cout << "Member constructor" << endl;
		if (x > 100)
			throw 1;
	}
};

class Owner {
	Member mx;
public:
	Owner(int val) try : mx{ val }
	{

	}
	catch (int x) {
		cout << "hata Owner ctor icinde yakalandi.." << endl;
		throw;
	}
};

int main(void) {

	try {
		Owner ox{ 299 };
	}
	catch (int x)
	{
		cout << "hata main icinde yakalandi" << endl;
	}
	return 0;
}
//////////////////////////////////////////////////////////////////


Tipik bir C++ sisteminde ki buna standart kütüphane sýnýflarý da dahil, sýnýflar exception safety açýsýndan
üçe ayrýlýr. Kategoriler 1)weak garanti 2)strong garanti 3)no throw garanti
En iyi durum no throw garantisi. Burada exception throw ettirilmeyeceðinin garantisi verilir. Her halükarda 
fonksiyon iþini yapacak. Ýlgili sýnýfýn kendisinden kaynaklanan faaliyetlerden hiçbir þekilde exception
throw edilmeyeceðinin garantisi verilir. Yani bu sýnýf ile ilgili hiçbir nedenden dolayý bir try bloðu
oluþturulmak zorunda deðiliz. Sýnýf iþini yapacak.
Strong garanti ise, exception gönderilebilir ama exception yakalandýktan sonra kodlar hala kullanýlabilir 
durumda. Ayný deðer garanti edilmiyor ancak kullanýlabilirliði garanti. Örnek olarak bir vektör nesnesi 
exception throw etti ancak o vektör hala kullanýlabilir.
Weak garanti ise, kaynak sýzdýrmama garantisi verir. Tüm edinilen kaynaklar geri verilir. Ancak tekrar
kullanýlamaz. Exception yakalandýðýnda bellek sýzýntýsý olmayacak ama nesnenin tekrar kullanýlmasý mümkün
deðil.



Destructors and Exceptions

Destructor exception göndermemeli. Exception'ýn dýþarý sýzmasý deðil, bir destructor'ýn exception göndermesi
durumu dahi sýradýþý. Çok sýradýþý bir senaryoda exception gönderilme ihtiyacý olursa da o exception dýþarý
çýkmamalý, destructor'ýn kodu exception'ý yakalamalý.
Constructor için bu kadar doðal olan bir durum neden destructor'a gelindiðinde hiç gönderilmemeli ?
Destructor bir nesnenin hayatý bittiðinde sonlanýyor, çaðrýldý ve de nesnenin kaynaklarý geri verildi. 
Bir nedenden dolayý kaynaklar geri verilememiþ olsun ve exception gönderdi. Exception'ý yakalayan ne 
yapabilir ki ? Kaynaklarý destructor geri veremiyorken hatayý yakalayan kodun bunu yapmasý mümkün deðil.
Lojik olarak destructor'ýn göndereceði exception'dan bir fayda ummak doðru deðil.

Destructor bir nesnenin hayatý sonlanacaðý zaman çaðrýlýr. Peki bir nesnenin hayatý neden sonlandýrýlýr ?
Blok sonuna gelinmiþtir, destructor çaðrýlmýþtýr veya delete operatörü kullanýlýp destructor çaðrýlmýþtýr.
Ancak baþka bir durum daha var zaten exception gönderilmiþtir, bu exception yakalanmýþtýr, handle edilecektir.
Stack unwinding süreci devam etmektedir, stack'deki yerel nesneler için destructor çaðrýlmaktadýr. 
Zaten stack unwinding'in bütün faydasý, beklentisi hayata gelen nesneler destroy edilsin ki kaynaklarý geri
verilsin. Þimdi bu nedenle çaðrýlmýþ bir destructor bir de exception throw ederse, kaynaklar nasýl geri
verilecek ? Hayatta olan nesnelerin destructorlarýnýn çaðrýlma süreci sekteye uðramýþ olur.

Stack unwinding sürecinde bir hata yakalanmýþ, stack unwinding yapýlmýþ, stackdeki yerel nesnelerden birinin 
destructor'ý çaðrýlýyor ama o destructor'da yine exception throw ediyor. Zaten exception yakalandý da buraya
gelindi, bir de yine exception throw ediliyor. Ýþte bu durumda terminate fonksiyonu çaðrýlýr.
Terminate'in çaðrýlma senaryolarýna bir de bu eklenir. Exception handle edilirken stack unwinding sürecinde bir
nesnenin destructor'ý çaðrýlmýþsa ve çaðrýlan destructor yine exception throw etmiþse ve bu exception destructor'dan
dýþarý çýkmýþsa derleyici terminate fonksiyonunu çaðýrýr. Bu durumda destructor içinde exception göndermek hele 
bir de stack unwinding'de sürecinde çaðrýlmasý sonuç tam bir felaket. 



R.T.T.I (Run Time Type Identification)

Polimorfik türler söz konusu olduðunda bir nesnenin statik türü ile dinamik türü farklý olabiliyor.
void carGame(car *ptr); buradaki *ptr nesnesi compiler'in compile time sürecinde yaptýðý kontrolelr açýsýndan Car
türünden ama runtime davranýþý yani dinamik açýdan bakýldýðýnda bir Bmw de Audi de olabilir. Nesne yönelimli 
programlamanýn runtime polimorfizm ile ilgili araçlarý þöyle bir avantaj saðlamaya yönelik: programcý zaten bu
polimorfik iþlemede nesnenin türünün ne olduðunu bilmek zorunda deðil. Zaten nesnenin türünün ne olduðuna baðlý 
olarak bir kod yazýlýyorsa ortada doðru olmayan bir durum var çünkü bu yapýlýrsa eski kodlarýn yeni kodlarý kullanma
avantajý tamamen ortadan kalkar. Yani örnek olarak carGame fonksiyonu için buraya gelen araba Mercedes ise þu yapýlsýn,
Bmw ise bu yapýlsýn, yani dinamik türe göre iþ yapýlacaksa ortada nesne yönelimli programlamanýn kullanýmý ile ilgili 
bir problem var. Burada nesnenin türü bilinmek zorunda olursa, buraya yeni türler geldiðinde burasý da sürekli update
edilmeli. Amaç zaten bundan kurtulmak.

Ancak öyle durumlar var ki kötü tasarýmdan deðil, mecburiyetten nesnenin türünü öðrenmek zorunda kalýyoruz. 
Kodlar programcýda olmadýðý için, yani bazý iþleri yapmak için kaynak koda ihtiyaç var ancak kaynak kod verilmemiþ. 
Dolayýsýyla kaynak koda müdahale edilme imkaný olmadýðýndan geriye kalan ihtimal nesnenin türünün öðrenilmesi.
Yani öyle durumlar var ki bu istenmese de nesnenin türünün ne olduðunu öðrenmeye yönelik dilsel bir araç iþimizi 
kolaylaþtýrýr. Çalýþma zamanýnda tür belirlenmesi öyle günlük, sürekli kullanýlacak bir araç deðil. Kullanýlmasý için
ortada bir zorunluluk, bir sýkýþma durumu olmasý gerekir. Bu olmazsa yani artýk iþ yapamama durumunda olmalýyýz.
Tasarýmsal bir hatada, tasarým deðiþtirilmeli.

Java, C# gibi dillerde buna yönelik araçlar daha fazla kullanýlma eðiliminde. Yani oradaki yapýnýn monolitik hiyerarþi
olmasý, garbage collector gibi bir sistemin olmasý, bütün fonksiyonlarýn virtual olmasý(hangi fonksiyonun çaðrýlacaðýnýn
run time'da anlaþýlmasý) Run time'da bir nesnenin türünün sorgulanmasýna yönelik ciddi bir maliyet de getirmez. C++'da ise
bunun bir de maliyeti var. Run time'da bir nesnenin türünün ne olduðu anlaþýlýyorsa ortada bir maliyet faktörü olduðu 
kesin çünkü run time içinde bir kod çalýþacak türü anlayacak. 

C# ve Java gibi dillerde olduðu gibi C++'da da bir nesnenin dinamik türünün yani run time'da belli olan türünün	ne olduðunu 
run time'da check etmeye yarayan araçlar var. Aslýnda 3 tane basit araç olarak bahsedilebilir;
Bunlardan biri bir operatör, dynamic_cast operatörü
Ýkincisi yine bir opertaör, typeid
Bir de typeid operatörü ile iliþkili standart bir sýnýf var, bu sýnýfýn ismi de typeinfo.



dynamic_cast opeatörü:

Sentaks olarak kursun baþýnda gördüðümüz C'de olmayan C++'da olmayan tür dönüþtürme operatörlerinden biri.
Tüm tür dönüþtürme operatörlerinin genel sentaksý ayný:
dynamic_cast<Target Type>(operand),
Örnek olarak: dynamic_cast<Audi *>(carptr) //Audi * türüne dönüþüm yapýlmýþ, dönüþtürülen ise carptr
upcasting: her mercedes bir arabadýr, her spor mercedes bir mercedestir. Dolayýsýyla zaten her Mercedes bir araba olduðu için
araba gereken her yerde mercedes kullanýlabilir. Mercedes'ten arabaya, spor Mercedes'ten Mercedes'e veya spor Mercedes'den Arabaya
yapýlan dönüþümler yukarý doðru dönüþümler. 
Ancak dynamic_cast söz konusu olduðunda bizi ilgilendiren bunun tam tersi, down casting.



10_02_2018_CUMARTESÝ

RTTI, run time type information(identication)'ýn kýsaltmasý, çalýþma zamanýnda tür belirlenmesi.
Polimorfizm söz konusu olduðunda, polimorfik bir tür söz konusu olduðunda statik tür kavramýnýn yaný sýra dinamik tür kavramý
var. Normal olarak marifet türün ne olduðunu bilmeden bu iþi yapmak böylece eski kodlar yeni kodlarý kullanýr. Ancak bazý 
durumlarda nesnenin türünün run time'da ne olduðunu öðrenmek, yapamadýðýmýz bazý iþleri yapmamýzý saðlar. Bu senaryolarýn çok
büyük bir kýsmý kaynak kodun bizde olmamasý ile ilgili. 
Nesne yönelimli programlama dillerinin sadece C++'da deðil diðer dillerde de buna yönelik araçlarý var.
C#, Java gibi dillerde tüm sýnýf nesneleri zaten polimorfik, oradaki gibi programýn lojik yapýsýný saðlamak için C++'da bu araç
kullanýlmaz. Mecbur olunduðu zaman kullanýlmasý gereken bir araç. 
Araç setinde iki tane operatör var, dynamic_cast ve typeid. Bir de typeid operatörü ile birlikte kullanýlacak typeinfo isimli 
sýnýf. 

dynamic_cast operatörü programýn çalýþma zamanýnda bir downcasting'in güvenli olarak yapýlýp yapýlamayacaðýnýn kontrolünü yapar.
Doðal olan is a ilikþisini gösteren, türemiþ sýnýftan taban sýnýfa doðru dönüþümlere geleneksel olarak upcasting denir. downcasting
ise bunun tam tersi. Örneðin Bmw *'ýn Car *'a dönüþtürülmesi upcasting, ama Car *'ýn Bmw *'a dönüþtürülmesi downcasting.

Þöyle bir fonksiyon var:
void carGame(Car *ptr)
{
	auto bmwptr = (Bmw *)ptr; //C tarzý
	bmwptr->openSunroof();
}
Fonksiyonun parametresi  Car *. Buraya gelen Bmw ise, Bmw'nin openSunroof fonksiyonu çaðrýlsýn ancak Bmw deðilse sunroof açma 
giriþiminde bulunmak compile time engeli aþýlsa bile run time hatasý olur. 
Runtime'da fonksiyona gelen nesne gerçekten Bmw nesnesi ise hiç problem çýkmayacak. Ama gelen Bmw nesnesi deðilse openSunroof
aldýðý this adresini Bmw adresi olarak kullanacak, veri öðelerine eriþecek, pointerlarýna eriþecek, run time'da anýnda patlar.
Run time'da bu iþler ancak gelenin Bmw olduðundan emin olunduðunda yapýlacak, iþte dynamic_cast operatörü bunun sýnamasýný verir.
Bu gerçekten Bmw mi ? *ptr gerçekten Bmw'mi ? compile time'da deðil run time'da bunun kontrolü imkanýný verir.
*ptr gerçekten Bmw ise, böyle bir tür dönüþümü yapmak ve Bmw nesnesi gibi kullanmak bir run time hatasýna sebep olmaz.

static_cast<>
const_cast<>
reinterpret_cast<>
dynamic_cast<T>(operand)
C++'da tüm tür dönüþtürme operatörlerinin sentaksý ayný.

Bmw *p = dynamic_cast<Bmw *>(carptr): Bmw *'a cast ediliyor ve operand carptr.
run time'da eðer carptr'nin gösterdiði nesne gerçekten bir Bmw nesnesi ise bu dönüþüm baþarýlý olur ve de Bmw nesnesinin adresi,
this adresi olarak kullanýlacak adres elde edilir. Dolayýsý ile bu bir Bmw pointerýna atanýrsa ve bu dönüþüm baþarýlý ise p
bir Bmw nesnesinin adresi olur. Dönüþüm baþarýsýz olursa, yani *carptr bir Bmw deðilse o zaman operatör null pointer deðerini 
üretir. Dolayýsýyla downcasting yapýlýp yapýlmayacaðý, güvenli mi güvensiz mi, p'ye verilen deðere bakýp anlaþýlýr. Eðer p'ye
verilen deðer null pointer deðil ise, p artýk bir Bmw olarak kullanýlýr.


Bu operatörün kullanýmýna iliþkin þöyle bir kural var; operand olan ifade polimorfik bir türden olmak zorunda.
Bir türün polimorfik olmasý için en az bir tane sanal veya saf sanal fonksiyoný olmasý gerekir.
Base sýnýfýnýn böyle bir tane bile fonksiyonu yok. 
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
};

class Der1 : public Base {
public:
	void f3() {};
};

class Der2 : public Base {
public:
	void f4() {};
};

void func(Base *baseptr)
{
	Der1 *dp = dynamic_cast<Der1 *>(baseptr); //sentaks hatasý
}
//////////////////////////////////////////////////////////////////


Sýnýfa sanal bir destructor eklenerek bu problem basitçe çözüldü.
Der1 ve Der2 sýnýflarý, Base'den türetilmiþ sýnýflar. func fonksiyonunun parametresi Base * türden.
Fonksiyonun içinde dynamic_cast kullanýlarak parametre olarak gelen sýnýfýn Der1 olup olmadýðý kontrolü yapýlýr.
Eðer gelen Der1 ise, Der1 sýnýfýnýn f3 üye fonksiyonu çaðrýlýr. Çalýþma zamanýnda anlaþýlmasý için randomize idiyomu
kullanýlýr.
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
	virtual ~Base(){}
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der2 : public Base {
public:
	void f4() {};
};

void func(Base *baseptr)
{
	Der1 *dp = dynamic_cast<Der1 *>(baseptr);

	if (dp) {
		cout << "buraya gelen bir Der1 nesnesi" << endl;
		dp->f3();
	}
	else {
		cout << "buraya gelen bir Der1 nesnesi degil" << endl;
	}
}

int main(void) {

	randomize();

	for (;;) {
		if (rand() % 2) {
			cout << "Der1 case\n";
			func(new Der1);
		}
		else {
			cout << "Der2 case\n";
			func(new Der2);
		}
		getchar();
	}
}
//////////////////////////////////////////////////////////////////


Buradaki problem scope leakage, f3 fonksiyonunu çaðýrmak dýþýnda baþka yapýlacak bir iþ yok.
Hem yanlýþlýkla bu isim kullanýlabilir hem isim çakýþmasýna sebep olabilir.
//////////////////////////////////////////////////////////////////
void func(Base *baseptr)
{
	Der1 *der1ptr = dynamic_cast<Der1 *>(baseptr);
	if (der1ptr != nullptr)
		der1ptr->f3();
}
//////////////////////////////////////////////////////////////////
der1ptr eðer bu iþlemi yapmak dýþýnda hiçbir yerde kullanýlmayacaksa, fonksiyonun devam ettiði düþünülürse
if bloðu dýþýnda yanlýþlýkla bir yerde de kullanýlabilir. Bu durumda mümkünse der1ptr'yi bu iþlem dýþýnda 
kullanmak mümkün olmamalý. Bunu yapmanýn bir iyi olmayan yolu bunu blok içine almak.

if deyimine iliþkin bir özellik, for'un birinci kýsmýnda deðiþken tanýmlanabiliyor, if'in de içinde deðiþken 
tanýmlanabiliyor. Bu C++11 ile gelen yeni bir özellik deðil. Ancak bir sýnýrlama var sadece zero non-zero veya
lojik control yapýlabiliyor.
//////////////////////////////////////////////////////////////////
void func(Base *baseptr)
{
	if (Der1 *der1ptr = dynamic_cast<Der1 *>(baseptr))
		der1ptr->f3();

	der1ptr->f3(); //geçersiz, der1ptr'nin scope'u dýþýnda
}
//////////////////////////////////////////////////////////////////
if parantezi içinde bildirilen der1ptr týpký for'un birinci kýsmýnda tanýmlanan isimlerde olduðu gibi scope'u
kontrol deyiminin gövdesi ile sýnýrlý. Bunun da sýnýrlayýcý özelliði sadece zero, nonzero veya nullptr olup olmadýðý
sorgulanabilir.

2017 standartlarý ile if deyimine yeni bir sentaks eklendi, if with initializer. Böylece artýk scope leakage problemi tamamen
engellenir. Yukarýdaki faydalý ancak sadece logic kontrol yani boolean kontrol ile sýnýrlý. 
//////////////////////////////////////////////////////////////////
int func(int);
int main(void) {

	if (int retval = rand(); retval % 5 == 0)
		func(retval);

}
//////////////////////////////////////////////////////////////////



Eðer referans üstünden dynamic_cast yapýlýrsa, null referans diye bir kavram olmadýðýndan bu durumda dönüþümün baþarýsýz 
olmasý halinde kontrol kriteri yok. Bu durumda bir exception gönderir. dyanmic_cast operatörü referans bazlý kullanýlýrsa ve
run time'da nesnenin dinamik türü o hedef tür deðilse bir exception gönderir. Gönderilen exception'ýn türü bad_cast.
Öncelikle func fonksiyonu referans semantiði kullanacak þekilde düzenlendi.
Ardýndan main'de fonksiyona der2 sýnýfý türünden nesne gönderildi ve try bloðu içine alýndý. catch bloðunda ise kendi türü
bad_cast ile hata yakalandý.
bad_cast sýnýfý da exception sýnýfýndan türetildiðinden exception & ile de hata yakalanabilirdi.
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
	virtual ~Base() {}
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der2 : public Base {
public:
	void f4() {};
};

void func(Base &r)
{
	Der1 &dref = dynamic_cast<Der1 &>(r);
	dref.f3();

}

int main(void) {
	try{
		Der2 d2;
		func(d2);
	}
	catch (bad_cast &r) {
		cout << "hata yakalandi " << r.what() << endl;
	}

}
//////////////////////////////////////////////////////////////////
dynamic_cast pointer üstünden yapýldýðýnda, downcasting baþarýlý olmayacaksa(nesnenin türü beklenen tür deðilse) ifadenin deðeri
nullptr olur. Ancak referans üstünden yapýldýðýnda null referans diye bir araç olmadýðýndan, downcastingin baþarýsýz olmasý
durumunda bad_cast sýnýfý türünden bir exception throw eder. bad_cast sýnýfý da exception sýnýfýndan türetilmiþ bir sýnýf.


Der11 sýnýfý da Der1 sýnýfýndan türetme yolu ile elde edilmiþtir. Burada yine is a iliþkisi var.
Der11 de Der1 olduðundan Der11 de Der1 gibi muamele görür.
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
	virtual ~Base() {}
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der11 : public Der1 {
public:

};

void func(Base *ptr)
{
	if (auto p = dynamic_cast<Der1 *>(ptr)) {
		cout << "evet Der1" << endl;
	}
	else {
		cout << "hayir Der1 degil" << endl;
	}
}

int main(void) {

	Der1 d1;
	func(&d1); //geçerli, "evet Der1"

	Der11 d11;
	func(&d11); //geçerli "evet Der1"

}
//////////////////////////////////////////////////////////////////



Typeid Operatörü:

typeid(expression);
typeid keyword, sizeof keyword ikisine de bir expression argüman olarak verilir.
Bir typeid ifadesi yazýldýðýnda, bu ifade derleyicinin oluþturduðu kodla bir sýnýf türünden nesneye referans oluþturur.
Bu bir fonksiyon deðil ancak sanki adeta bir fonksiyon çaðrýlýyor, fonksiyondan da bir sýnýf türünden referans elde edilir.
Ancak fonksiyon olmadýðý unutulmamalý, derleyici operatör seviyesinde kod üretir.
Bu sýnýfýn ismi typeinfo. typeid operatörü kullanýldýðý zaman, typeid operatörü ile oluþturulan ifade ismi typeinfo olan
standart bir C++ sýnýfý türünden bir nesneye referans. Nesneye referans olmasý ile o nesne kullanýlmýþ olur.
Yani typeid(expression) ifadesinin yanýna nokta konulursa; typeid(expression). aslýnda typeinfo sýnýfýnýn interface'i
kullanýlmýþ olur. Bu referans const bir referans. typeid operatörüne operand olarak bir ifade verildiðinde derleyicinin
oluþturduðu kodla typeinfo isimli bir sýnýf türünden derleyicinin oluþturduðu bir nesneye referans alýnmýþ olunur.

Derleyicinin ürettiði kodda sanki ismi typeinfo türünden olan bir nesne oluþturulur. typeid(exp) kullanýldýðýnda derleyici
bunu þöyle bir ifadeye dönüþtürür: const typeinfo &r = x; 
typeid(exp) dedik ancak geri planda derleyicinin oluþturduðu bir nesne kullanýlýr. 
const referans olduðundan sýnýfýn interface'inden yalnýzca const üye fonksiyonlar kullanýlabilir.
Daha önceden örneklerde de kullandýðýmýz; typeid(exp).name(); name aslýnda typeinfo sýnýfýnýn bir üye fonksiyonu.
typeinfo sýnýfýnýn 3 tane bizi ilgilendiren fonksiyonu var; operator==, operator!= ve name fonksiyonlarý.
name fonksiyonunun geri dönüþ deðeri const char *, dolayýsý ile typeid(exp).name() ifadesi kullanýldýðýnda buradan yazýnýn
adresi alýnýr.

//////////////////////////////////////////////////////////////////
int main(void) {

	int x = 10;

	cout << typeid(x).name() << endl;
}
//////////////////////////////////////////////////////////////////



typeinfo sýnýfý türünden bir nesne oluþturulmasýnýn hiçbir yolu yok.
Baþlýk dosyasý eklenmesine raðmen geçersiz olur.
//////////////////////////////////////////////////////////////////
int main(void) {
	type_info x; //geçersiz
}
//////////////////////////////////////////////////////////////////
"no default constructor available", sýnýfýn default constructor'ý yok.



copy constructor ile de nesne oluþturulamaz.
//////////////////////////////////////////////////////////////////
int main(void) {
	type_info x{typeid(10)}; //geçersiz
}
//////////////////////////////////////////////////////////////////
sýnýfýn copy constructor'ý delete edilmiþtir.
eski c++ kodlarýnda delete etmek mümkün olmadýðýndan bu fonksiyon private'dý.


Derleyicinin yazmýþ olduðu sýnýf aþaðýdaki gibi düþünülebilir;
class typeinfo{
public:
	type_info(const type_info &) = delete;;
}
Bir type info nesnesine ulaþmanýn tek yolu, typeid operatörünü kullanmak.


Eðer sýnýfýn operator==, operator!= fonksiyonlarý çaðrýlýrsa, iki typeinfo nesnesinin ayný nesne olup olmadýðý test
edilebilir. Ayný türe iliþkin typeinfo nesnesi bir tane. typeid bir ifade için kullanýlýp, baþka bir ifade için yine
typeid operatörü kullanýlýrsa iki tane typeinfo nesnesi elde edilmiþ olur, bu iki nesne == ile karþýlaþtýrýldýðýnda
bu ikisi ayný türden ise fonksiyon true deðer verir, farklý türlerden ise false deðer verir.

//////////////////////////////////////////////////////////////////
int main(void)
{
	int x = 10, y = 34;
	double dval;

	if (typeid(x) == typeid(y))
		cout << "evet esit" << endl;
	else
		cout << "hayir esit degil" << endl;

	if (typeid(x) != typeid(dval))
		cout << "esit degiller" << endl;
	else
		cout << "esitler" << endl;
}
//////////////////////////////////////////////////////////////////

typeid operatörünü, sizeof operatörüne biraz daha benzer kýlan bir özelliði daha var.
sizeof operatörünün operandý olan ifade bir tür bilgisi olabilir, sizeof(int) gibi, ayný özellik burada da geçerli.
Yani typeid(x) == typeid(int) gibi bir kontrol de yapýlabilir. x'in türü in mi ? sorgusu yapýlýr.
if(typeid('a') == typeid(int)), false deðer üretir çünkü C++'da 'a' ifadesinin türü C'de olduðu gibi int deðil char.
typeid operatörüne geçilen tür bilgisi user defined bir tür de olabilir. 

typeid operatörü içindeki ifade de, sizeof'daki gibi deðerlendirmeye alýnmaz.
dynamic_cast'den birinci önemli farký, dyanmic_cast'in operandý olan ifadenin polimorfik türlerden olmasý gerekir.
typeid'nin ise polimorfizm ile ilgisi olmak zorunda deðil. ifade olarak int türden bir sabit de geçilebilir.
typeid(expression).name() sonucunda elde edilen yazý derleyiciye baðlý.


typeid operatörü run time operatörü mü ? hem evet hem hayýr.
operatörün davranýþý, operand olan ifadenin polimorfik türden olup olmadýðýna göre deðiþir.
Aþaðýdaki örnekte *ptr ifadesinin türünün class Base olduðu görülür.
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der11 : public Der1 {
public:
};

class Der2 : public Base {
public:
	void f4() {}
};

void func(Base *ptr)
{
	cout << typeid(*ptr).name() << endl;
}

int main(void)
{
	Der1 myder1;

	func(&myder1);
}
//////////////////////////////////////////////////////////////////


Ancak sýnýf, polimorfik bir sýnýf haline getirilip kod tekrar çalýþtýrýldýðýnda, *ptr ifaedesinin türünün
class Base deðil, class Der1 olduðu görülür.
//////////////////// //////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
	virtual ~Base() {}
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der11 : public Der1 {
public:
};

class Der2 : public Base {
public:
	void f4() {}
};

void func(Base *ptr)
{
	cout << typeid(*ptr).name() << endl;
}

int main(void)
{
	Der1 myder1;

	func(&myder1);
}
//////////////////////////////////////////////////////////////////


Söz konusu ifade polimorfik bür türdense, tür run time'da belirlenir. Polimorfik deðilse statik tür alýnýr.
dynamic_cast'de zaten polimorfik bir türden operand kullanmak zorunlu.


func fonksiyonunun kodu þu þekilde deðiþtirilse;
//////////////////////////////////////////////////////////////////
void func(Base *ptr)
{
	if (typeid(*ptr) == typeid(Base))
		cout << "dogru" << endl;
	else
		cout << "yanlis" << endl;
}
//////////////////////////////////////////////////////////////////
main'de yanlýþ yazýsý çýkar. Her Der bir Base'dir ancak typeid opeatörü kontrolü böyle yapmaz.
Yani is a ? iliþkisi == için yeterli deðil. Oysa dynamic_cast söz konusu olsaydý bu eþit çýkardý.
typeid operatöründe nesnenin kesin türünün eþitlik için doðru olmasý gerekir yani is a ? iliþkisi ile 
elde edilen türün deðil. 
Tabi, eðer Base sýnýfýnýn polimorfik olmasýný saðlayan destructor silinir ve sýnýf polimorfik olmaktan
çýkarsa eþitlik doðru olar, çünkü statik olarak bakýldýðýnda türleri aynýdýr.

Run time'da gerek dynamic_cast olsun gerek typeid olsun nasýl bir kod üretiliyor ? Nasýl oluyor da run time'da nesnenin türünün ne
olduðu anlaþýlýp ekrana yazdýrýlýyor ?
Her sýnýf için ve polimorfik olmasý durumunda hiyerarþideki her sýnýf için derleyici resmen run time'ýn baþýnda birer nesne yaratýr.
Yani hiyerarþide 250 tane sýnýf olsa, 250 tane run time baþýnda sýnýflar türünden nesne yaratýlýr. Bu tür bilgilerini vs enkapsüle eden
bu derleyicinin oluþturduðu sýnýf nesneleri.
Yani *ptr'nin türü Mercedes mi diye bakýldýðýnda gerçekten typeid, *ptr ile bizi bir nesneye eriþtirir. Bu nesne run time baþýnda
derleyicinin oluþturduðu nesne. O nesne ile ayný olup olmadýðýna bakar.
Bu iþ maliyetli bir iþ. typeid operatörü kullanýldýðý zaman veya dynamic_cast kullanýldýðý zaman bu nesnelerin hayata gelme,
construction maliyeti kodun bir maliyeti. Eðer sorgulama yapýlýrsa derleyici hiyerarþiyi hiyerarþiyi yukarýdan aþaðýya doðru dolaþýp
tek tek bakar, nesnelerin türü ayný mý deðil mi diye. Hiyerarþi içinde 250 tane sýnýf varsa, 250 tane typeinfo nesnesi var hepsi 4 byte
olsa 1000 byte. Run time'da bunun için bir kod çalýþýyor.
RTTI default olarak ayarlardan tamamen kapatýlabilir. Derleyici, programcýnýn bunu kullanýp kullanmayacaðýný göremediði için mecbur 
polimorfik sýnýflar söz konusu olduðunda bu typeinfo nesnelerini hayata getirecek kodu üretir. Bu sebeple C++ derleyicilerinin çoðunda IDE
ayarlarýnda RTTI kapatýlýp, açýlabilir.

func foknksiyonuna nullptr gönderildi ve kod çalýþtýrýldýðýna abort çaðrýlýr, exception throw edilir.
exception'ýn türü bad_typeid, yine exception ile yakalanabilir.
operatör atýlan 3 tane exception öðrenildi; biri new operatörü, operator new'i çaðýrýp bellek bloðu elde edemediði zaman bad_alloc gönderir.
Diðeri dynamic_cast referans yoluyla baþarýsýz dönüþüm giriþiminde bad_cast throw eder.
Bu da null pointer'ý dinamik tür içinde gönderdiðimizde bad_typeid exception'ý throw eder.
//////////////////////////////////////////////////////////////////
void func(Base *ptr)
{
	cout << typeid(*ptr).name() << endl;
}

int main(void)
{
	Der1 myder1;

	try {
		func(nullptr);
	}
	catch (exception &r) { //catch (bad_typeid &r) gerçek tür

		cout << "hata yakalandi: " << r.what() << endl;
	}
}
//////////////////////////////////////////////////////////////////


Derleyici nasýl bir kod üretir ? Polimorfik sýnýflar için derleyici sanal fonksiyon tablosu oluþturur. Sanal fonksiyon tablosunda normalde ayný 
override'larýn adresi bulunur. Derleyici o typeinfo sýnýfý türünden nesne oluþturacak kodu üretirken o nesnenin adresini de gider sanal fonksiyon
tablosunda 0 indekse yazar. Biz virtual pointer yolu ile o sanal fonksiyon tablosuna eriþiyorduk, oraya eriþtikten sonra indeks yolu ile o 
typeinfo nesnesine de eriþebiliriz. 
typeid'nin maliyeti ile dynamic_cast'in maliyeti arasýnda büyük bir sýnýf hiyerarþisi söz konusu olduðunda hangisinin maliyeti daha yüksektir ?
ikisi de ayný nesneleri kullanýr, dynamic_cast de o türden olup olmadýðýný anlarken sanal fonksiyon tablosuna eriþip o indekse bakar, o indeksten
nesnenin türünün ne olduðunu anlar böylece o ayný türse null pointer üretmez. Ýmplementasyon tarafýnda ikisi de ayný nesneyi kullanýrlar.
dynamic_cast'in maliyeti daha yüksek. typeid'de ayný olup olmadýklarý bir sorgulamada sýnanýr. Ayný türden olduklarýnda ayný typeid nesneleri.
Ancak dynamic_cast hiyerarþide sonuna kadar gitmek zorunda, hiyerarþi çok derinse dynamic_cast daha fazla sorgulama yapar.


static_cast operatörü de dynamic_cast gibi kullanýlabilir, legal ancak ayný þey deðil.
sentaks hatasý yok ama buradaki kontrolün run time kontrolü ile hiçbir alakasý yok.
Burada derleyici sadece bu iki sýnýfýn ayný hiyerarþide olup olmadýðý kontrolünü yapar.
Buraya gelen nesnenin Der1 nesnesi olup olmadýðý kontrolü yapýlmaz.
fonksiyona Der2 nesnesi gönderildi ancak onu Der1 nesnesiymiþ gibi kullandý.
dynamic_cast kullanýlsaydý, gelen nesnenin Der1 olup olmadýðý run time'da kontrol edilirdi.
Ortada bir compile time hatasý yok ama bu bir run time hatasý.
//////////////////////////////////////////////////////////////////
class Base {
public:
	void f1() {};
	void f2() {};
	virtual ~Base() {}
};

class Der1 : public Base {
public:
	void f3()
	{
		cout << "Der::f3()" << endl;
	}
};

class Der11 : public Der1 {
public:
};

class Der2 : public Base {
public:
	void f4() {}
};

void func(Base *ptr)
{
	Der1 *p = static_cast<Der1 *>(ptr);
	p->f3();
}

int main(void)
{
	Der2 myder2;

	func(&myder2);

}

//////////////////////////////////////////////////////////////////



Yukarýdakinin ayrý bir faydasý var. Diyelim ki elimizde çok derin bir sýnýf hiyerarþisi var, iki sýnýfýn ayný hiyerarþide olup olmadýðý test edilmek
isteniyor. Üçüncü bir sýnýf olarak Onder sýnýfý oluþturuluyor. Onder sýnýfýnýn Base hiyerarþisi ile hiçbir alakasý yok.
Onder *'dan Der *'a statik cast ile dönüþüm yapýlýrsa compile time hatasý olur.
//////////////////////////////////////////////////////////////////
class Onder {

};

class Neco{

};

int main(void)
{
	Onder x;
	Neco *p = static_cast<Neco *>(&x);


}
//////////////////////////////////////////////////////////////////
Ýki sýnýfýn ayný hiyerarþide olup olmadýðý böyle anlaþýlýr. static_cast ile kullanýmý legalse ayný hiyerarþidedir.


Burada ise legal.
static_cast'de dönüþümün legal olmasý, run time'da o nesnenin o türden olduðunu iþaret etmez.
static_cast'in run time ile alakasý yok.
Ancak static_cast'de adres üstünden iki farklý sýnýf için dönüþüm yapýlýrsa ve legalse bu iki sýnýf ayný hiyerarþi içindedir.
//////////////////////////////////////////////////////////////////
class Onder {

};

class Neco : Onder{

};

int main(void)
{
	Onder x;
	Neco *p = static_cast<Neco *>(&x);


}
//////////////////////////////////////////////////////////////////



templatelere iliþkin birçok kodda typeid operatörü mekanýzmayý anlamak için kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename t>
void func(T x)
{
	cout << typeid(x).name() << endl;
}
//////////////////////////////////////////////////////////////////
Derleyici T türünün ne olduðunu anladýðýnda, T yerine compile time'da o gerçek türü kullanýr.
Derleyicinin yazdýðý kodda da typeid operatörü kullanýlýr, derleyicinin T türünü hangi tür olarak aldýðý bu þekilde görülür.
Yani burada ihtiyaçtan ziyade eðitimin bir aracý olarak kullaným durumu var.



11_02_2018_PAZAR

NAMESPACES(ÝSÝM ALANLARI)

Programlarda biz isimler kullanýyoruz ve bu isimlerin önemli bir kýsmý dýþ baðlantýya açýk. Fakat programlamadaki temel
problemlerden biri dýþ baðlantýya ait isimlerin sayýsý tek olmalý. Örnek olarak dýþ baðlantýda ayný isimde iki fonksiyon
olamaz, link aþamasýnda problem çýkar. C gibi bir dilde bile bu önemli bir problem, C programlarýnýn görece küçük olmasý
tesellimiz. Bir kütüphane baþlýk dosyasý include edildiðinde, dýþarýya açýlmýlþ bütün isimleri kendi global alanýmýza
almýþ oluyoruz bu da isim çakýþmasý için ciddi bir risk. Ýsimler özelleþtirilerek çakýþma riski azaltýlabilir, örnek 
olarak kütüphanelerde, kütüphanenin ismi isimlere ön ek olarak koyulabilir. 
C++, C#, Java gibi oop dillerinde kütüphane sayýlarý tipik bir projede çok daha fazla. Ýsim çakýþma olasýlýðý çok daha
yüksek. Bu yüzden böyle diller, global isim alanýna enjekte edilen isimlerin birbirinden gizlenmesine yönelik daha 
sofistike C'de olmayan araçlar barýndýrýr. Araçlarýn özü isimleri birbirinden gizlemek. 

Örnek olarak C dizini altýnda ayný isimde iki .txt dosyasý bulunamaz. Eðer böyle bir durum varsa, dosyalardan birini C
altýnda bir klasör oluþturur onun içine koyabiliriz. Bu durumda biri C'de biri C'nin içindeki bir klasörde olan ayný isimde
iki .txt dosyasý olabilir. Ayný þekilde bir kütüphane kullanýlacaksa isimler doðrudan global alana boþaltýlmak yerine sanki
hepsi birer klasör altýndaymýþ gibi gelirler. Adeta bir container içindelermiþ gibi isimler aktarýlýr. Ýsimler ayný olsa bile
ayrý containerlarda tutulduðundan birbirleri ile karýþmaz.

Ýsim alanlarý, global isim alanýndaki isimleri birbirinden gizlemek ve isim çakýþmasýný engellemek için dil tarafýndan 
desteklenen mekanizma. Bir namespace adeta bir isim container'i. 
C++'da özellikle büyük ve genel hizmet veren kütüphaneler isimlerini tipik olarak bir namespace içinde verir. 
Programcý olarak namespaceler daha çok hizmet alýnan kodlardadýr, daha çok kullanýcý olarak karþýlaþýlýr. Programcýnýn kullandýðý
baþka kütüphaneler namespace içinde isimler verir.

C++'nýn standart kütüphanesi, std namespace'i içinde. Sadece C++'ýn standart kütüphanesinden 2000 küsür isim gelir.
Kütüphanenin dýþa tanýttýðý bütün isimler, std isim alaný içinde.


namespace bir anahtar sözcük, birden fazla yerde kullanýlacak bir keyword.
Kapayan küme parantezinin sonunda sýnýflarda olduðu gibi ; koyulmaz, ancak koyulmasý da sentaks hatasý deðil.
Ýsim alanýnýn içinde global alanda yapýlan her þey yapýlabilir. Bir deðiþken tanýmlanabilir, bildirilebilir. Bir fonksiyon da 
tanýmlanýp, bildirilebilir. Bildirim de olabilir, taným da.
//////////////////////////////////////////////////////////////////
namespace Neco {

} 
//////////////////////////////////////////////////////////////////


Örnek olarak bir baþlýk dosyasý include edilir, baþlýk dosyasýnýn bütün içeriði bu isim alanýnýn içinde olur.
cppcurl.h include edildiðinde, kendi global alanýmýza bu isim alanýný yapýþtýrmýþ oluruz. Yani yukarýdaki örnekteki namespace Neco
include edilen baþlýk dosyalarýndan gelir. Bu baþlýk dosyasý bir isim alaný içinde bildirimlere sahip olur. 
Ýçinde normal bir sýnýf bildirimi, fonksiyonlar, typedef bildirimleri bu isim alanýndan gelir.
//////////////////////////////////////////////////////////////////
#include "cppcurl.h"
namespace Curlx {
	class Xyz{
	};
	
} 
//////////////////////////////////////////////////////////////////


Dilin kurallarýna göre namespace bir kod alaný, yani global alan da aslýnda bir namespace ancak bahsedilirken global namespace denir.
Neco'nun içinden bahsedilirken ise Neco namespace'i denir. Dilin kurallarýna göre normal global alanda ne yapýlabiliyorsa bu isim
alanlarý içinde de yapýlabilir. Bir namespace içinde de namespace oluþturulabilir, nested olabilirler.
C++'nýn standart kütüphanesinde de nested isim alanlarý var. 
//////////////////////////////////////////////////////////////////
namespace Neco {
	namespace Project{
	}
} 
//////////////////////////////////////////////////////////////////


Namespace bir scope, dilin kurallarý ayný scope içinde ayný ismin birden fazla varlýða verilmesini engelliyorsa bu namespace için de 
geçerli. Ýsim alanlarý içindeki isimler birbirinden farklý olmak zorunda.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10;
	double x = 2.3;
}  //geçersiz
//////////////////////////////////////////////////////////////////


Namespace scope'un ilginç bir özelliði var. 
Derleyici bir namespace tanýmýnýn üstünden geçtikten sonra, ayný isimde bir namespace görürse bunlarý kimülatif birleþtirir.
Tek bir namespace olmasýna raðmen, fiziksel olarak birden fazla yerde bulunabilir. Bunlar ayrý namespace'ler deðil. 
Eðer böyle olmasaydý bir kütüphane tek bir baþlýk dosyasý ile sunulmak zorundaydý. Kütüphanedeki bütün isimler bir namespace'e
konulmak isteniyor ancak onlar da ayrý ayrý baþlýk dosyalarýnda. 10 tane baþlýk dosyasý, 10'u da ayný isim alaný içinde. Birden fazla
baþlýk dosyasý include edildiðinde burada olduðu gibi, bunlara tek bir isim alaný muamelesi yapar.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 210;
}

namespace Neco {
	double d = 34;
	class Myclass {

	};
	double x = 3.4; //geçersiz, ayný isim alanýnda ayný isim birden fazla bulunamaz
}
//////////////////////////////////////////////////////////////////


vector baþlýk dosyasý dahil edildiðinde, namespace std {} include edilmiþ olur, bütün baþýk dosyasýndaki isimler bunun içinde.
map include edildiðinde de yine, isimler namespace std {} içinde. Farklý ve birçok sayýda baþlýk dosyasý var ama dýþarý verilen isimlerin
hepsi ayný isim alaný içinde.


namespace bir scope, class da bir scope ama class ve namespace arasýnda ciddi fark var. Ýkisinde de isimler tanýtýlýyor ama sýnýflara 
access kontrol konulabiliyorken isim alanlarýna konulmaz. Ýsim alanlarý eriþim kontrolüne tabi deðil.


Bir ismi bir namespace içinde aratmak için özel bir operatör kullanýlýr. Bu operatör yine çözünürlük operatörü. Sol operand olarak isim
alanýnýn ismi, sað operand olarak isim alaný içindeki ismi alýr.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x;
} 
int main(){
	Neco::x;
}
//////////////////////////////////////////////////////////////////
Derleyici artýk bu ismi doðrudan Neco isim alanýnda arar. Artýk önce blok içinde arayýp global alanda arayýp bakmaz. Sadece isim alanýna
bakar. Neco ismi de aranýyor yani namespace Neco silinse, Neco ismi bulunamadýðý için sentaks hatasý olur. Ýki aþamalý bir sentaks kontrolü
mevcut, biri namespace ismi, diðeri namespace içindeki bu isim. 


Bazý durumlarda sürekli kullanýlacak isimleri çözünürlük operatörü ile isim alanýnýn ismi ile niteleyerek kullanmak kullaným zorluðu
olabiliyor, okuyanýn iþini de zorlaþtýrabiliyor. Bazý durumlarda namespace içindeki isimler nitelemenden kullanýlmak istenebilir. Ancak
Neco::x gibi bir kullaným asla yanlýþ veya kötü deðil, birincil yöntem bu. Ancak kimi zaman yazým kolaylýðý saðlamak, kodun görüntüsünü 
basitleþtirmek için namespace ismi ile hiç niteleme yapýlmak istenmez. Buna yönelik araçlar asla baþlýk dosyasý içinde kullanýlmaz.
Baþlýk dosyasýnda mesela bir sýnýf tanýmlanacak, sýnýfýn öðelerinden biri bir namespace içinde tanýtýlan türlerden ise veya baþlýk dosyasýna
bir inline fonksiyon tanýmý yapýlýyor orada kullanýlacak bir isim bir namespace içindeyse her zaman o isim nitelenerek kullanýlýr. 
Ýsmi nitelemeden kullanmaya olanak veren araçlar baþlýk dosyasý için deðil. Baþlýk dosyasýný birçok farklý dosya include edecek, baþlýk
dosyasýna ne konulursa dahil eden kodlara o yapýþtýrýlýr. Baþlýk dosyasýna oradaki ismin namespace ismi ile nitelenmeden kullanýlmasýna 
olanak veren bir bildirim konulursa o bildirimi baþlýk dosyasýný include eden tüm baþlýk dosyalar almýþ olur. Bu zaten isim alanýnýn bütün
avantajýný götürür, zaten amaç isim çakýþmasýný engellemekti. Böyle yaparak isim doðrudan kullanýlýr hale gelir.  

//////////////////////////////////////////////////////////////////
#include <string.h>
class Myclass {
	std::string s;	//string s; doðru deðil
};
//////////////////////////////////////////////////////////////////
Myclass içindeki s, string türünden, C++'nýn standart sýnýfýnýn ismi, string.h baþlýk dosyasýnda ve bir namespace içinde.
std namespace'i içinde o zaman std ile nitelenmeli. Burada asla using bildirimi de kullanýlmamalý. Mesela bunun Neco.h içinde oluðu düþünülsün,
eðer kullanýlýrsa Neco.h'yý dahil eden herkes o using bildirimini de kullanmýþ olur.


Bir namespace içindeki ismi nitelemeden kullanmaya yönelik üç farklý ayrý araç var. 
Bu araçlardan biri using declaration, diðeri using namespace declaration, diðeri ise ADL(arguement dependant lookup) veya diðer ismi Koenig lookup.


using declaration:

main içindeki gibi bu isim kullanýldýðýnda, derleyici using bildirimini bulur. Böylece main'deki x isminin Neco namespace'ine iliþkin olduðunu
anlar ve Neco isim alanýnda bu ismi bulur, o isim ile iliþkilendirir.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10;
	class Myclass {

	};
}

using Neco::x;

int main(void)
{
	x;
}
//////////////////////////////////////////////////////////////////


Ancak bazý önemli kurallar bilinmeli, birinci kural using bildiriminin de bir scope'u var. Yukarýdaki örnekte using bildirimi global alanda yapýldý.
Þöyle bir kaynak dosya olduðu düþünülsün;
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10;
	class Myclass {

	};
}

using Neco::x;

void f1()
{
	x = 34;
}

void f2()
{
	x = 21;
}
//////////////////////////////////////////////////////////////////
using bildirimi global alanda yapýldýðýndan, bildirim f1 içinde de f2 içinde de görülür. Dolayýsýyla iki fonksiyonun içinde de x ismi nitelemeden 
kullanýlabilir.


Eðer global alandaki using bildirimi f1 fonksiyonunun ana bloðu içinde yapýlsaydý, artýk bu using bildirimi sadece f1 içinde görünür olurdu. 
f2 içinde bildirim görünür olmadýðýndan f2 içinde x'in kullanýmý sentaks hatasý olurdu.
//////////////////////////////////////////////////////////////////
void f1()
{
	using Neco::x;
	x = 34;
}

void f2()
{
	x = 21;
}
//////////////////////////////////////////////////////////////////

Nitelemeden ismi kullanma hakký global alandaki tüm kodlara verilmek istenirse using bildirimi global alanda yapýlýr. Eðer bu bir fonksiyonla 
sýnýrlandýrýlmak istenirse, using bildirimi o fonksiyonun ana bloðu içinde yapýlýr. Dilin kurallarý içsel bloklarda da kullanýmýný engellemez.
Gerekirse bir kontrol bloðunun bile ana bloðunda bile yapýlabilir(uygulama pratiðinde genelde global alanda veya bir fonksiyonun ana bloðu 
dýþýnda görülmez)


using bildirimi ile tanýtýlan isim(yukarýdaki örnekteki x ismi) using bildiriminin yapýldýðý scope'a enjekte edilmiþ olur.
Yani sanki orada öyle bir isim tanýtýlmýþ gibi etki eder. Artýk o scope'da o ismin kullanýlmasý engellenmiþ olur.
//////////////////////////////////////////////////////////////////
void f1()
{
	using Neco::x;

	int x; //sentaks hatasý

	x = 34;
}
//////////////////////////////////////////////////////////////////
using bildirimi ile x ismi bu isim alanýna enjekte edildi, adeta burada tanýmlanmýþ gibi.
using Neco::x; bildirimi ile artk bu isim baþka amaçla kullanýlamaz.


Yine geçersiz bir kod çünkü using bildirimi ile isim bu sefer de global alana enjekte edildi.
Ýsim global alanda tek olmalý.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10;
	class Myclass {

	};
}

using Neco::x;
double x;	//geçersiz

int main()
{

}
//////////////////////////////////////////////////////////////////


Geçerli çünkü scope'lar farklý. Ýsim using bildirimi ile global isim alanýna enjekte edildi.
//////////////////////////////////////////////////////////////////
using Neco::x;

void f()
{
	int x = 56;
}
//////////////////////////////////////////////////////////////////


Ýlkinde main'de tanýmlanan x, ikincide isim alanýndaki x isminin deðeri yazdýrýlýr.
//////////////////////////////////////////////////////////////////
using Neco::x;

int  main()
{
	int x = 56;

	std::cout << "x = " << x << endl;

	std::cout << "x = " << Neco::x << endl;
}
//////////////////////////////////////////////////////////////////


using bildirimlerinde virgüllerle ayrýlan liste kullanma þansý yok.
Birden fazla isim böyle enjekte edilmek istendiðinde her biri ayrý ayrý bildilmeli.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10, y = 34;
}

using Neco::x, y; //geçersiz
using Neco::x, using Neco::y; //geçersiz
//////////////////////////////////////////////////////////////////



using namespace declaration:

using namespace Neco;
buraya iliþkin kurallar using bildirimine benzer gibi görünse de aslýnda farký kurallar mevcut.
Bu bildirimin de týpký using bildiriminde olduðu gibi bir scope'u var. Yine bu bildirim sadece global alanda yapýlmak 
zorun deðil. Yine bir fonksiyonun ana bloðu içinde yapýlabilir.
using bildiriminden farký, tek bir isim deðil isim alanýndaki tüm isimler için yapýlýr.

//////////////////////////////////////////////////////////////////
namespace Neco {	//bildirim olmasaydý - 1
	int x = 10, y = 34, z = 456;
	class Myclass {

	};
}


int x = 10, y = 34, z = 456; //bildirim ile - 2
class Myclass {

};

using namespace Neco;
//////////////////////////////////////////////////////////////////
using bildirimi ile, bu bildirimin görünür olduðu yerde bu namespace içindeki isimlerin sanki namespace'in içinde 
deðilmiþ gibi görünmesi saðlanýr. Bildirim olmasaydý 1'deki bir görünüm olacaktý, bildirim ile 2 þeklindeki 
görünür hale gelir. Ancak bu bildirimin scope'una enjekte etmez. using bildirimi ile using namespace bildirimi
arasýndaki fark using bildiriminin ismi o alana enjekte etmesi ama using namespace bildiriminde ise sadece bu þekilde
görünür kýlar. 

f1 içindeki x = 45; ifadesi geçerli. Bu namespace bildirimi olmasa, yani namespace içindekiler doðrudan global alanda
olsaydý isim arama kurallarý nasýl olacaktýysa þimdi de öyle. 
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10, y = 34, z = 456;
	class Myclass {

	};
}

using namespace Neco;

void f1()
{
	x = 45;
}
//////////////////////////////////////////////////////////////////



int x = 567; ifadesi de geçerli. Eðer using bildirimi olsaydý bu geçersiz olurdu, isim alanýna enjekte ettiðinden.
Ancak buradaki problem þu f1 içindeki gibi bir kod x ismini kullandýðýndan artýk ambiguity oluþur. Çünkü x = 567;
ifadesindeki x ismi global alanda görülür durumda, namespace içindeki x ismi de using namespace bildirimi nedeniyle
görülür durumda. Buradaki hata ambiguity hatasý.
using namespace bildirimi isim alanýna enjekte etmez. Bu yüzden int x = 567; tanýmlamasýna sentaks hatasý vermez.
Ýsim alanýna enjekte ediyor olsaydý o zaman ayný scope'da ikinci isim tanýmlanmýþ olur ancak buraya bir isim
enjekte edilmediðinden isimler halen birbirinden gizleniyor.
Bu ambiguity hatasý için eðer using namespace bildirimi olmasaydý bu durumda görünürdeki x, int x = 567; deki olurdu.
using bildirimi nedeni ile diðeri de görünür hale geldi. 
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10, y = 34, z = 456;
	class Myclass {

	};
}

using namespace Neco;

int x = 567;

void f1()
{
	x = 45; //çift anlamlýlýk hatasý
	Neco::x = 56; //geçerli, isim alaný içindeki x
	::x = 56; //geçerli, global alandaki x
}
//////////////////////////////////////////////////////////////////


using namespace bildirimi yapmak mecburi deðil bazý durumlarda bilerek yapýlmaz.
namespace Neco bir kütüphaneden, namespace Akin baþka bir kütüphaneden gelir.
Bunlar farklý isim alanlarýnda olduðu için zaten çakýþma olmaz, namespace'in amacý zaten bu.
Ýki isim alanýnda ortak isimler var.
Burada iki isim alaný için de using namespace bildirimi yapýlýrsa ayný ambiguity yine olacak.
Programcý using namespace bildirimlerini yaptýktan sonra main'de x ismini doðrudan kullanýrsa yine sentaks
hatasý. Ýki isim alanýnýn birlikte bulnmasý geçerli çünkü isim alanýna enjekte etmiyorlar. Ýki isim alanýndaki
x'ler using namespace bildirimleri ile görünür hale gelir, derleyici hangi x'i alacaðýný bilemez hata verir.
//////////////////////////////////////////////////////////////////
///lib1.h
namespace Neco {
	int x = 10, y = 34, z = 456;
	class Myclass {

	};
}

///lib2.h
namespace Akin {
	int x = 10, y = 34, z = 456;
	class Myclass {

	};
}

int  main()
{
	Neco::x = 43; //geçerli
	Akin::x = 12; //geçerli
} 
//////////////////////////////////////////////////////////////////


using namespace bildirimi, func fonksiyonunun gövdesinde yapýlýr.
Bu durumda main içinde x isminin kullanýlmasý gerçersiz ancak func bloðu içinde x ismini kullanmak geçerli.
O blok içinde Neco isim alanýndaki isimler sanki Neco namespace'i içinde deðil global alandaymýþ gibi görülür durumda.
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10, y = 34, z = 456;
	class Myclass {
	};
}

void func()
{
	using namespace Neco;
	
	x = 34; //geçerli
}

int  main()
{
	x = 34; //geçersiz
} 
//////////////////////////////////////////////////////////////////


using bildirimi olsa sentaks hatasý olurdu.
int x = 5; ifadesi sentaks hatasý deðil.
Burada ambiguity yok ama main'deki x ismi global x ismini gizler. 
//////////////////////////////////////////////////////////////////
namespace Neco {
	int x = 10, y = 34, z = 456;
	class Myclass {
	};
}

int  main()
{
	using namespace Neco;

	int x = 5;

	std::cout << x << std::endl; //5
} 
//////////////////////////////////////////////////////////////////


Arguement Dependent Lookup(ADL):

namespace içindeki func isimli fonksiyona çaðrý doðrudan böyle yapýlamaz.
Ya Aykut::func() þeklinde çaðrýlmalý ya da bu isme iliþkin bir using bildirimi veya using namespace bildirimi olmalý.
//////////////////////////////////////////////////////////////////
namespace Aykut {
	void func();
}

int  main()
{
	func(); //geçersiz
} 
//////////////////////////////////////////////////////////////////



isim alaný içinde bir fonksiyon bir de sýnýf bildirimi var.
Mainde o isim alaný içindeki sýnýf türünden bir nesne hayata getirilir.
func fonksiyonu çaðrýldýðýnda sentaks hatasý olmadýðý görülür. Normalde yukuarýdaki gibi func fonksiyonu çaðrýldýðýnda
beklenti geçersiz olmasý.
Burada derleyicinin func ismini Aykut namespace'i içinde arayýp bulmasýnýn nedeni ADL kuralý.
//////////////////////////////////////////////////////////////////
namespace Aykut {
	class Myclass {

	};
	void func(Myclass &r);
}

int  main()
{
	Aykut::Myclass m;
	
	func(m); //geçerli, ADL
} 
//////////////////////////////////////////////////////////////////


ADL'e göre eðer bir fonksiyona gönderilen argümanlardan herhangi biri, bir namespace içinde tanýtýlan türden ise o zaman 
bu fonksiyonun ismi normal aramanýn dýþýnda bu namespace içinde de aranýr. Yukarýdaki örnekte func fonksiyonun parametresi
yine Aykut namespace'i içinde tanýtýlan Myclass türünden. Derleyicinin func ismini Aykut namespace'inde de aramasýnýn nedeni
bu argümanýn bu namespace'in içinde tanýtýlan türlerden olmasý. Ýsim arama argümana baðlý olarak yapýlýr.
Bir fonksiyon çaðýrýyoruz, fonksiyonun ismini nitelemesek bile fonksiyona gönderdiðimiz argüman eðer bir namespace içindeki
türlerden birinden ise derleyici o fonksiyonun ismini o namespace içinde de arar.
Hatta bir fonksiyon olduðu düþünülsün, 4 tane argüman alacak her argümanda farklý bir namespace içindeki türden o zaman o isim
4 namespace içinde de aranýr. Tüm argümanlar için geçerli.
Mekanizma tamamen user defined türler için geçerli.



Burada da bir ADL var.
<< ile operator overloading var, burada aslýnda bir fonksiyon var. operator<< fonksiyonu kullanýlýyor.
s ismi tanýmlandý o yüzden buluyor, cout ismi de std ile nitelendi o yüzden buluyor.
operator<<'in  bildirimi string baþlýk dosyasýnda, o da std namespace'i içinde. Tüm string baþlýk dosyasý std isim
alaný içinde. Nasýl oluyor da ortada bir niteleme yokken std namespace'i içindeki bu fonksiyon bulunuyor ?
Operatör sentaksý kullanýlmasa: operator<<(std::cout, s) þeklinde yazýlýr. operator<< fonksiyonu için std:: ile nitelenmese de 
derleyici gitti std isim alanýna baktý. Bunun std namespace'i içinde aranmasýnýn nedeni, fonksiyona gönderilen argümanýn
veya argümanlardan birinin std isim alaný içinde tanýmlanan türlerden birinden olmasý. string türü veya cout'un dahil olduðu
ostream türü std isim alaný içinde. 
//////////////////////////////////////////////////////////////////
int  main()
{
	std::string s = "ali";
	std::cout << s;
		
} 
//////////////////////////////////////////////////////////////////



Bir isim normal olarak görünürken, bir baþka isim de ADL nedeniyle görünürse bu iki isim arasýnda bir seçilik kriteri yok.
Ýsmin ADL ile bulunuyor olmasý görünen isimler arasýnda bir seçicilik yaratmaz.
Bu iki fonksiyon birbirinden ayrý fonksiyonlar. Neco::Myclass m; ifadesi ile Neco namespace'i içindeki Myclass sýnýfý türünden
bir nesne yaratýlýr. Eðer global func fonksiyonu olmsasaydý;
func(m); ifadesinde bir sentaks hatasý olmazdý, func isminin bulunma nedeni ise ADL olurdu.
ADL ile bulunacak olan fonksiyon yorum satýrýna alýnsa yani sadece global func fonksiyonu olsa
func(m); ifadesi yine geçerli bu sefer global func fonksiyonu çaðrýlýr.
Ancak iki fonksiyona varken func(m) ifadesi geçersiz olur, hatanýn sebebi ise ambiguity.
//////////////////////////////////////////////////////////////////
namespace Neco {
	class Myclass {

	};
	void func(Myclass &) {}
}

void func(Neco::Myclass &) {}

int  main()
{
	Neco::Myclass m;

	func(m); //geçersiz, ambiguity
		
} 
//////////////////////////////////////////////////////////////////


using bildirimi ile veya ADL ile bir overloading etkisi yaratýlabilir.
Her iki isim alanýnda ayný isimde func fonksiyonu var. Eðer parametrik yapýlarý da ayný olsaydý, func fonksiyonuna
yapýlan çaðrý geçersiz olurdu, çünkü isim alaný için de using bildirimi yapýldýðýndan bu durumda ambiguity oluþurdu.
Ancak iki fonksiyonun parametrik yapýlarý birbirinden farklý olduðundan ve de using namespace bildirimlerinden dolayý
her iki fonksiyon da sanki global alandaymýþ gibi görülür. Bu durumda da ayný isimde parametrik yapýlarý farklý iki
fonksiyon olmuþ olur, bu da function overloading.
//////////////////////////////////////////////////////////////////
namespace Ali {
	void func(int) {}
}

namespace Veli {
	void func(double) {}
}

using namespace Ali;
using namespace Veli;

int  main()
{
	func(19);
		
} 
//////////////////////////////////////////////////////////////////


unnamed namespace özelliði: (isimsiz isim alaný)

namespace yazýlýr ancak yanýnda bir isim yok.
//////////////////////////////////////////////////////////////////
namespace{
	int x, y;
}
int main()
{
	x = 20;
}
//////////////////////////////////////////////////////////////////

unnamed namespace C'deki statik globallere bir alternatif. Bu isimsiz isim alanýnýn içine ne konulursa sadece bu modülden
kullanýlabilecek diðer modüllerden görülmeyecek varlýklar. Bu durumda buradaki isimler hiç nitelenmeden görülür durumda.
Derleyici arkaplanda sanki bu namespace'e kendi bir isim vermiþ de onun da using bildirimini yapmýþ gibi kod üretir.
Dilin kurallarýnca bu isimler doðrudan görülür kabul edilir, týpký bir global deðiþken gibi. Zaten nitelenme þansý yok.
Kaynak dosya baþýan tek ve dýþarýdan gizlenmiþtir. Eðer bazý varlýklar sadece bir kaynak dosyada kullanýlacaksa, diðer
modüllerdeki isimlerle çakýþmasý istenmiyorsa, diðer modülleri bu isimler ilgilendirmiyorsa bu isimleri global alanda 
statik anahtar sözcüðü ile bildirmek yerine böyle bir namespace içinde kullanabiliriz.


statik global deðiþkenler için veya fonksiyonlar için kullanýlabildiði gibi türler de konulabilir. 
Böylece bunlar toplu bir yerde durur.
//////////////////////////////////////////////////////////////////
namespace{
	int x, y;
}
//////////////////////////////////////////////////////////////////
x ve y global baþka kimse kullanmayacak. Myclass da bildiðimiz normal bir sýnýf ama dýþarýdan kullanýlmayacak.
Sadece bu kod dosyasý kullanýr.


Bir kütüphanenin isimleri bir namespace içine almasý isim çakýþmasý riskini tamamen engeller mi ?
Çok büyük bir oranda engeller ancak namespace isimlerinin de çakýþma riski var. Sonuçta isim alanlarýnýn da bir
ismi var. 
Aþaðýdaki kod sentaks hatasý. Ýsim alanýnýn kendi ismi de isim çakýþmasý riskine sahip.
//////////////////////////////////////////////////////////////////
namespace Fethi {

}

class Fethi {

};
//////////////////////////////////////////////////////////////////


Bu riski tamamen otadan kaldýrmak adýna, isim alanlarýnýn isimleri özelleþtirilebilir.
Ancak bu durumda client kodlar için bu ismin kullanýlmasý, kullaným zorluðu meydana getirebilir.
Client kod buradaki isimleri kullanmak için namespace adý ile nitelerken her defasýnda bu uzun ismi yazmalý.
//////////////////////////////////////////////////////////////////
namespace CSD_Project_Group{
	int x, y, z;
}
//////////////////////////////////////////////////////////////////


Bunu engellemek için dilin bir aracý var, bu araç namespace alias(isim alaný eþ ismi)
Bir isim alanýna typedef bildirimi gibi namespace'in ismini temsil eden, onun yerine geçen yeni bir isim 
oluþturulabilir. CSD_Project_Group ismini clien kod oluþturmadý, deðiþtirmesi mümkün deðil. Ancak bu ismin yerine
geçen yeni bir isim oluþturabilir.
//////////////////////////////////////////////////////////////////
namespace CSD_Project_Group{
	int x, y, z;
}

namespace Fethi = CSD_Project_Group;

int main()
{
	Fethi::x = 23;
}
//////////////////////////////////////////////////////////////////
Artýk Fethi ismi de derleyici için tamamen CSD_Project_Group ismi ile eþ anlamlý.



Bunun bir faydasý da isim alanlarýnýn nested olduðu, iç içe olduðu durum.
Myclass sýnýfýný derleyiciye aratýp buldurmak için yazýlmasý gereken kod;
CSD_Project_Group::SecretPRoject::Myclass m; ifadesi yazýlmalý.
Bunun yerine nested bir isim alanýna da alias verilebilir.
//////////////////////////////////////////////////////////////////
namespace CSD_Project_Group{
	int x, y, z;
	namespace SecretProject{
		class Myclass{
		
		};
	}
}

namespace Pro = CSD_Project_Group::SecretPRoject;

int main()
{
	Pro::Myclass m;
}
//////////////////////////////////////////////////////////////////


std::regex_constants::basic ifadesi geçerliyse, regex_constants ya bir sýnýf olacak ki deðil.
Buradaki regex_constants bir nested namespace. std isim alaný içindeki bir içsel isim alaný.
//////////////////////////////////////////////////////////////////
int  main()
{
	std::regex_constants::basic
} 
//////////////////////////////////////////////////////////////////



TEMPLATES (ÞABLONLAR)

C++'da derleyicinin kod yazmasýný saðlayacak bir metakod. Derleyiciye bir þablon verilmesinin sebebi, derleyicinin o þablondan
faydalanarak bizim için kod yazacak olmasý. Ýki ayrý kategoriye ayrýlýr, fonksiyon þablonlarý ve sýnýf þablonlarý.
Fonksiyon þablonlarý öyle metakodlar ki derleyici bu metakodlardan faydalanarak bir fonksiyonun kodunu yazar. O þablon
derleyiciye bir fonksiyon kodunu yazdýrmak amaçlý. Sýnýf þablonu ise komple bir sýnýfýn kodunu yazdýrma amaçlý.
Ortak ve ortak olmayan özellikleri var. C++'nýn standart kütüphanesinin neredeyse tamamý þablon. Ortada gerçek kod yok 
metakodlar var. Derleyici, compile time'da bizim için önce fonksiyon ve sýnýflarýn kodunu yazar, ondan sonra onu derler.
C derleyicisi sadece çeviri iþini yapar, C++ derleyicisi kod da yazar.
Çok büyük çoðunlukla þablonlarýn kullanýcý tarafýnda oluruz, metakod yazdýðýmýz durumlarda tabi olacak ancak daha çok 
þablonlarýn kullanýcýsý oluruz. Þablonlar çoðunlukla standart kütüphaneden gelir. Üçüncü parti kütüphanelerin de template
olduðu durumlar var. C++'nýn en önemli kütüphanelerinden biri olan ve standart olmayan  kütüphanesi Boost kütüphanesi de 
önemli bir þablon bazlý kütüphane. Üçüncü parti olarak kullanýlan en yaygýn kütüphane boost kütüphanesi.
Þablonlarýn kendilerini yazma durumumuz görece daha az.

Þablonlar generic programlamanýn en önemli aracý.(türden baðýmsýz programlama)
Generic programlamanýn birbirinden çok farklý sonuçlar veren birkaç farklý implementasyon biçimi mevcut. 
C tarzý generic programlamada, fonksiyonlarýn parametresi void * olur, fonksiyonlara istenilen argüman geçilir.
C'de veri yapýlarý kütüphaneleri çoðunlukla void * parametrelidir.
C++'da þablonlarla gelen genericlik bunla karýþtýrýlmamalý. Burada compile time'da derleyici o sýnýfý ya da fonksiyonu 
fiilen yazar.Avantajlardan biri eðer kullanýlmýyorsa yani bir fonksiyona çaðrý yapýlmýyorsa veya o sýnýf hiç kullanýlmýyorsa
onun kodu hiç yazýlmaz. Böylece bir kod ekonomisi saðlanýr. 
Daha sonradan eklenen sýnýflar için bunlar þablon olduðundan o sýnýflarý da kullanacak sýnýflar ve fonksiyonlar yazma 
þansýna sahibiz.
Fonksiyon þablonlarý fikri, algoritma aslýnda bir iþin nasýl yapýlacaðýný belirler. Birçok algoritmada, algoritma türe
baðlý deðil. Örneðin diziyi reverse etme algoritmasýnda dizinin elemanlarýnýn türü önemli deðil. Swap iþlemi de ayný þekilde.
Nesnelerin türü int de olsa double da olsa algoritma bu. Her ne kadar böyle olsa da C, C++ gibi dillerde algoritmadan koda
geçiþte kod bizden tür bekler. Þablonlarla bu artýk tür farklýlýðýnýn getirdiði farklýlýk ortadan kalkar. Türe göre gerçek
kodun yazýlmasý iþini derleyici yapar.
Sýnýflar söz konusu olduðunda bu iþten en fazla fayda gören veri yapýlarýný implemente eden sýnýflar. Veri yapýlarýnýn genel
organizasyonu belli ancak örnek olarak baðlý listede ne tutulacaðýna baðlý olarak kod deðiþir. 


Function Templates (Fonksiyon Þablonlarý)

function template, template'in metakod'un kendisi. C++'nýn kurallarýna göre yazýlmýþ gerçek kodun kendisi deðil metakod.
template function ise, kodu template'den oluþturularak derleyici tarafýndan yazýlmýþ anlamýnda.

Genel olarak bir þablon oluþturmak için template anahtar sözcüðü zorunlu.
template anahtar sözcüðünden sonra açýsal parantez olur, açýsal parantez içinde template parametreleri denilen parametreler
bildirilir. template parametreli, bir tür bilgisi yerine kullanýlacak isimler. Burada kullanýlan T ismi aslýnda bir tür 
ismini temsil eder. Derleyici bir þekilde T isminin yerine hangi türün kullanýlacaðýný öðrenir, gerçek kodu ona göre yazar.
template'lerin böyle parametrelerine template type parameter denir, tür parametresi denir. Öyle isimler ki türleri temsil eder.
Bir de ikinci bir template parametre türü olarak non-type parametreler var. Bu isimler ise sabitin yerine geçer. Compile time'da
derleyici o sabitin kaç olduðunu bilir, o ismin kullanýldýðý yerde derleyici o sabiti kullanýr.
Derleyiciye compile time'da kullandýðýmýz bir isim karþýlýðý bir türü kullanarak kod yazma olanaðý verilir.

Tür parametreleri için C++'nýn ilk döneminde(standartlar öncesi dönemde) tek bir keyword vardý, class anahtar sözcüðü.
T bir tür olmak üzere anlamýna gelir. Sanki T'nin bir class type olmasý mecburiyeti varmýþ gibi gözükse de öyle deðil, T türü pekala 
int de olabilir. Hala kullanýlýyor, legalite açýsýndan bir problem de yok.
Ancak bu anlamda kullanýlan ikinci bir anahtar sözcük typename anahtar sözcüðü. Her iki anahtar sözcükte T bir tür olmak üzere demek.
Buradaki T isimlerine, template type parameter denir.
template<class T>
template<typename T>

non-type parametre için de doðrudan türün kendisi yazýlýr ve bir isim verilir.
template<int size>
size bir sabit olmak üzere demek, derleyici gerçek kodu yazarken size yerine ne kullanacaðýný bilir.


Derleyici compile time'da T türünün int olduðunu anlarsa, int parametrede bir fonksiyon yazar.
Double olduðunu anlarsa, double türden fonksiyon yazar.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{

}
//////////////////////////////////////////////////////////////////


Derleyici compile time'da T'nin string, size'in ise 20 olduðunu öðrenirse func fonksiyonunun kodunda
oluþturacaðý bu yerel dizinin elemanlarýnýn türü string, eleman sayýsý da 20 olur.
//////////////////////////////////////////////////////////////////
template<typename T, int size>
void func(T x)
{
	T a[size];
}
//////////////////////////////////////////////////////////////////


Derleyiciye bizim istediðimiz bir türü kullanarak kod yazmasý saðlatýlýr veya istediðimiz sabit veya sabitler
kullanýlarak kod yazmasý saðlatýlýr.

Tür parametresinin sayýsal olarak bir sýnýrý yok. Birden fazla olmasý durumunda farklý isimde olmalýlar.
typename<typename T, typename U>
T ve U türler olmak üzere...
Derleyici compile time'da sadece T türünün deðil, U türünün de ne olduðunu bilmek zorunda ve ona göre kod üretmek
durumunda.

Aynýsý non-type parametreler için de geçerli.
template<int low, int high>
low ve high sabitler olmak üzere..

template<typename T, U> ise geçersiz yani typename anahtar sözcüðünü bir kez kullanýp birden fazla tür ismi
belirtmek söz konusu deðil.

template tür parametresi ile fonksiyon parametresi birbirine karýþtýrýlmamalý.
Bundan sonrasý normal bir fonksiyon tanýmlama sentaksý nasýlsa öyle. Fonksiyonun geri dönüþ deðeri türü, adý ve 
ana bloðu yazýlýr. Ancak artýk doðrudan T veya T'ye baðlý olan türlerin fonksiyonun geri dönüþ deðerinin türü olarak,
parametrele deðiþkenlerinin türü olarak veya lokal deðiþkenlerinin türü olarak da kullanabiliriz.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x, T y)
{
	T *ptr = &x;
	T &r = y;
	////
}
//////////////////////////////////////////////////////////////////
Derleyici compile time'da T türünün int olduðunu anlarsa geri dönüþ deðeri olmayan, iki tane int parametresi olan bir 
fonksiyon tanýmlar. ptr, int * türünden, r ise int nesneye referans olur.

Yukarýdaki fonksiyonun kodu deðil!
Derleyiciye fonksiyonun kodunu yazdýrmak için kullanýlan bir þablon.
Bunun derleyici açýsýndan bir önemi de, derleyici bir þablonun üstünden geçtiðinde minimalst bir kontrol yapar.
T türünün ne olduðunu bilmediðinden neyin sentaks hatasý olup olmadýðýný bilemez.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{
	x.func()++;
}
//////////////////////////////////////////////////////////////////
Derleyici bu ifadeye sentaks hatasý vermez. Kodun legalitesi T türünün ne olduðuna baðlý. T türü int ise error.
Ancak T türü bir sýnýf ismi ise, sýnýfýn func isminde bir fonksiyonu varsa ve de fonksiyonun geri dönüþ deðeri
türü örneðin bir referans ve de ayný sýnýfýn operator++ overloadý ise bu kod legal olur.
Bu yüzden derleyici þablonun kendisinin üstünden geçtiðinde birince etapta çok kaba bir kontrol yapar.
; silindiðinde bile sentaks hatasý olmayabilir, bu kodun kendisi deðil þablon.
Asýl kontrol derleyici bu þablondan gerçek bir fonksiyonun kodunu yazmaya çalýþtýðýnda yapar, ayný zamanda yazdýðý 
fonksiyonun kodunu derlerken de normal sentaks kontrolünü yapar.   


Derleyicinin gerçek kodu yazabilmesi için T türünün ne olduðunu bilmesi gerekir. Fonksiyon þablonlarýnda derleyicinin
bu template tür parametrelerinin veya non-type parametrelerinin yerine hangi türleri veya hangi sabitleri yazaacaðýný
anlamasýna yönelik iki mekanizma var, biri çýkarým mekanizmasý(deduction) diðeri ise açýkça derleyiciye programcý olarak
bunun söylenmesi.
Sýnýf þablonlarýnda ise çýkarým mekanizmasý hiç yok. Sýnýf þablonlarýnda tek olasýlýk derleyiciye buradaki template tür 
parametrelerinin ne olduðunu yazdýðýmýz kodla biz programcý olarak söyleriz.

vektör nesneleri oluþturulurken kullandýðýmýz sentaks;
//////////////////////////////////////////////////////////////////
int  main()
{
	vector<int> ivec;
} 
//////////////////////////////////////////////////////////////////
Aslýnda vector isimli bir sýnýf þablonu var, o sýnýf þablonunun template tür parametresi olarak int kullanýlmasý gerektiði
derleyiciye söyleniyor. Burada çýkarým mekanizmasý yok.


swap bir fonksiyon þablonu. swap'ýn kendisi bir fonksiyon deðil.
swap þöyle bir þablon;
template<typename T>
void swap(T &r1, T &r2){
	T temp{r1};
	r1 = r2;
	r2 = temp;
}
Türe baðlý olmasýna raðmen çaðrýyý yaparken tür bilgisini söylemiyoruz.
Buradaki mekanizma deduction.
//////////////////////////////////////////////////////////////////
int  main()
{
	int x = 10, y = 456;
	
	swap(x, y);
} 
//////////////////////////////////////////////////////////////////




17_02_2018_CUMARTESÝ


C++'nýn standart kütüphanesinden bitset sýnýfý. Bitsel iþlemler için kullanýlýr.
Bitset sýnýfý þu þekilde düþünülebilir;
template<size_t n> //non-type parametre, n bir sabit
class bitset{

};
Dolayýsýyla derleyiciye sýnýfýn kodunu yazarken kullanacaðý sabitin ne olduðunu söylememiz gerekiyor.
//////////////////////////////////////////////////////////////////
int  main()
{
	bitset<32> x;
} 
//////////////////////////////////////////////////////////////////
Derleyici bu sýnýfýn kodunda bazý yerlerde sabit kullanmak zorunda, o sabit yerine 32 sabitini kullanmasýný istedik.
Tipik bir non-type parameter uygulamasý. 



array template'leri de, C++11 ile standart haline getirilmiþ eski bir boost sýnýfý. Amacý dizileri sarmalamak. C++'da 
artýk C tarzý diziler yerine vektör veya array kullanýlýr. Diziyi doðrudan kullanmak yerine array template'i kullanýlýr.
array template'inde hem type parametre hem de non-type parametre mevcut.
template<typename T, size_t size>
class Array{

};
þeklinde düþünülebillir. Ýki template parametresi var. Ýlki sarmalanacak dizinin öðelerinin türü, ikinci non-type 
parametre ise dizinin boyutu.
//////////////////////////////////////////////////////////////////
int  main()
{
	int a[10];
	array<int, 10> arr;
} 
//////////////////////////////////////////////////////////////////
maliyet açýsýndan ikisinin bir farký yok. Köþeli parantez operatörü ile yine dizinin öðelerine array sýnýfý içinde de
eriþilir. C tarzý dizinin yapamayacaðý bazý iþeri de yapar. 


Bu tür kodlarý yazdýrmak için, non-type parametreye verilecek deðerin bir constant expression, sabit ifadesi olmasý
gerekir.

Ýster type parametre olsun ister non-type parametre olsun, derleyicinin compile time'da kodu yazabilmesi için T türü 
yerine neyi alacaðýný ya da size yerine hangi sabiti kullanacaðýný bilmesi gerekiyor. Bunu bilmesinin de 2 yolu vardý.
Ýlki deduction, derleyici bunu contextden kendisi çýkarmaya çalþýr, ikincisi ise programcýnýn kendisinin söylemesi.
Fonksiyon þablonlarýnda her iki mekanizma da var.
Sýnýf þablonlarýnda ise çýkarým doðrudan yok.



Fonksiyon þablonlarýnýn genel sentaksýna iliþkin;
Compile time'da derleyici aslýnda 3 tane fonksiyon yazar;
biri string &, string &
biri int &, int &
diðeri ise double &, double &
//////////////////////////////////////////////////////////////////
template<typename T>
void Swap(T &r1, T &r2)
{
	T temp{ r1 };
	r1 = r2;
	r2 = temp;
}

int  main()
{
	int x = 10, y = 20;
	string s1{ "alican" }, s2{ "edanaz" };
	double d1 = 2.3, d2 = 6.7;

	Swap(x, y);
	Swap(s1, s2);
	Swap(d1, d2);

	cout << x << " " << y << endl;
	cout << s1 << " " << s2 << endl;
	cout << d1 << " " << d2 << endl;
} 
//////////////////////////////////////////////////////////////////
Derleyici bir fonksiyon yazmasý gerektiðini ve yazdýðý fonksiyonun parametrelerinin türünün ne olmasý gerektiðini
fonksiyon çaðrý ifadesinden anladý. Burada kulanýlan mekanizma deduction mekanizmasý.


Þablonlar üstünde derleyici 3 aþamalý bir kontrol yapar. Biri þablonun kendisinin üstünden geçerken yaptýðý kontrol.
Burada T türünün ne olduðunu bilmediðinden, T türünün kullanýmýna iliþkin bir sentaks hatasý vermesi mümkün olmaz.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &r)
{
	r.foo();
	++r;
	r[10].foo();
}
//////////////////////////////////////////////////////////////////
gibi bir iþlev yazýldýðýnda, T türünün ne olduðuna baðlý olarak kod legal olabilir, olmayabilir de.
Birinci aþamada derleyiciler sadece çok bariz, her zaman hata olabilecek durumlarý kontrol ederler.


Üçüncü kontrol ise açýk, T türünün int olduðunu bilse fonksiyonun parametresi int &r olurdu.
Gerçekten int &r parametreli bir fonksiyonda r.foo() ifadesi nasýl ki sentaks hatasý olacaksa burada da derleyici
ayný bu þekilde kontrol yapar ve sentaks hatasý verir.


Fonksiyon þablonlarýnda en karýþýk konu, derleyicinin yaptýðý çýkarýmý nasýl yaptýðý, template arguement deduction.
Swap fonksiyonunda, T'nin ne olmasý gerektiðini derleyici kendisi çýkarýmýný yaptý. Ýþte ikinci aþama kontrol burada.

Template Arguement Deduction


þeklinde bir þablon olsun, þablonun template tür parametresi var.
Elimizde bir fonksiyon þablonu var diye, o fonksiyon þablonu ile yapýlacak tüm çaðrýlar legal olmak zorunda deðil.
Ýki tipik illegalite durumu var. Birincisi fonksiyon çaðrýsýndan hareketle derleyicinin template parametrelerinin
ne olduðunu anlama þansýnýn hiç olmamasý.

Þablonun kendisinin olmasý bir sentaks hatasý deðil.
Derleyicinin compile time'da bu kodu yazabilmesi için, T türünün ne olduðunu bilmesi gerekiyor.
Fonksiyon çaðrýsýnda argüman bile yok, T türünün ne olduðunu anlama þansý yok.
Derleyicinin verdiði sentaks hatasýnýn nedeni, eldeki çaðrýdan elde edilecek bilgiler T türünün ne olduðunu
anlamasýna izin vermiyor.
//////////////////////////////////////////////////////////////////
template<typename T>
T func()
{
	return 1;
}

int  main(){
	func(); //geçersiz
} 
//////////////////////////////////////////////////////////////////


T türü, yerel bir deðiþkenin türü.
Derleyici bu fonksiyon çaðrýsýndan T türünün ne olduðunu yine anlayamaz.
//////////////////////////////////////////////////////////////////
template<typename T>
void func()
{
	T x;
}

int  main(){
	func(); //geçersiz
} 
//////////////////////////////////////////////////////////////////


Yani derleyicinin bir fonksiyonun kodunu yazabilmesi için T türünün ya da template tür parametrelerinin hangi türe
karþýlýk geldiðini bilmesi gerekiyor. Bunu ya programcý olarak biz explicit olarak söyleriz ya da derleyicinin
çýkarýmýna býrakýrýz. Derleyicinin çýkarýmýna býraktýðýmýzda da çýkarýmý yapabileceði araçlara sahip olmasý gerekir.


Ýkinci bir error senaryosu daha var, ambiguity.

Derleyicinin T türünün ne olduðunu gönderilen argümanlardan anlamasý gerekir.
func(10, 29) çaðrýsý geçerli. Derleyici argüman olan ifadenin türüne bakar, 10 ifadesinin türü int.
O zaman x de T türünden olduðuna göre T türünün int olmasý gerekir. y de T türünden, y'ye gönderilen argüman da int.
func(10, 2.9) þeklinde func fonksiyonuna çaðrý yapýldýðýnda ise derleyici artýk bu çýkarýmý yapamaz. Ýlk argümana
bakarsa T türünün int, ikinci argümana bakarsa T türünün double olmasý gerekir. Derleyici bu konuda arýk bir 
çeliþki gördüðü için ambiguity hatasý verir.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x, T y)
{

}

int  main(){
	func(10, 29);
	func(10, 2.9); //çift anlamlýlýk hatasý
} 
//////////////////////////////////////////////////////////////////


þablon aþaðýdaki þekilde olsaydý ortada bir problem olmazdý.
Yani func(10, 2.9) çaðrýsý da geçerli olurdu. Artýk derleyici her bir template tür parametresini ayrýca deduce 
ederdi. T'nin int; U'nun ise double türden olduðunu anlardý.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
void func(T x, U y)
{
	std::cout << "type T is " << typeid(T).name() << endl;
	std::cout << "type U is " << typeid(U).name() << endl;
}

int  main()
{
	func(10, 2.9); //geçerli
} 
//////////////////////////////////////////////////////////////////



func fonksiyonu içinde foo ve g fonksiyonlarýna çaðrý yapýlýyor.
foo ve g de þablon olabilir.
Bunlarýn hepsi compile time'da olur. Derleyici func çaðrýsýný görünce template arguement deduction yapar.
T'nin int, U'nun double olmasý gerektiðini anlar. Dolayýsýyla x'in türü int olduðundan foo'nun kendisi de bir
template olduðundan onun da template tür parametresinin int olduðunu anlar. 
g için de benzer iþi yapar.
//////////////////////////////////////////////////////////////////
template<typename T>
void foo(T x)
{
	cout << "template foo : typename is: " << typeid(T).name() << endl;
}

template<typename T>
void g(T x)
{
	cout << "template g : typename is: " << typeid(T).name() << endl;
}

template<typename T, typename U>
void func(T x, U y)
{
	cout << "template func : typename is: " << typeid(T).name() << endl;
	cout << "template func : typename is: " << typeid(U).name() << endl;
	foo(x);
	g(y);
}

int  main()
{
	func(10, 2.9);
} 
//////////////////////////////////////////////////////////////////


template<typename ...> bu ifadeyi bir kere yazýp birden fazla fonksiyon için kullanmak gibi bir sentaks yok.
her bir template'deki tür isimleri birbirinden ayrý, birbirleri ile scope olarak da ayrýlar, ilgileri yok.
Baþlýk dosyasýnda birden fazla template varsa programcýlar bunlara ayný isimleri vermekten kaçýnmazlar.



Nasýl fonksiyonlar hem bildirilip hem tanýmlanabiliyorsa, template olmalarý bildirimi engellemez.
//////////////////////////////////////////////////////////////////
template<typename T>
void foo(T x);	//fonksiyon þablonunun bildirimi
//////////////////////////////////////////////////////////////////
Ýster fonksiyon þablonu ister sýnýf þablonu olsun bunlarýn yeri her zaman baþlýk dosyalarý. 
Baþlýk dosyasýnda bunun bildiriminin olmasý kod üretimi için yeterli deðil. Bildirimin yapýlabilmesinin bazý baþka
nedenleri var. Bu bildirim normal fonksiyon bildirimleri ile karýþtýrýlmamalý.
Örnek olarak bu bildirimin kaan.h baþlýk dosyasýnda olduðu düþünülsün. necati.c de kaan.h'yý include etsin.
Derleyici sentaks kontrolünü yapabilir ancak template kodun kendisi olmadýðý için kodu üretemez.
Böyle bir kod yazýldýðý zaman bu derlenebilir ancak link edilme þansý yok.


Fonksiyon dizi ismi ile çaðrýlýr bu durumda array to pointer conversion yapýlýr.
Yani T türü int * türünden.
Bir string literali ile fonksiyona çaðrý yapýldýðýnda yine array to pointer conversion yapýlýr.
char türden const diziler olduðundan T türü için const char * çýkarýmý yapýlýr.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x){
}

int  main()
{
	int a[100];
	const int b[100]{};

	func(a); //T is int *
	func(b); //T is const int *

	func("neco"); //const char *
} 
//////////////////////////////////////////////////////////////////


&x ifadesinin türü int *. 
ptr'nin int * türünden olmasý için T'nin türünün int olmasý gerekir.
T'nin türü int.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T *ptr) {
	std::cout << typeid(T).name() << std::endl;
}

int  main()
{
	int x = 10;
	func(&x); //T is int, ptr is int *

} 
//////////////////////////////////////////////////////////////////


void func(T ptr); olduðunda ise, fonksiyona gönderilen int * olduðundan T'nin türü int * olur.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T ptr) {
	std::cout << typeid(T).name() << std::endl;
}
//////////////////////////////////////////////////////////////////



fonksiyonun parametersi bir fonksiyon göstericisi. func fonksiyonu foo ile çaðrýlýyor.
foo'nun geri dönüþ deðeri int, parametresi int türden olduðundan T türü int.
func'un parametresinin türü ise, geri dönüþ deðeri ve parametresi int olan bir fonksiyonun adresini tutacak olan
pointer.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T (*f)(T)) {
	std::cout << typeid(T).name() << std::endl;
}

int foo(int) {

	return 1;
}

int  main()
{
	func(foo); //T is int, f is int(*)(int)
} 
//////////////////////////////////////////////////////////////////



Bu durumda ise T int, U double türdendir.
func'ýn parametresi ise, geri dönüþ deðeri int, parametresi double olan fonksiyon adresi göstericisi
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
void func(T(*f)(U));

int foo(double);

int  main()
{
	func(foo); // T is int U is double, f is int(*)(double)
} 
//////////////////////////////////////////////////////////////////


2.kategori, parametrenin wrap olmasý durumu:


x için T'nin türü int, fonksiyon parametresinin türü ise int &.
y içinse T'nin türü const int, fonksiyon parametresinin türü ise const int &.
T türü const int olduðunda, fonksiyon bloðu içinde T türünden lokal bir nesne oluþturulup, sonradan deðiþtirilmek
istendiðinde geçersiz olur çünkü T türü const int.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &x);

int  main()
{
	int x = 10;
	func(x); //T is int, x is int &

	const int y = 20;
	func(y); //T is const int, x is const int &
} 
//////////////////////////////////////////////////////////////////


T'nin türü int olur, çünkü fonksiyona gönderilen r'nin türü int &.
func fonksiyonunun parametresinin türü ise int &.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &x);

int  main()
{
	int x = 10;
	
	int &r = x;

	func(r); //T is int, r is int &
} 
//////////////////////////////////////////////////////////////////



func, a ile çaðrýlýyor. Artýk burada arrat to pointer conversion yok.
parametre referans türden olmasaydý int * olurdu.
þimdi ise int *'a referans deðil, 5 elemanlý int türden bir diziye referans.
T'nin türü 5 elemanlý dizi türü, parametre ise 5 elemanlý int diziye referans.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &x);

int  main()
{
	int a[5]{0};

	func(a); // T is int [5], r is int(&)[5]
} 
//////////////////////////////////////////////////////////////////



func fonksiyonu a, b ile çaðrýldýðýnda geçerli. Çünkü her ikisi de T türü 5 elemanlý int dizi türü.
func (a,c) ile çaðrýldýðýnda ise ambiguity hatasý oluþur. Birinci argümana bakýldýðýnda T'nin türü 4 elemanlý int
dizi türü, ikinci argümana bakýldýðýnda ise T'nin türü 5 elemanlý int dizi.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &r1, T &r2);

int  main()
{
	int a[4];
	int b[4];
	int c[5];

	func(a, b); //geçerli
	func(a, c); //ambiguity
} 
//////////////////////////////////////////////////////////////////



func("alican", "mehmet") ifadesi geçerli çünkü T türü 7 elemanlý const char dizi türü olarak alýnýyor.
func("metin", "mehmet") ifadesi ise sentaks hatasý yine ambiguity hatasý var, biri 6 elemanlý diðeri 7 elemanlý
const char türden dizi, tür farklýlýðý var.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &r1, T &r2);

int  main()
{
	func("alican", "mehmet"); //geçerli
	func("metin", "mehmet");  //ambiguity
} 
//////////////////////////////////////////////////////////////////



display fonksiyonuna sadece dizi geçilerek, boyut bilgisi geçilmeden tüm dizinin dolaþýlmasý saðlanýr.
Farklý boyutlardaki dizi için geçerli, bu durumda referans zaten dizinin yerine geçeceði için kod geçerli.
Aslýnda derleyici 2 farkllý dizi için 2 farklý fonksiyon yazmýþ olur.
//////////////////////////////////////////////////////////////////
template<typename T>
void display(const T &r)
{
	for (int k = 0; k < sizeof(r) / sizeof(*r); ++k)
		std::cout << r[k] << " ";
	std::cout << std::endl;

	/*for(auto x : r)
		std::cout << x << " ";
	std::cout << std::endl;*/
}

int  main()
{
	int a[5]{ 1,2,3,4,5 };
	int b[10]{ 7, 81, 13, 41, 97, 44, 55, 67, 2, 3 };
	
	display(a);
	display(b);
} 
//////////////////////////////////////////////////////////////////



C'de bir dizinin boyutunu derleyiciye hesaplatmak için ön iþlemciye bunu yaptýrýrdýk.
sizeof(a) / sizeof(*a) ifadesini ön iþlemciye yazdýrýrdýk.
C++'da ise çok daha iyi bir olanak var, bunu bir fonksiyon þablonu halinde yazmak.
arrsize(a) ifadesinde template arguement deduction kurallarýna göre T, int size sabiti ise 10 olur.
T'nin türü 10 elemanlý int dizi türü olur. fonksiyon size ile geri döndüðünden doðrudan dizi boyutu elde edilir.
int c[arrsize(a) * 2] ifadesinde dizi boyutunun geçerli olabilmesi için içindeki ifadenin sabit ifadesi olmasý
gerekir. fonksiyon constexpr olarak tanýmlandýðýndan bu geçerli olur.
constexpr fonksiyonlar, sabit ifadesi ile çaðrýldýðýnda geri dönüþ deðeri compile time'da elde edilir.
constant expression ile çaðrýlmadýðýnda ise geri dönüþ deðeri run time'da elde edilir.
//////////////////////////////////////////////////////////////////
template<typename T, size_t size>
constexpr size_t arrsize(T (&r)[size])
{
	return size;
}

int  main()
{
	int a[10] = { 0 };
	int b[] = {2, 5, 5, 8, 8};
	int c[arrsize(a) * 2];

	cout << arrsize(a) << endl;
	cout << arrsize(b) << endl;
	cout << arrsize(c) << endl;
} 
//////////////////////////////////////////////////////////////////



Eðer bir template tür parametresi varsa fakat fonksiyonun parametresi iki tane && ile yazýlmýþsa burada r kesinlike
sað taraf referansý anlamýna gelmez. 
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T &&r)
{
}
//////////////////////////////////////////////////////////////////
Bu fonksiyonu sol taraf deðeri ile çaðýrýrsak r sol taraf referansý; sað taraf deðeri ile çaðýrýsak r sað taraf
referansý olur.

Modern C++'nýn önemli araçlarýndan biri, üçüncü kategori.
Eðer fonksiyonun parametresi && olursa, böyle referanslara universal reference denir.


Örnek olarak vektor sýnýfýnýn push_back fonksiyonu, fonksiyonun parametresi &&val.
l-value referans mý r-value referans mý olacaðý tamamen compile time'da ne gönderildiðine baðlý olarak deðiþir.
//////////////////////////////////////////////////////////////////
int  main()
{
	vector<int> ivec;

	ivec.push_back(10);
} 
//////////////////////////////////////////////////////////////////


STL'de parametrik yapýsý þu þekilde olan birçok fonksiyon görülür.
template<typename T>
void func(T &&);


Elimizde bir fonksiyon þablonu var ve fonksiyon þablonunun parametresi T türünden.
T türünden parametre fonksiyon çaðrý operatörünün operandý yapýlmýþ.
//////////////////////////////////////////////////////////////////
template <typename T>
void func(T f)
{
	f();
}
//////////////////////////////////////////////////////////////////

T'nin hangi tür olarak çýkarýmýnýn yapýlmasý durumunda böyle bir kod legal olabilir ?
Buradaki f gibi isimlere modern C++'da callable denir. Çünkü böyle bir template'den üretilen kodun geçerli olmasýný
saðlayacak çok saydý senaryo var. 

Bu fonksiyona bir fonksiyon adresi gönderilir, bu durumda derleyici T türünü bir function pointer olarak çýkarýmýný 
yapar dolayýsýyla run time'da çaðrýlacak fonksiyonda o function pointer'in gösterdiði fonksiyonla olur. Bu durumda
iþlevin parametresi bir iþlev göstericisi olur.

func(foo) ifadesine derleyici compile time'da bakar. Bu durumda T'nin türünü void(*)(void) olmasý gerektiðini anlar.
Böyle bir fonksiyon parametreli bir fonksiyon yazar, f(); ifadesinde çaðrýlan fonksiyonda func'a argüman olarak
gönderilen foo fonksiyonu.	
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T f)
{
	f();
}

void foo()
{
	cout << "foo cagrildi" << endl;
}

int  main()
{
	func(foo);
} 
//////////////////////////////////////////////////////////////////



f bir sýnýf nesnesi de olabilir, böyle sýnýf nesnelerine functor denir. T türü fonksiyon çaðrý operatörünü overload 
eden bir sýnýf türü olabilir. T de o türden bir nesne olur. T bir sýnýf türüdür ve T sýnýfý fonksiyon çaðrý opeatörünü
overload etmiþtir.


Client kod, Functor sýnýfý türünden bir nesne tanýmlayýp fonksiyon þablonuna x'i argüman olarak geçti.
Derleyici T türünün bu sýnýf türü olduðunu anladý. Derleyicinin yazdýðý kodda fonksiyon çaðrý operatörünün operandý
bir sýnýf nesnesi olduðu için çaðrýlan fonksiyon sýnýfýn fonksiyon çaðrý operatör fonksiyonu oldu.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T f)
{
	f();
}

class Functor {
public:
	void operator()()
	{
		cout << "Functor::operator()" << endl;
	}
};

int  main()
{
	Functor x;

	func(x);
} 
//////////////////////////////////////////////////////////////////



stl'deki birçok fonksiyon böyle, mesela algorithm baþlýk dosyasýndakiler.
algorithm baþlýk dosyasýndaki find_if algoritmasýnýn birebiri yazýldý, Find_if(orjinali küçük harfli)
2 tane template tür parametresi var. Fonksiyonun ise 3 tane parametre deðiþkeni var.
Derleyici compile time'da kod yazabilmek için InIter ve F türünün ne olduðunu anlar.
main içinde bir baðlý liste nesnesi oluþturuldu, list'in string açýlýmý türünden slist.
fonksiyona yapýlan çaðrýda listenin begin'i, listenin en'i ve de üçüncü parametre olarak mypred fonksiyonu geçildi.
Bu Find_if þablonundan herhangi bir veri yapýsýnda herhangi bir deðeri aramak için onlarca ayrý fonksiyon yazýlabilir.
mypred fonksiyonu ise bool'a geri dönen bir fonksiyon, parametre olarak aldýðý string'in uzunluðu 5 ise true döner.
Derleyici InIter türünün hangi tür olduðunu fonksiyon çaðrýsýndaki ilk iki parametreye bakarak anlar.
slist.begin() fonksiyonunun geri dönüþ deðeri list'in string açýlýmýnýn iteratörü türü. Derleyici geri dönüþ deðeri
list'in string açýlýmýnýn iteratoru türü olan, birinci parametre ve ikinci parametre deðiþkeni list'in string 
açýlýmýnýn iteratoru türünden olan üçüncü parametresi de geri dönüþ deðeri bool, parametresi const string & olan
bir fonksiyon göstericisi olan fonksiyonu yazar.
Find_if fonksiyonu geçilen aralýktaki stringlerden her biri için döngünün her turunda, adresi alýnan fnc fonksiyonunu
çaðýrýr, fnc true dönerse o iterator deðerini return eder. Aranan deðer bulunmazsa beg ile döndüðüne göre, o range'in
end iteratörü deðerini döndürür.
uzunluðu 5 olan ilk string ile döner.
//////////////////////////////////////////////////////////////////
template<typename InIter, typename F>
InIter Find_if(InIter beg, InIter end, F fnc)
{
	while (beg != end) {
		if (fnc(*beg))
			return beg;
		++beg;
	}
	
	return beg; 
}

bool mypred(const string &r)
{
	return r.size() == 5;
}

int  main()
{
	list<string> slist{ "ali", "huseyin", "aykut", "tayfun", "poyraz", "fethi" };

	auto iter = Find_if(slist.begin(), slist.end(), mypred);

	if (iter != slist.end()) {
		cout << "bulundu " << *iter << endl;
	}
	else
		cout << "bulunamadi" << endl;

} 
//////////////////////////////////////////////////////////////////




Uzunluðu 5 deðil 6 olan için yeni bir fonksiyon yazýlýp, üçüncü parametre olarak bu fonksiyon geçilir.
Bunu otomatik hale getirmek için ise bir sýnýf oluþturulur. LenPred isminde bir sýnýf oluþturuldu.
Sýnýfýn fonksiyon çaðrý operatör fonksiyonu mevcut, bu fonksiyon bir yukarýdaki örnekteki mypred'e benzer bir iþ
yapar. Parametre olarak aldýðý string'in uzunluðuna bakar, bu uzunluk mlen'e eþitse true döner. mlen ise sýnýfýn
private veri elemaný, constructor ile set edilir.
Main'de Find_if'e yapýlan çaðrýda üçüncü parametre olarak LenPred sýnýfý türünden bir geçici nesne kullanýlýr.
Geçici nesne istenilen uzunluk deðerini parametre olarak alýp öyle construct edilir.
Bu durumda derleyicinin yazacaðý fonksiyonun F template tür parametresi LenPred olacak, böylece fonksiyona LenPred
türünden bir deðer gönderilir.
Böyle sýnýflara functor sýnýflar denir.
//////////////////////////////////////////////////////////////////
template<typename InIter, typename F>
InIter Find_if(InIter beg, InIter end, F fnc)
{
	while (beg != end) {
		if (fnc(*beg))
			return beg;
		++beg;
	}
	
	return beg; 
}

class LenPred {
	int mlen;
public:
	LenPred(int len) : mlen{len} {}
	bool operator()(const string &s)
	{
		return s.size() == mlen;
	}
};

int  main()
{
	list<string> slist{ "ali", "huseyin", "aykut", "tayfun", "poyraz", "fethi" };
	cout << "uzunluk degerini girin : ";
	int len;
	cin >> len;

	auto iter = Find_if(slist.begin(), slist.end(), LenPred{len});

	if (iter != slist.end()) {
		cout << "bulundu " << *iter << endl;
	}
	else
		cout << "bulunamadi" << endl;

} 
//////////////////////////////////////////////////////////////////



Fonksiyon template'leri de birbirini overload edebilir.
func ismi ile çaðrýlacak fonksiyona, iki argüman gönderilirse yukarýdaki template'den, tek argüman gönderilirse
aþaðýdaki template'den açýlým yapýlacak.
Ýlk çaðrýda yukarýdaki template kullanýlýr ve T türü float olarak deduce edilir.
Ýkinci çaðrýda ise alttaki template kullanýlýr T türü ise unsigned int.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x, T y)
{
	std::cout << "func(T x, T y) typename T is: " << typeid(T).name() << std::endl;
}

template<typename T>
void func(T x)
{
	std::cout << "func(T x) typename T is: " << typeid(T).name() << std::endl;
}
int  main()
{
	func(4.5f, 3.4f);
	func(9u);
} 
//////////////////////////////////////////////////////////////////



Diðer önemli bir durum ise, bir fonksiyon ile bir template'in bir arada olmasý.
Bu isimde fonksiyona, gerçek fonksiyonun parametresi ile exact match olan bir argüman verilirse gerçek fonksiyon
çaðrýlýr, aksi halde template'den fonksiyon yazýlýr.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{
	std::cout << "template func(T x) typename T is: " << typeid(T).name() << std::endl;
}

void func(double dval)
{
	std::cout << "non template func(double dval)" << endl;
}
int  main()
{
	func(3u);  //template func
	func(3.f); //template func
	func(3.4); //non template func
} 
//////////////////////////////////////////////////////////////////



Sadece belirli bir tür için çaðrýlacak bir fonksiyon þu þekilde yazýlabilir.
Bir template fonksiyon bildirilir ve de bu fonksiyon delete edilir.
Bir de gerçek fonksiyon yazýlýr. Bu durumda sadece gerçek fonksiyonun parametre türü için yapýlan çaðrýlar
geçerli olur, baþka türlerle yapýlan çaðrýlar geçersiz.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x) = delete;

void func(double dval)
{
	std::cout << "non template func(double dval)" << endl;
}
int  main()
{
	func(3.5);
	func(5); //geçersiz
} 
//////////////////////////////////////////////////////////////////



Üstteki template de, alttaki template de func(&x) çaðrýsýna uygun.
Templateler ayrý ayrý yoruma alýnýp sadece biri varken çaðrý yapýlýrsa her ikisi için de çaðrý geçerlidir.
Ýlk template için T'nin türü int *; ikinci template içinse T'nin türü int olur.
Bu iki fonksiyon birden açýkken hangi durumda hangi template'in seçileceðine dair dilin bazý farklý kurallarý
var, buna ordering rules denir.
Daha spesifik olanýn önceliði var.
T türünün int olmasýyla, int * olmasý arasýnda, T'nin int olarak çýkarýmýnýn yapýlmasýnýn diðerine göre üstünlüðü
var. 
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{
	std::cout << "template function func(T x) type T is : " << typeid(T).name() << std::endl;
}

template<typename T>
void func(T *ptr)
{
	std::cout << "template function func(T *ptr) type T is : " << typeid(T).name() << std::endl;
}

int  main()
{
	int x = 10;
	func(&x); //alttaki template için fonksiyon yazýlýr.
} 
//////////////////////////////////////////////////////////////////
Bir fonksiyon çaðrýsýndaki argüman eðer birden fazla template için uygunsa arkaplanda ordering rules devreye girer.
Seçim kriterinde daha kompleks çýkarýmlar daha yüksek seçilebilirlik özelliðine sahip.



Aslýnda C++11 öncesi sadece sýnýf þablonlarýna bir özellikti, C++11 ile birlikte fonksiyon þablonlarýna da tanýnan
bir hak haline geldi: Varsayýlan Template Tür Parametresi
Öyle bir template var ki, template tür parametresine herhangi bir tür argümaný verilmediðin zaman sentaksta 
belirlenen tür verilmiþ kabul ediliyor.
template<typename T = int>: Ya T'nin ne olduðu derleyiciye söylenecek ya da eðer söylenmezse derleyici T'nin int
olduðu bilgisini elde edecek.
//////////////////////////////////////////////////////////////////
template<typename T = int>
class Myclass {
public:
	Myclass() {
		std::cout << "type T is : " << typeid(T).name() << std::endl;
	}
};

int  main()
{
	Myclass<double> mx; // T türü double
	Myclass <> my; // T türü int
} 
//////////////////////////////////////////////////////////////////
Buna varsayýlan template tür parametresi denir.



Burada da týpký fonksiyonlarýn varsayýlan argüman alabilmesi gibi soldaki bir template tür parametresi varsayýlan
tür argümaný aldýðýnda onun saðýndakilerinin hepsinin almasý gerekiyor. Yani;
template<typename T = int, typename U> gibi bir ifade doðrudan sentaks hatasý, geçersiz.
//////////////////////////////////////////////////////////////////
template<typename T = int, typename U = double>
class Myclass {
public:
	Myclass() {
		std::cout << "type T is : " << typeid(T).name() << std::endl;
		std::cout << "type U is : " << typeid(U).name() << std::endl;
	}
};

int  main()
{
	Myclass<long, char> mx; // T'nin türü long, U'nun türü char
	Myclass<long> my; //T'nin türü long, U'nun türü double
	Myclass<> mz; //T'nin türü int, U'nun türü double
} 
//////////////////////////////////////////////////////////////////	 



Zaten sýnýf þablonlarýnda mecburi olan, fonksiyon þablonlarýnda da kullanýlabilen bir özellik daha var.
Türün ne olduðunu programcý olarak biz de söyleyebiliriz.
Aþaðýdaki þablon için, func(10); çaðrýsý yapýldýðýnda derleyici T'nin int olduðu çýkarýmýný kendisi yapar.
Ancak func<int>(10); ifadesinde artýk çýkarým yok, hangi argüman gönderilirse gönderilsin derleyici T türünü
<> içne geçilen tür olarak alýr.
Açýk, explicit olarak template tür parametrelerinin ne olduðunu derleyiciye söyleyebiliriz.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{
	std::cout << "type T is : " << typeid(T).name() << std::endl;
}

int  main(){

	func<int>(10);
} 
//////////////////////////////////////////////////////////////////



Bu birden fazla template tür parametresine de uygulanabilir.
func<double>(4, 2) ifadesinde bir tür explicit olarak belirtildiðinden, birinci template tür parametresinin
double olmasý gerektiði söylendi, ikinci için ise yine derleyici kendi çýkarým yapacak. Ýlk parametre için 4 
gönderilmesine raðmen deduction istenmiyor, T türü double olur, U türü ise çýkarýmla int olur.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
void func(T x, U y)
{
	std::cout << "type T is : " << typeid(T).name() << std::endl;
	std::cout << "type T is : " << typeid(U).name() << std::endl;
	std::cout << "**********************************************\n";
}

int  main(){

	func(12, 4.5); 
	func<double>(4, 2);
	func<int, char>(4, 'A');
} 
//////////////////////////////////////////////////////////////////



C++11 öncesinde template'ler ile ilgili tipik bir problem mevcuttu, problemin çözümü farklý yýllarda gelen
standartlar ile farklý þekillerde çözülmeye çalýþýldý.
Bir fonksiyon yazýlmak isteniyor ve bu fonksiyon iki tane deðeri toplama iþleminde kullanýlacak. Ýlk baþta 
þöyle bir þablon yazýlýyor.
//////////////////////////////////////////////////////////////////
template<typename T>
T add(T x, T y)
{
	return x + y;
}

int  main(){

	//derleyici türler için kendi çýkarým yapar
	cout << add(2, 6) << endl; 
	cout << add(2.1, 6.4) << endl;

	string s1{ "eda" };
	string s2{ "naz" };

	cout << add(s1, s2) << endl;

} 
//////////////////////////////////////////////////////////////////


Ancak client kodlarýn bu template'den hareketle add(3, 4.5) gibi iþlemleri de yapabilmesi isteniyor. Ancak
ikisi ayný tür olmadýðý için sentaks hatasý.(ambiguity)


Yukarýdaki ambiguity'yi aþmak için C++2003'deki çözüm þu þekilde:
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
T add(T x, U y)
{
	return x + y;
}
int main()
{
	cout << add(3, 4.5) << endl;
}
//////////////////////////////////////////////////////////////////
Tabi buradaki problem de, geri dönüþ deðerinin türü ne olacak ? 
Fonksiyona main'de geçilen birinci argümanýn türü int, fonksiyonun geri dönüþ deðeri de o türden olduðu için
mevcut durumda veri kaybý oluþur.
Fonksiyon U türüne geri dönseydi de bu sefer add(4.5, 3) çaðrýsýnda yine veri kaybý olmuþ olacaktý.



Önceleri yapýlan çözümde üçüncü bir template tür parametresi verilirdi.
Fonksiyonun geri dönüþ deðerinin türü bu R türünden yapýlýrdý. Geri dönüþ deðerini ise fonksiyonu çaðýranýn
kendisi belirlemeliydi.
add<double>(3.7, 4); çaðrýsýndan görüleceði üzere geri dönüþ deðerinin türü double.
Fonksiyona geçilen parametrelerin sýrasý ile ilgili oluþan ambiguity problemi de burada çözülmüþ durumda.
//////////////////////////////////////////////////////////////////
template<typename R, typename T, typename U>
R add(T x, U y)
{
	return x + y;
}

int main()
{
	cout << add<double>(3.7, 4) << endl;
	cout << add<double>(9, 4.5) << endl;

}
//////////////////////////////////////////////////////////////////



C++11 ile, daha pratik bir çözüm bulundu.
trailing return type diye bir terim ortaya atýlýyor. trailing return type herhangi bir fonksiyona da 
uygulanabilir, yani normal fonksiyonlar için de geçerli bir sentaks özelliði. Ancak normal bir fonksiyona
uygulamanýn bir faydasý yok. Örnek olarak normalde bir sayýnýn karesi ile geri dönen bir fonksiyon þöyle
yazlýr:
//////////////////////////////////////////////////////////////////
int square(int)
{
	return x * x;
}
//////////////////////////////////////////////////////////////////



trailing return type kullanýlarak ise fonksiyon þu þekilde yazýlabilir:
//////////////////////////////////////////////////////////////////
auto square(int) ->int
{
	return x * x;
}
//////////////////////////////////////////////////////////////////
Bu fonksiyonun geri dönüþ deðerinin int olduðu anlamýna gelir. Zaten normal fonksiyonlar için böyle bir
yazýmýn bir anlamý yok. Bu templateler için geliþtirilmiþ bir özellik.



Yukarýda yapmýþ olduðumuz add fonksiyonu örneðinde aslýnda fonksiyonun geri dönüþ deðeri x + y; ifadesinin
geri dönüþ deðeri olsa bir veri kaybý olmaz. Bir ifadenin türünün ne olduðunu gösteren decltype niteleyicisi
kullanýlýr.
decltype(x+y) ifadesi yazýldýðýnda, bu x+y ifadesinin türü anlamýna gelir. Yani fonksiyonun geri dönüþ
deðerinin türü x+y ifadesinin türü olur. 
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
decltype(x+y) add(T x, U y)
{
	return x + y;
}
//////////////////////////////////////////////////////////////////



trailing return type sentaksýnýn ortaya çýkmasýnýn sebebi ise x+y'nin scope'u içinde olmamamýz.
Fonksiyonun geri dönüþ deðerinin yazýldýðý yerde x ve y görünmüyor, bilinir deðiller. O yüzden sýrf
scope'a dahil etmek için oraya auto yazýlýr. Fonksiyonun geri dönüþ deðerinin türü ise -> yanýna yazýlýr.
Bu durumda, x+y ifadesinin türü neyse derleyicinin yazdýðý fonksiyonun geri dönüþ deðerinin türü o olur.
Böylece üçüncü bir template tür parametresine de gerek kalmaz.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y)
{
	return x + y;
}

int main()
{
	cout << add(2.4, 5) << endl;
	cout << add(5, 2.4) << endl;
}
//////////////////////////////////////////////////////////////////



C++14 ile ise artýk decltype kullanýmýna da gerek yok.
Doðrudan fonksiyonun geri dönüþ deðerine auto yazýldýðýnda derleyici otomatik olarak geri dönüþ deðeri
türünü anlayýp ona göre kod üretir.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
auto add(T x, U y)
{
	return x + y;
}

int main()
{
	cout << add(2.4, 5) << endl;
	cout << add(5, 2.4) << endl;
}
//////////////////////////////////////////////////////////////////



18_02_2018_PAZAR


auto ile yapýlan deduction ile, templateler'de yapýlan deduction bir istisna dýþýnda tamamen ayný.
//////////////////////////////////////////////////////////////////
int func();

template<typename T>
void foo(T y);

int main()
{
	auto x = func(); //x'in türü int

	foo(14);
}
//////////////////////////////////////////////////////////////////
T türü int, çünkü gönderilen argüman int. T türünün ne olduðunu belirleyen foo'ya gönderilen argüman.
x'in ne olduðunu belirleyen ise = operatörünün yanýndaki ifade.
Kurallar birebir ayný, T türünün ne olduðu nasýl belirleniyorsa x'in türünün ne olduðu da öyle belirlenir.
x adeta template fonksiyondaki parametre deðiþkeni gibi, ona ilk deðer veren ifade de sanki template
fonksiyona gönderdiðimiz argüman.


x'in türü int. Buradaki kurallar ile diðer kurallarýn hiç bir farký yok. Bir tane template olsaydý,
template tür parametresi T olsaydý(T & deðil) o template'e ci'yi argüman olarak gönderseydik const int
deðil int olurdu, burada da ayný kural geçerli.	
//////////////////////////////////////////////////////////////////
const int ci = 5;

auto x = ci;
//////////////////////////////////////////////////////////////////



Þimdi ise ikinci kategoriye denk geldi. Template tür parametresi T, template fonksiyonunun parametresi T &.
//////////////////////////////////////////////////////////////////
const int ci = 5;

auto &x = ci;
//////////////////////////////////////////////////////////////////


Yani auto'da kullanýlan deduction ile template fonksiyonun parametre deðiþkeninin türü için yapýlan
deduction arasýnda pek fark yok, tek fark initializer list kullanýmýnda.


Aynýsý range based for loop için de geçerli, orada da type deduction var.
vector<string> svec; isimli vektörün string açýlýmý türünden bir svec nesnesi olsun
for(auto s : svec) ifadesinde, referans deklaratörü yok, kopyalama yapýlýr yani döngünün her turunda s,
svec'de tutulan öðenin kendisi deðil o öðe ile ilk deðerini alan baþka bir string nesnesi. s deðiþtirilirse
svec'deki öðe deðiþmez.
for(auto &s : svec) bu durumda s, vektördeki öðenin kendisi.
for(const auto &s : svec) yine vektördeki öðenin kendisi ama salt okuma amaçlý.



Class Templates (Sýnýf Þablonlarý)

STL demek aðýrlýklý olarak fonksiyon ve sýnýf þablonlarý demek. Tabi onun da kendi içinde ayrý kategorileri
var mesela fonksiyon þablonlarý, algoritmalar. Fonksiyon þablonlarýný vermesinin sebebi, bir veri yapýsýnda
önceden belirlenmiþ bir iþin yapýlmasý için gereken kodun üretilmesi. Örnek olarak arama, veri yapýsýnda
arama yapýlmak isteniyorsa baðlý liste de olsa, vektör de olsa, deque de olsa arama ayný isim ile yapýlýr.
Fakat aslýnda derleyici duruma göre compile time'da ayrý fonksiyonlar yazar. Ayný þablondan farklý veri
yapýlarý için, compile time'da farklý kodlar yazar. 

Sýnýf þablonu ise öyle bir metakod ki, derleyici o koddan compile time'da bir sýnýfýn kodunu yazar.
Sýnýf þablonu olduðunda avantajlar daha da artar. String sýnýfý bunun en güzel örneði, string sýnýfý
tamamen bir class template. Çok büyük bir sýnýf, çok sayýda fonksiyon var ama client kod bir fonksiyona 
çaðrý yapmadýkça o fonksiyonun kodu yazýlmaz. Sýnýf þablonlarý en çok veri yapýlarýný implemente eden
sýnýflarda iþe yarar. Dinamik dizi bir veri yapýsý, ama dinamik dizide int, double, string tutulabilir.
Eðer dinamik dizi veri yapýsý int'e göre yazýlmýþ olsaydý, belirli veri elemanlarý int türden olurdu, bazý
fonksiyonlarýn geri dönüþ deðeri türü int türden olurdu vs. String tutmak için ise yine ayný þekilde bu
sefer int yerine string kullanýlýrdý. C tarzý void pointerlar ile de çözüm saðlanabilirdi belki ama C++'ýn
çözümü bambaþka. Compile time'da o türe yönelik sýnýfýn kodu derleyici tarafýndan yazýlýr. Bir C kodunun
veri yapýsý ile ilgili verimliliði neyse, C++'da sýnýf þablonlarý da en az o kadar verimli. 


Sentaks, fonksiyon þablonlarýna benzer.
Artýk T türü veya T'den elde edilecek diðer türler(T *, T &, const T & gibi) veri elemanlarýnýn türü olarak,
fonksiyonlarýn parametrelerinin türü, geri dönüþ deðerlerinin türü olarak kullanýlabilir.
//////////////////////////////////////////////////////////////////
template<typename T>
class Myclass {

};
//////////////////////////////////////////////////////////////////


Daha önceki konularda, ilkel de olsa bir akýllý pointer sýnýfý yazmýþtýk(operator overloading konusunda)
T, smart pointer'ýn kontrol edeceði nesnenin türü.
Constructor düþünüldüðünde, T türü int ise parametresi int *. T türü Window ise parametresi Window *.
//////////////////////////////////////////////////////////////////
template<typename T> 
class SmartPtr {
	T *mp;
public:
	SmartPtr(T *p) : mp{p} {}
	~SmartPtr() { delete mp; }
	T &operator*() { return *mp; }
	T *operator->() { return mp };
};

int main()
{
	SmartPtr<string> sp{ new string{"Fethi"} };

	cout << *sp << endl;

	SmartPtr x; //geçersiz
}
//////////////////////////////////////////////////////////////////
Yanlýz bu bir sýnýfýn kendisi deðil. SmartPtr x; ifadesi bu yüzden geçersiz, böyle bir sýnýf yok ki.
Bu þablonun ismi, sýnýfýmýz ise bunun bir açýlýmý yani derleyiciye yazdýracaðýmýz sýnýf.
SmartPtr<string> dediðimizde derleyici bu þablondan hareketle T türünün string türü olduðunu öðrenir,
T türünün olduðu yerlerde string olacak þekilde kod yazar. Yukarýdaki kodda ok operatörü kullanýlmadý,
bu yüzden ok operatörü fonksiyonunun kodunu derleyici yazmaz. Derleyici bu þablondan ihtiyaç olduðu
zaman compile time'da farklý türler için kod yazar.


Farklý iki sýnýf türünün birbirine atanabilmesi için bu iþi yapan bir fonksiyon olmasý gerekir.
Ayný þablondan farklý türler için üretilmiþ sýnýflar farklý farklý sýnýflar, ayný template'den üretilmiþ
olmalarý bu sýnýflarý ayný yapmaz.
//////////////////////////////////////////////////////////////////
template<typename T> 
class Myclass {
public:
	void func(T x){}
};

int main()
{
	Myclass<double> m1;
	Myclass<int> m2;

	m1 = m2; //sentaks hatasý
}
//////////////////////////////////////////////////////////////////


Ayný þekilde geçersiz, ikisi kesinlikle farklý türler.
Bir sýnýf þablonunun belirli bir tür için açýlýmý ayrý bir sýnýf türü, baþka bir tür için açýlýmý ise
farklý bir sýnýf türü. Ýlave bir mekanizma saðlanmazsa birbirine assignable veya convertible deðil.
//////////////////////////////////////////////////////////////////
int main()
{
	vector<double> dvec;
	vector<int> ivec;

	dvec = ivec;
}
//////////////////////////////////////////////////////////////////


class Myclass{};
Myclass sýnýfý türünden nesne tanýmlanabilir, bu türden bir pointer oluþturulabilir, elemanlarý bu türden
olan bir dizi oluþturulabililr, fonksiyon parametresi ve geri dönüþ deðeri bu türden veya bu türden &
olabilir.

Bir þablondan üretilmiþ bir sýnýf içinde hiç fark yok.
vector<int> func(const vector<double> &)
C++'da son derece doðal bir kod. 


Derleyici compile time'da T türünün int olduðunu anlarsa vector'un int açýlýmý kullanýlýr.
STL'deki sýk kullanýlan mekanizmalardan. Bir fonksiyon þablonu baþka bir fonksiyon þablonunu açabileceði
gibi, bu örnekte olduðu gibi bir fonksiyon þablonu bir sýnýf þablonunu da açabilir.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(T x)
{
	std::vector<T> xvec;
}
//////////////////////////////////////////////////////////////////


Derleyici T türünün çýkarýmýný yaparken, yine bu fonksiyona ne gönderileceðine baðlý olarak çýkarým
yapar. dvec fonksiyonun parametresi olan x referansýna aktarýlýr. Bu aktarýmýn yapýlmasý için T'nin türünün
double olmasý gerekir.
Fonksiyona bir vector nesnesi gönderiliyor, gönderilen vektor nesnesine baðlý olarak çýkarým yapýlýyor.
Atamanýn yapýlmasý için T'nin double olmasý gerekiyor.
Bir fonksiyon þablonu, bir sýnýf þablonunu tür çýkarýmýnda da bu þekilde kullanýlabilir, çok yaygýn 
kullanýlan mekanizmalar.
//////////////////////////////////////////////////////////////////
template<typename T>
void func(std::vector<T> &x)
{
	T x{}; // x'in türü de double 
}
int main()
{
	vector<double> dvec;
	func(dvec);
}
//////////////////////////////////////////////////////////////////


Örnek olarak iki boyutlu bir dizi kullanmak istiyoruz. Ancak kullanýlacak matrisin satýr ve sütun sayýsý
da çalýþma zamanýnda belli olacak. vector'ün int açýlýmý da bir sýnýf, vektor template'ini vektor'un int
açýlýmý için tekrar açarsak, içinde vektor olan bir vektor oluþturulmuþ olur.	 
//////////////////////////////////////////////////////////////////
int main()
{
	vector<vector<int>> vec;
	
	///////////
	
	vec[12][34]+;
}
//////////////////////////////////////////////////////////////////
vec öyle bir vektör ki, öðe olarak int vektörler tutar.
Arada bazý baþka kodlar olduðu düþünülsün, köþeli parantez operatörü kullanýlabilir. Köþeli parantez
operatörü ile vektörde tutulan öðeye eriþilir, o da vektör onun da köþeli parantez operatörü kullanýlýr.



Bunlar farklý containerlar da olabilir. Öyle bir vektör oluþturulacak ki, vektördeki her bir öðe string
listesi olacak. Bu vektöre bir öðe eklendiði zaman, string listesi eklenir.
//////////////////////////////////////////////////////////////////

int main()
{
	vector<list<>string> xvec;
	
	//////

	xvec[2].front().size();
}
//////////////////////////////////////////////////////////////////
xvec[2] bir baðlý liste, string baðlý listesi.
xvec[2]. yapýldýðýnda . operatörü ile liste sýnýfýnýn interface'i görünür.
Listenin front isimli fonksiyonu referans yolu ile baðlý listedeki ilk elemana eriþir.
xvec[2].front() bir string olur.
xvec[2].front().size(), xvec vektöründe tutulan üçüncü string baðlý listesinin tuttuðu ilk stringin
uzunluðu elde edilmiþ oldu.
Buradaki tüm kodlar compile time'da yazýlýyor.



Sýnýf þablonlarýnda deduction yok, yani açýk açýk hangi türden açýlýmýn yapýlacaðý belirilmek zorunda.
Tabi default olarak yok, basit bir teknik ile derleyiciye bunun çýkarýmý yaptýrýlabilir.
Bir fonksiyon þablonu yazýlýr, buradan bir deduction yapýlýri çaðrýlan fonksiyon bir sýnýf nesnesi 
döndürür tabi derleyici fonksiyon þablonunda tür çýkarýmý yaptýðý için sýnýf þablonunun da hangi türe
açýlacaðýný derleyici compile time'da bilebilir.


Fonksiyona birinci parametre olarak gönderilen nesne int türdense, derleyici T türünün int olduðu çýkarýmýný
yapar. O zaman geri dönüþ deðeri ifadesinde de vector'un int açýlýmýný kullanýr. Dolayýsýyla fonksiyon
vektörün int açýlýmý türünden bir nesne döndürür. n ise kaç tane öðe ile baþlatýlacaðý bilgisi için 
vektörün constructor'ýna geçilir.
//////////////////////////////////////////////////////////////////
template<typename T>
std::vector<T> gvec(T x, size_t n)
{
	///
	return vector<T>(n);
}

int main()
{
	int ival;

	auto vec = gvec(ival, 50);  
}
//////////////////////////////////////////////////////////////////
vec, gvec'in geri dönüþ deðeri türünden. gvec ise bir fonksiyon þablonu, derleyici gvec fonksiyon þablonuna
çaðrý yapýldýðý için T türünün int olarak çýkarýmýný yaptý. Ýkinci parametreye de 50 gönderildi. Böylece
vec içinde 50 tane int nesne tutan bir nesne haline geldi.



Özellikle sýnýf þablonlarýnýn varsayýlan tür argümaný almasý STL'de çok sýk karþýlaþýlýr. STL containerlarý
böyle.
//////////////////////////////////////////////////////////////////
template<typename T, typename U = int>
class Myclass{
}
//////////////////////////////////////////////////////////////////
Bu durumda, birinci template tür parametresi söylenir ancak ikincisi söylenmezse int anlaþýlýr.


Vektörde bir template, ikinci template tür parametresi bildirimezse vektörün int açýlýmý türü kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename T, typename U = vector<int>>
class Myclass {

};
//////////////////////////////////////////////////////////////////


Burada ise örnek olarak Myclass int'e açýlýrsa, T türüni derleyici int olarak yorumlar.
Bu durumda da ikinci parametreye vector'un T açýlýmýný default olarak açar.
Myclass<int> çaðrýsý, Myclass<int, vector<int>> çaðrýsýna dönüþtürülmüþ olur.
//////////////////////////////////////////////////////////////////
template<typename T, typename U = vector<T>>
class Myclass {

};
int main()
{
	Myclass<int> x;
}
//////////////////////////////////////////////////////////////////



String sýnýfý için þöyle bir örnek verilebilir. Sýnýfýn türü gerçekten bu, bizim kullandýðýmýz string
sýnýfý böyle bir sýnýf. Peki nasýl oluyor da string ifadesi bu anlama geliyor ?
//////////////////////////////////////////////////////////////////
int main()
{
	basic_string<char, char_traits<char>, allocator<char>> str{"necati"};

	string s{"necati"};
}
//////////////////////////////////////////////////////////////////


Bu template varsayýlan tür argümaný alýr, template aslýnda þu þekilde;
3 tane template tür parametresi var. Ortada bir sýnýf þablonu var.
Ýkinci ve üçüncü template tür parametreleri varsayýlan tür argümaný alýrlar.
BasicString<char> idadesi aslýnda BasicString<char, char_traits<char>, allocator<char>> ifadesine
dönüþtürülür. Bunun üstüne bir de typedef bildirimi yapýlmýþ, eðer BasicString char türüne açýldýysa o
türe string denmiþ. Yani aslýnda BasicString<char, char_traits<char>, allocator<char>> türü string türüne
typedef edilmiþ.
//////////////////////////////////////////////////////////////////
template<typename C, typename T = char_traits<char>, typename A = allocator<C>>
class BasicString{
};
typedef BasicString<char> string
//////////////////////////////////////////////////////////////////


Template sentaksýný yazmak zaman zaman zor olduðundan birçok durumda typedef bildirimleri sýk kullanýlýr.
Ancak modern C++'da typedef bildirimleri yerine geçen using yapýsý da kullanýlýr.
//////////////////////////////////////////////////////////////////
//typedef int word;
using word = int;

//typedef int(*FCMP)(const char *, const char *);
using FCMP = int(*)(conar char *, const char*);
//////////////////////////////////////////////////////////////////


using, typedef ile tamamen ayný þey deðil. using ile yapýlabilen ancak typedef ile yapýlamayan bazý 
bildirimler var. using'in eklenmesi motivasyonlarýndan biri de bu.
typedef bildirimleri template olarak yapýlamaz ancak using bildirimleri template olarak yapýlabilir.

Artýk VSvec ismi kullanýldýðýnda açýsal parantez kullanmaya gerek yok. typedef bildirimleri template olarak
yapýlamazdan kastedilen bu deðil. Bu typedef ile de yapýlabilir, using ile de. 
Bir typedef ismi baþka bir typedef isminde de kullanýlabilir.
//////////////////////////////////////////////////////////////////
typedef std::vector<std::vector<std::string>> VSvec; //typedef kullanýlarak geçerli
typedef std::vector<std::string> Svec; //Svec artýk doðrudan içinde string tutan vektör türünün typedef'i
typedef std::list<Svec> Con; //Svec burada kullanýlabilir, Con içinde string vektörü tutan baðlý liste
							 //türünün typedef ismi
//////////////////////////////////////////////////////////////////


STL'in en çok kullanýlan yapýlarýndan(struct) biri pair yapýsý(utility baþlýk dosyasý içinde)
pair, iki tane türü tek bir türmüþ gibi kullanmaya olanak saðlayan, olabilecek en basit template.
En fazla kullanýldýðý yer bir fonksiyondan iki tane deðer döndürmek için. Ýki tür bir arada paketlenmek
isteniyor ama bu ayrý bir tür olmayý hakedecek kadar da özel deðil. Yani ortada interface'i hakedecek bir
durum olmaz, tek neden bunlarýn fonksiyondan birlikte aktarýlmasý. Bu tür durumlarda pair sýk kullanýlýr.
C++11 ile standart hale gelen tuple'lar da bu iþ için kullanýlýr, tuple'lar pair'in çoklusu. 2 tane tür
paketlenmek isteniyorsa pair, daha fazlasý için ise tuple. Pair þöyle bir tür;
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
struct Pair {
	T first;
	U second;
};

int main()
{
	pair<int, double> idp; //orjinal STL'deki pair sýnýfý

}
//////////////////////////////////////////////////////////////////
Pair bir yapý, elemanlarý public olan bir template class. Ýki öðesi var, birinci data member', T türünden
diðeri ise U türünden. Pair<int, double> idp ifadesi ile template türünden bir sýnýf yazdýrýlýr, T türü 
olarak int, U türü olarak double alýnýr.


Pair sýnýfýnýn default constructor'ý þöyle yazýlmýþ: Primitif veri öðeleri söz konusu olduðunda first ve
second 0'a çekilir.
//////////////////////////////////////////////////////////////////
int main()
{
	pair<int, double> idp;

	cout << idp.first << "  " << idp.second << endl;
}
//////////////////////////////////////////////////////////////////


Eðer T veya U türleri, user defined türlerdense onu da default constructor'ý ile çaðýrýr.
Arkaplandaki kod sanki þu þekilde:
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
struct Pair{
	T first;
	U second;
	Pair() : first{}, second{} {} //default constructor
	Pair(const T &t, const U &u) : first{t}, second{u} {} //parametreli constructor
}
//////////////////////////////////////////////////////////////////
C++'da; int x{}; þeklinde primitif türlerden bir deðiþkende oluþturulabilir. C'de geçerli olmayan bu 
sentaks C++'da primitif türler için geçerli ve deðiþkenin deðerini oluþtuktan sonra 0'a çeker. Yukarýdaki
default ctor düþünüldüðünde eðer first veya second primitif türlerdense deðeri 0 olacak, user defined
türlerdense de default constructor'larý çaðrýlacak.


Pair sýnýfý için aþaðýdaki gibi bir örnek verilebilir. Öncelikle pair sýnýfý türünden;
pair<Date, string> dsp{ x, s }; dsp nesnesi oluþturulur. Burada x Date türünden, s ise string türünden.
Ayný zamanda pair sýnýfýnýn orjinal make_pair isimli bir fonksiyon þablonu var, bu fonksiyonu kullanarak
doðrudan tür belirtip açýlým yapýlmadan da pair türünden sýnýf nesnesi oluþturulabilir. make_pair 
fonksiyonuna benzer bir Make_pair þekildeki gibi yazýlmýþtýr. Fonksiyon þablonu pair türünden bir geçici
nesne ile geri dönerek, fonksiyon þablonu olduðundan türler için derleyici çýkarým yapýp pair'i oluþturur.
Derleyici make_pair(x, s); ifadesinde compile time'da x ve s'nin türünün çýkarýmý yapar, fonksiyonun
geri dönüþ deðerinin türünü de ona göre belirler. Template sentaksý hiç kullanýlmadan bir pair oluþturuldu.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
std::pair<T, U>Make_pair(const T &t, const U &u)
{
	return pair<T, U>{t, u};
}
int main()
{
	Date x{ 12, 5, 1987 };
	string s{ "ali aksoy" };

	//pair<Date, string> dsp{ x, s };

	auto dsp = make_pair(x, s);
}
//////////////////////////////////////////////////////////////////


Ýþte using bildiriminin eklenme nedeni aþaðýdaki sentaks. using bildiriminin þablonlaþtýrýlmýþ hali.
Spair bir template tür olarak kullanýlýr ve onun int açýlýmý alýnýrsa o pair'in string ve int açýlýmý olur.
Bunun typedef ile yapýlmasý mümkün deðil. Böyle template haline getirilmiþ typedef bildirimleri için
using bildirimi kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename T>
using Spair = std::pair<string, T>;

int main()
{
	Spair<int> x; //pair<string, int>
	Spair<Date> y; //pair<string, Date>
}
//////////////////////////////////////////////////////////////////



Bir baþka örnek ise set. Aslýnda set þöyle bir template:
less, STL'in yine template sýnýflarýndan biri. Ýkinci template tür parametresi olarak less kullanýldýðý
zaman set'deki dizi küçükten büyüðe doðru. Ama küçükten büyüðe deðil, büyükten küçüðe doðru bir set
oluþturulmak istenirse o zaman ikinci template tür parametresi buna uygun olarak verilmeli. O türün ismi
ise greater.
//////////////////////////////////////////////////////////////////
template<typename T, typename C = less<T>, typename A = allocator<T>>
class Set{
};
//////////////////////////////////////////////////////////////////


set'in string açýlýmý kullanýldý. ikinci template tür parametresi default olduðundan less<string>
olmuþ oldu. Bu durumda setteki düzen küçükten büyüðe doðru oldu.
//////////////////////////////////////////////////////////////////
int main()
{
	set<string> myset { "deniz", "riza", "aykut", "huseyin" };

	for (const auto &s : myset)
		cout << s << " ";
	cout << endl;
}
//////////////////////////////////////////////////////////////////



Bunu büyükten küçüðe doðru yapmak için ise greater kullanýlýr; ikinci parametreye geçilir 
set<string, greater<string>> türünden bir nesne oluþturulurdu.
Hatta bir using bildirimi ile bunu doðrudan kullanmak þu þekilde mümkün yani greater<T> sabit olup
yalnýzca T türüne deðer verilebilir. Böylece uzun uzun greater<string> açýlýmý yazýlmasýna gerek kalmaz.
//////////////////////////////////////////////////////////////////
template<typename T>
using Gset = std::set<T, std::greater<T>>;
int main()
{
	Gset<string> myset { "deniz", "riza", "aykut", "huseyin" };

	for (const auto &s : myset)
		cout << s << " ";
	cout << endl;
}
//////////////////////////////////////////////////////////////////



x = y ifadesi farklý türler olduklarý için geçersiz.
Ancak gerçek pair sýnýfý için a = b ifadesi geçerli.
pair sýnýfýnda farklý türlerden pair'leri birbirine ataycak bir mekanizma var. Bizim yazdýðýmýz Pair'de yok.
Bu mekanizmaya member template denir.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
struct Pair {
	T first;
	U second;
};

int main()
{
	Pair<double, double> x;
	Pair<int, int> y;

	x = y; //error

	pair<double, double> a;
	pair<int, int> b;

	a = b; //geçerli
}
//////////////////////////////////////////////////////////////////



Myclass bir sýnýf þablonu. Bir üye fonksiyonu var, üye fonksiyonu da yine Myclass'ýn T açýlýmý türünden.
Sýnýfýn scope'u içinde olunduðundan, Myclass<T> yerine doðrudan Myclass yazýlabilir.
x.func(y)'nin geçerli olma sebebi, x Myclass'ýn double açýlýmý olduðundan, sýnýf için fonksiyonun parametre
deðiþkeninin türü de Myclass<double> türünden, y nesnesi de ayný türden olduðundan geçerli.
Ancak x.func(z) ifadesinde türler farklý olduðundan çaðrý geçersiz.
//////////////////////////////////////////////////////////////////
template<typename T>
class Myclass {
public:
	void func(Myclass);
};

int main()
{
	Myclass<double> x;
	Myclass<double> y;
	Myclass<int> z;

	x.func(y); //geçerli
	x.func(z); //geçersiz
}
//////////////////////////////////////////////////////////////////



Bu ifadenin legal olmasý için gereken, Myclass'ýn double açýlýmýnýn öyle bir func fonksiyonu olmalý ki
parametresi Myclass'ýn int açýlýmý türünden olacak. Bunu derleyiciye yazdýrmak mümkün. Ýþte derleyiciye
böyle kodlar yazdýrmaya yarayan yapýya member templates denir.
tekrar bir template keywordü kullanýlýr ancak tür ismi olarak farklý bir isim kullanýlýr.
Böylece fonksiyona Myclass<int> türünden bir argüman gönderilirse, derleyici U türünün int olmasý
gerektiðini anlar ve fonksiyonu Myclass<int> açýlýmý türünden olacak þekilde parametreye sahip bir 
fonksiyon yazar.

//////////////////////////////////////////////////////////////////
template<typename T>
class Myclass {
public:
	template<typename U>
	void func(Myclass<U>);
};

int main()
{
	Myclass<double> x;
	Myclass<int> y;

	x.func(y); //geçerli
}
//////////////////////////////////////////////////////////////////



pair sýnýfýnýn copy constructor'ý da bu þekilde yazýlmýþtýr. Bizim pair sýnýfýna benzeterek yazdýðýmýz
Pair sýnýfý için copy constructor aþaðýdaki gibidir. Derleyici farklý türler için copy constructor için
fonksiyon yazar. Tabi burada dikkat edilmesi gereken tür uyumunun korunmasý ayný þekilde gerekiyor. 
Birbirlerine ilk deðer verebilir türler olmasý gerekiyor. Yani örnek olarak Pair'in string açýlýmýna, 
Pair'in int, int açýlýmý atanýrsa bu fonksiyon çalýþýr, int string'i initialize edemediði için sentaks 
hatasý olur. Böyle bir özellik var ama tabi tür uyumunun korunmasý gerekiyor. 
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
class Pair {
	T first;
	U second;
public:
	Pair() : x{}, y{} {}
	template<typename X, typename Y>
	Pair(const Pair<X, Y> &p) : first(p.first), second(p.second) {}
};
//////////////////////////////////////////////////////////////////


make_pair("Murat", "Hasan") ifadesinin türü pair<const char *, const char *> açýlýmý.
Yani ilk deðer veren ifade pair<const char *, const char *> türünden. p ise pair<strin, string> açýlýmý
türünden. member template olmasa bu mümkün kýlýnmazdý.
//////////////////////////////////////////////////////////////////
int main()
{
	pair<string, string> p = make_pair("Murat", "Hasan");

}
//////////////////////////////////////////////////////////////////


Bir template sýnýftan açýlan sýnýf, o template'in baþka bir açýlýmý ile ayrý bir türdür, bunlar 
birbirine atanamaz. Ancak arkada member template yapýsý kullanýlmýþsa bu atama geçerli kýlýnabilir.



Bir pair'i çýkýþ akýmýna vermek için yazýlan global operator<< fonksiyonu aþaðýdaki þekilde yazýlabilir.
Bu operator<< fonksiyonu bir fonksiyon þablonu, böylece pair'in farklý açýlýmlarý için bu fonksiyon 
kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
std::ostream & operator<<(std::ostream &os, const std::pair<T, U> &p)
{
	return os << "(" << p.first << ", " << p.second << ")";
}

int main()
{
	auto p1 = make_pair("hasan", "huseyin");
	auto p2 = make_pair(bitset<32>{654321U}, 289);


	cout << p1 << endl;
	cout << p2 << endl;

	cout << make_pair(p1, p2) << endl;
}
//////////////////////////////////////////////////////////////////


iki tane pair karþýlaþtýrýlabilir. pair'in tüm karþýlaþtýrma operatörleri overload edilmiþtir.
first'i küçük olan küçüktür, eðer firstler eþitse second'a bakýlýr. her ikisi de eþitse, ikisi de eþittir.


Bütün containerlarýn begin ve end fonksiyonlarý var. Bir de global begin ve end fonksiyonlarý var.
Örnek olarak bir vektor tanýmlanýyor ve de primitif int türden bir dizi var, peki nasýl oluyor da her 
ikisi için de begin fonksiyonu kullanýlýr ? 
//////////////////////////////////////////////////////////////////
int main()
{
	vector<string> svec;
	int a[100];

	begin(svec);
	begin(a);
}
//////////////////////////////////////////////////////////////////
begin bir template fonksiyon, hem de global bir fonksiyon. 



Bu, template'lerin özelliþtirilmesi ile mümkün. Öyle bir mekanizma ki farklý türler için farklý 
template'lerin kullanýlmasýna olanak saðlar. Özelleþtirme(specialization) belirli türler için veya tür
gruplarý için bir template yerine baþka bir template'in kullanýlmasýný saðlamak.	


Myclass'ýn int dýþýndaki açýlýmlarý için yukarýdaki template kullanýlýr. Ancak int açýlýmlarý için
aþaðýdaki template kullanýlýr. Derleyici bunu compile time'da seçer.
Interface'lerin ayný olmasý gerekmiyor, aþaðýdaki Myclass interface'i yukarýdakinden tamamen de farklý 
olabilir.
Üstteki template için master template terimi kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename T>
class Myclass {
public:
	Myclass()
	{
		std::cout << "Myclass<T> typename T is : " << typeid(T).name() << std::endl;
	}
};

template<>
class Myclass<int> {
public:
	Myclass()
	{
		std::cout << "Myclass<int>" << std::endl;
	}
};

int main()
{
	Myclass<double> dval;
	Myclass<int> ival;

}
//////////////////////////////////////////////////////////////////
Birinci template(Myclass<double>) üstteki template'den açýlýr. Ýkincisi ise alttaki template'den açýlýr.


Bu da kullanýlan sentaks özelliklerinden biri. Pointer açýlýmlarý için aþaðýdaki template kullanýlýr.
Pointer olmayan açýlýmlar için ise yukarýdaki kullanýlýr.
//////////////////////////////////////////////////////////////////
template<typename T>
class Myclass {
public:
	Myclass()
	{
		std::cout << "Myclass<T> typename T is : " << typeid(T).name() << std::endl;
	}
};

template<typename T>
class Myclass<T *> {
public:
	Myclass()
	{
		std::cout << "Myclass<T *>" << std::endl;
	}
};

int main()
{
	Myclass<int> x;
	Myclass<string> s;
	Myclass<double *>  z;
}
//////////////////////////////////////////////////////////////////


Ýki template tür parametresi ayný olduðunda aþaðýdaki template'den açýlýr. Farklý olduklarýnda ise 
yukarýdaki template'den açýlýr.	
//////////////////////////////////////////////////////////////////
template<typename T, typename U>
class Myclass {
public:
	Myclass()
	{
		std::cout << "Myclass<T, U>" << std::endl;
	}
};

template<typename T>
class Myclass<T, T> {
public:
	Myclass()
	{
		std::cout << "Myclass<T, T>" << std::endl;
	}
};

int main()
{
	Myclass<int, int> x{}; //alttakinden açýlýr
	Myclass<int, double> y{}; //yukarýdakinden açýlýr
}
//////////////////////////////////////////////////////////////////


STL'den bir örnek, vector sýnýf þablonunun bool açýlýmý bir özelleþtirme. vector'un diðer açýlýmlarý
normal vector template'inden üretilir ama bool açýlýmý için ayrý bir template verilmiþ.
bool, bir int'de tutulabilen bir veri o zaman vector'un bool açýlýmý gereksiz bellek alaný kullanmasýn,
boolean deðerleri bit seviyesinde tutsun diye böyle bir farklýlýk yapýlmýþ. O yüzden vector'un bool
açýlýmý baþka bir interface'e sahip.



Normal bir sýnýfýn üye fonksiyonu template olabilir, bir engel yok.
Myclass türünden bir nesne *this olarak kullanýlýp func fonksiyonuna onunla çaðrý yapýldýðýnda func'a
hangi türden argüman gönderilirse derleyici o parametrik yapýda func fonksiyonu yazar. Fonksiyon 
þablonlarýnda nasýlsa burada da öyle.
//////////////////////////////////////////////////////////////////
class Myclass{
public:
	template<typename T>
	void func(T x)
	{
		std::cout << typeid(T).name() << std::endl;
	}
};
int main()
{
	Myclass m;

	m.func(10);
	m.func(1.5);	
	m.func(5L);
}
//////////////////////////////////////////////////////////////////


STL'in önemli bazý sýnýflarý non-type parametre sýnýflarý, yani sadece sabitin ne olduðu bildirilir.
Bunlardan biri bitset, bitsel iþlemler için tasarlanmýþ bir sýnýf. Bitsel manipülasyon iþlemleri bu
sýnýfta yapýlabilir ve de C'de bitsel iþlemlerini yapmak ile ayný maliyette.
bitset<16> ifadesi ile boyut olarak 16 bit olacaðý belirtilmiþtir.
//////////////////////////////////////////////////////////////////
int main()
{
	bitset<16> x{1234}; //bitset<16> ifadesinde non type parametre girilir, tür deðil boyut girilir.

	cout << x << endl;
}
//////////////////////////////////////////////////////////////////



non-type parametreli örnek bir sýnýf þablonu:
random template'inden açýlým yapmak için derleyiciye low ve high sabitlerinin kaç olduðu geçilmeli.
Derleyici random<30, 50> x; ifadesini gördüðünde yukarýdaki þablondan gerçek bir sýnýfýn kodunu yazarken
low kullanýlan yerde 30 sabitini, high kullanýlan yerde 50 sabitini kullanýr.
//////////////////////////////////////////////////////////////////
template<size_t low, size_t high>
class random {
public:
	int operator()() {
		return rand() % (high - low + 1) + low;
	}
};


int main()
{
	random<30, 50> x;
}
//////////////////////////////////////////////////////////////////




24_02_2018_CUMARTESÝ

